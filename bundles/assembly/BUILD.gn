# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/assembly_input_bundle.gni")
import("//build/assembly/assembly_resources_directory.gni")
import("//build/assembly/kernel_aib.gni")
import("//build/bazel/bazel_inputs.gni")
import("//build/icu/icu_assembly_input_bundle.gni")
import("//bundles/assembly/platform_aibs.gni")
import("//src/lib/icu/tzdata/icu_tzres_source.gni")
import("//third_party/sbase/binaries.gni")
import("//zircon/kernel/phys/qemu.gni")

########
# Guaranteed Invariants
#
#
# Invariants that are guaranteed by these platform-defined Assembly Input
# Bundles (AIBs):
#
# 1) Their contents are bitwise identical for all boards and products, for a
#    given architecture and "debug" vs. "release".  They could be built once-
#    each for the following, and then used as prebuilts if the build supported
#    that:
#      - x64-release
#      - x64-debug
#      - arm64-release
#      - arm64-debug
#    This is not currently possible given the state of the in-tree build, but it
#    is a contract that we have for using these with our OOT product assembly
#    environments.
#
# 2) Each AIB directly lists files that it includes, or the label to the exact
#    GN target that it includes.  They do not include group() targets.
#
# 3) Any single artifact is only included in one AIB.

########
# Maintenance Guidelines
#
# DO:  Prefer verboseness and clarity over abstractions and delegation.
#
# The template used in this file requires the direct listing of the package,
# config_data, and bootfs labels or entries.
#
# DO NOT: import a file that defines, for example, a list of labels or a set of
# config_data entries, that are added to an AIB using a GN variable.
#
# Importing other files which define variables used to provide the contents for
# an AIB reduces the clarity of how an artifact gets included first in AIBs, and
# later the assembled image.  This makes it harder to reason about how and when
# the artifacts are included within the assembled product.

assert(is_fuchsia,
       "Assembly Input Bundles can only be in the Fuchsia toolchain")

# All of the platform assembly input bundles.
group("assembly") {
  testonly = true

  # eng_platform_aib_labels come from //bundles/assembly/platform_aibs.gni.
  deps = eng_platform_aib_labels

  # Coverage and sanitizer builders rename the shared libs, therefore ignore them.
  # RISCV skips some artifacts, therefore we also ignore that.
  if (!is_coverage && !is_asan && !is_hwasan && current_cpu != "riscv64") {
    deps += [ "//bundles/assembly/scrutiny" ]
  }
}

########
#
# The Zircon kernel itself
#
# This uses a specialized template to create the AIB.
kernel_assembly_input_bundle("zircon") {
}

########
#
# The /bootstrap realm AIBs
#
# The most-common, most-basic, Assembly Input Bundles that are included by all
# assembled systems.  No system can function without these.
#
# These provide the `/bootstrap` realm and its children that are always present
# in each of the build-types.
#

# The most-common, most-basic, AIB that is included in all assembled systems,
# regardless of build-type.
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("bootstrap") {
  bootfs_files_labels = [
    "//build/info/bootfs",
    "//src/bringup:bootfs",
    "//src/sys/component_manager:bootfs",
  ]
  bootfs_packages = [
    "//src/bringup/bin/svchost:pkg",
    "//src/bringup/bin/device-name-provider:package",
    "//src/bringup/bin/miscsvc:package",
    "//src/bringup/bin/pwrbtn-monitor:package",
    "//src/bringup/bin/sysinfo:package",
    "//src/diagnostics/archivist:package",
    "//src/power/shutdown-shim:package",
    "//src/sys/root:package",
    "//src/sys/startup:package",
    "//src/zircon/bin/role_manager:package",
  ]
  kernel_cmdline = [ "blobfs.cache-eviction-policy=NEVER_EVICT" ]

  compiled_packages = [
    {
      bootfs_unpackaged = true
      name = "bootstrap"
      components = [
        {
          component_name = "bootstrap"
          shards = rebase_path("//src/sys/bootstrap/meta/bootstrap.cml",
                               root_build_dir)
        },
      ]
    },
  ]

  boot_driver_packages = [
    {
      package_target = "//src/connectivity/bluetooth/hci/transport/usb:package"
      driver_components = [ "meta/bt-transport-usb.cm" ]
    },
    {
      package_target = "//src/connectivity/ethernet/drivers/asix-88179:package"
      driver_components = [ "meta/asix-88179.cm" ]
    },
    {
      package_target = "//src/connectivity/ethernet/drivers/asix-88772b:package"
      driver_components = [ "meta/asix-88772b.cm" ]
    },
    {
      package_target = "//src/connectivity/ethernet/drivers/ethernet/netdevice-migration:package"
      driver_components = [ "meta/netdevice-migration.cm" ]
    },
    {
      package_target = "//src/connectivity/ethernet/drivers/usb-cdc-ecm:package"
      driver_components = [ "meta/usb-cdc-ecm.cm" ]
    },
    {
      package_target =
          "//src/connectivity/network/drivers/network-device:package"
      driver_components = [ "meta/network-device.cm" ]
    },
    {
      package_target = "//src/devices/adc/drivers/adc:package"
      driver_components = [ "meta/adc.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/core:package"
      driver_components = [ "meta/block.core.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/gpt:package"
      driver_components = [ "meta/gpt.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/ramdisk:package"
      driver_components = [ "meta/ramdisk.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/sdmmc:package"
      driver_components = [ "meta/sdmmc.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/usb-mass-storage:package"
      driver_components = [ "meta/usb-mass-storage.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/zxcrypt:package"
      driver_components = [ "meta/zxcrypt.cm" ]
    },
    {
      package_target = "//src/devices/bus/drivers/platform:package"
      driver_components = [
        "meta/platform-bus.cm",
        "meta/platform-bus.proxy.cm",
      ]
    },
    {
      package_target = "//src/devices/clock/drivers/clock:package"
      driver_components = [ "meta/clock.cm" ]
    },
    {
      package_target = "//src/devices/gpio/drivers/gpio:package"
      driver_components = [ "meta/gpio.cm" ]
    },
    {
      package_target = "//src/devices/i2c/drivers/i2c:package"
      driver_components = [ "meta/i2c.cm" ]
    },
    {
      package_target = "//src/devices/ml/drivers/usb-harriet:package"
      driver_components = [ "meta/usb-harriet.cm" ]
    },
    {
      package_target = "//src/devices/power/drivers/power:package"
      driver_components = [ "meta/power.cm" ]
    },
    {
      package_target = "//src/devices/pwm/drivers/pwm:package"
      driver_components = [ "meta/pwm.cm" ]
    },
    {
      package_target = "//src/devices/serial/drivers/ftdi:package"
      driver_components = [ "meta/ftdi.cm" ]
    },
    {
      package_target = "//src/devices/serial/drivers/serial:package"
      driver_components = [ "meta/serial.cm" ]
    },
    {
      package_target = "//src/devices/serial/drivers/serial-async:package"
      driver_components = [ "meta/serial-async.cm" ]
    },
    {
      package_target = "//src/devices/serial/drivers/usb-cdc-acm:package"
      driver_components = [ "meta/usb-cdc-acm.cm" ]
    },
    {
      package_target = "//src/devices/spi/drivers/spi:package"
      driver_components = [ "meta/spi.cm" ]
    },
    {
      package_target = "//src/devices/sysmem/drivers/sysmem:package"
      driver_components = [ "meta/sysmem.cm" ]
    },
    {
      package_target = "//src/devices/usb/drivers/usb-bus:package"
      driver_components = [ "meta/usb-bus.cm" ]
    },
    {
      package_target = "//src/devices/usb/drivers/usb-composite:package"
      driver_components = [ "meta/usb-composite.cm" ]
    },
    {
      package_target = "//src/devices/usb/drivers/usb-hub:package"
      driver_components = [ "meta/usb-hub.cm" ]
    },
    {
      package_target = "//src/graphics/display/drivers/coordinator:package"
      driver_components = [ "meta/display-coordinator.cm" ]
    },
    {
      package_target = "//src/media/audio/drivers/usb-audio:package"
      driver_components = [ "meta/usb-audio.cm" ]
    },
    {
      package_target = "//src/storage/fvm/driver:package"
      driver_components = [ "meta/fvm.cm" ]
    },
    {
      package_target = "//src/ui/input/drivers/hid:package"
      driver_components = [ "meta/hid.cm" ]
    },
    {
      package_target = "//src/ui/input/drivers/buttons:package"
      driver_components = [ "meta/buttons.cm" ]
    },
    {
      package_target = "//src/ui/input/drivers/hid-input-report:package"
      driver_components = [ "meta/hid-input-report.cm" ]
    },
    {
      package_target = "//src/ui/input/drivers/usb-hid:package"
      driver_components = [ "meta/usb-hid.cm" ]
    },

    # TODO(https://fxbug.dev/42082105): Carve out usb-peripheral-stack drivers for specific products/boards.
    {
      package_target =
          "//src/connectivity/ethernet/drivers/rndis-function:package"
      driver_components = [ "meta/rndis-function.cm" ]
    },
    {
      package_target =
          "//src/connectivity/ethernet/drivers/usb-cdc-function:package"
      driver_components = [ "meta/usb-cdc-function.cm" ]
    },
    {
      package_target = "//src/devices/block/drivers/ums-function:package"
      driver_components = [ "meta/ums-function.cm" ]
    },
    {
      package_target = "//src/devices/usb/drivers/usb-peripheral:package"
      driver_components = [ "meta/usb-peripheral.cm" ]
    },
  ]
}

# The most-common, most-basic, AIB that is included in all userdebug and eng
# systems.
#
assembly_input_bundle("bootstrap_userdebug") {
  bootfs_files_labels = [
    # tools
    "//src/bringup/bin/debuglog:bootfs",
    "//src/bringup/bin/dlog:bootfs",
    "//src/bringup/bin/waitfor:bootfs",
    "//src/connectivity/network/bin/ping:bootfs",
    "//src/developer/forensics/crasher/cpp:bootfs",
    "//src/devices/block/bin/disk-inspect:bootfs",
    "//src/devices/block/bin/fvm-check:bootfs",
    "//src/devices/nand/bin/nand-loader:bootfs",
    "//src/devices/nand/bin/nand-util:bootfs",
    "//src/devices/usb/bin/usbctl",
    "//src/storage/bin/dd:bootfs",
    "//src/storage/bin/df:bootfs",
    "//src/storage/bin/storage-metrics:bootfs",
    "//src/sys/bin/psutils:bootfs",
    "//src/sys/tools/component:bootfs",
    "//src/zircon/bin/kcounter:bootfs",
    "//src/zircon/bin/kstress:bootfs",
    "//src/zircon/bin/ktrace:bootfs",
    "//src/zircon/bin/loadgen:bootfs",

    # shell
    "//zircon/third_party/uapp/dash:bootfs",
  ]

  # Do not automatically include pistress, but build it to keep it from
  # bit-rotting.
  deps = [ "//src/zircon/bin/pistress:bootfs" ]

  boot_driver_packages = [
    {
      package_target = "//src/devices/nand/drivers/broker:package"
      driver_components = [ "meta/nand-broker.cm" ]
    },
  ]
}

# The most-common, most-basic, AIB that is included in all eng systems.
#
assembly_input_bundle("bootstrap_eng") {
  testonly = true
  bootfs_files_labels = [
    # tools
    "//src/devices/acpi/bin/acpidump:bootfs",
    "//src/devices/bin/driver_tools:bootfs",
    "//src/devices/bin/lsdev:bootfs",
    "//src/devices/block/bin/biotime:bootfs",
    "//src/devices/block/bin/gpt:bootfs",
    "//src/devices/block/bin/iochk:bootfs",
    "//src/devices/block/bin/iotime:bootfs",
    "//src/devices/block/bin/lsblk:bootfs",
    "//src/devices/block/bin/sdio:bootfs",
    "//src/devices/cpu/bin/cpuctl:bootfs",
    "//src/devices/gpio/bin/gpioutil:bootfs",
    "//src/devices/i2c/bin:bootfs",
    "//src/devices/power/bin/lspwr:bootfs",
    "//src/devices/ram/bin/ram-info:bootfs",
    "//src/devices/registers/bin/register-util:bootfs",
    "//src/devices/spi/bin/spiutil:bootfs",
    "//src/devices/thermal/bin/temperature-cli:bootfs",
    "//src/devices/thermal/bin/thermal-cli:bootfs",
    "//src/devices/usb/bin/lsusb:bootfs",
    "//src/diagnostics/iquery:bootfs",
    "//src/media/audio/tools/audio-driver-ctl:bootfs",
    "//src/security/bin/syscall-check:bootfs",
    "//src/ui/backlight/bin/backlight:bootfs",
    "//src/ui/input/bin/hid:bootfs",

    # tests
    "//src/devices/block/bin/blktest:bootfs",
    "//src/devices/tee/bin:bootfs",
    "//src/graphics/display/bin/display-test:bootfs",
    "//src/zircon/tests/evil:bootfs",
  ]

  # Do not automatically include these tools, but build them to keep them from
  # bit-rotting.
  deps = [
    "//src/devices/pwm/bin/pwmctl:bootfs",
    "//src/ui/light/bin/lights-cli:bootfs",
    "//src/zircon/testing/mutex_pi_exerciser:bootfs",
  ]
}

# The console AIB is included by all eng and userdebug products.
#
assembly_input_bundle("console_userdebug") {
  bootfs_packages = [
    "//src/bringup/bin/console:package",
    "//src/bringup/bin/console-launcher:package",
  ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path(
                  [
                    "//src/bringup/bin/console/meta/console.shard.cml",
                    "//src/bringup/bin/console/meta/console-userdebug.shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# The console_user AIB is included by all user products.
#
assembly_input_bundle("console_user") {
  bootfs_packages = [
    "//src/bringup/bin/console:package",
    "//src/bringup/bin/console-launcher:package",
  ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path(
                  [
                    "//src/bringup/bin/console/meta/console.shard.cml",
                    "//src/bringup/bin/console/meta/console-user.shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# The ptysvc AIB is included by all eng and userdebug products.
#
assembly_input_bundle("ptysvc") {
  bootfs_packages = [ "//src/bringup/bin/ptysvc:package" ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path(
                  [ "//src/bringup/bin/ptysvc/meta/ptysvc.bootstrap_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# The virtcon AIB is included by all eng and userdebug products, and can be
# optionally included by user products.
#
assembly_input_bundle("virtcon") {
  bootfs_files_labels = [
    # TODO(120776) The boot animation is configured via a global GN arg, which
    # needs to be migrated to a path provided by the product to assembly, which
    # then places it in the appropriate path in bootfs.
    #
    # As such, this isn't something that should be added to a platform bundle,
    # but the migration with the products that use that GN arg is sufficiently
    # complicated that this is clearer that trying to do a removal of the
    # default boot animation in those products that shouldn't include it (if
    # it's included by default via `//products/common/bringup.gni`).
    "//src/bringup/bin/virtcon:boot_animation",
  ]

  bootfs_packages = [ "//src/bringup/bin/virtcon:package" ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path(
                  [ "//src/bringup/bin/virtcon/meta/virtual-console.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("virtcon_disable") {
  kernel_cmdline = [
    "virtcon.hide-on-boot",
    "virtcon.disable=true",
  ]
}

# The netsvc AIB is included by all eng products.
#
assembly_input_bundle("netsvc") {
  bootfs_packages = [ "//src/bringup/bin/netsvc:package" ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards =
              rebase_path([ "//src/bringup/bin/netsvc/meta/netsvc.shard.cml" ],
                          root_build_dir)
        },
      ]
    },
  ]
}

# All eng build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
#
assembly_input_bundle("kernel_args_eng") {
  kernel_cmdline = [
    "console.shell=true",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "netsvc.all-features=true",
    "netsvc.disable=false",
  ]
}

# All userdebug build type products will include this Assembly Input Bundle.
# These kernel args should be refactored so that the AIBs have logical names.
#
assembly_input_bundle("kernel_args_userdebug") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=output-only",
    "netsvc.disable=true",
  ]
}

# All user build type products will include this Assembly Input Bundle.
#
# These are all the default values, so this AIB can be safely removed, but we
# are keeping it around for now so that we can assert that nothing changed
# during refactor.
#
# These kernel args should be refactored so that the AIBs have logical names.
assembly_input_bundle("kernel_args_user") {
  kernel_cmdline = [
    "console.shell=false",
    "kernel.enable-debugging-syscalls=false",
    "kernel.enable-serial-syscalls=false",
    "netsvc.disable=true",
    "kernel.serial=none",
  ]
}

# Added when a board supports the PMM checker (ie, it's real hardware that can
# do this without a large performance penalty), and when desired by the product
# (based on build-type).
assembly_input_bundle("kernel_pmm_checker_enabled") {
  kernel_cmdline = [
    # Enable PMM checker to detect certain kinds of buffer overrun and
    # use-after-free bugs.
    "kernel.pmm-checker.enable=true",

    # Use a small fill size to minimize performance impact.  In practice,
    # corruption tends to happen at the start of a page so filling/checking only
    # the first 16 bytes provides decent coverage without sacrificing
    # performance.
    "kernel.pmm-checker.fill-size=16",
  ]
}

# sl4f: Scripting Layer for Fuchsia
#
# Often used for manipulating device during E2E tests.
assembly_input_bundle("sl4f") {
  base_packages = [
    # We currently include SL4F in base to support E2E tests that
    # either do not download fuchsia packages or cannot start
    # package serving due to network limitations.
    "//src/testing/sl4f",
    "//src/sys/bin/start_sl4f",
  ]
  shell_commands = [
    {
      package = "start_sl4f"
      components = [ "start_sl4f" ]
    },
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/testing/sl4f/meta/sl4f_assembly.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Includes the bin/clock and clkctl developer tools
assembly_input_bundle("clock_development_tools") {
  bootfs_files_labels = [ "//src/devices/clock/bin/clock:bootfs" ]
}

########
#
# The /core realm AIBs
#
# These are the Assembly Input Bundles that are included by all assembled
# systems that include the `/core` realm.

# core_realm
#
# This AIB adds the `/core` realm itself, and it's mandatory children.  The
# other AIBs in this group add shards and optional children of `/core`.
#
# This is "less than minimal".  "utility" systems include this to get a `/core`
# realm, but do not include the `common_standard` AIB as that brings in too much
# functionality for these specialized systems.
#
# All children in `/core` receive InspectSink and LogSink.
#
assembly_input_bundle("core_realm") {
  bootfs_packages = [ "//src/sys/pkg/bin/pkg-cache" ]
  base_packages = [
    # This is a required dependency of pkg-cache
    "//src/sys/pkg/bin/system-update-committer",

    # Build-Information
    "//src/developer/build_info:build-info-service",

    # Driver system memory connector
    "//src/devices/sysmem/bin/sysmem_connector:pkg",

    # Developer.
    "//src/developer/forensics:pkg",
  ]

  compiled_packages = [
    {
      name = "core"
      components = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.

          component_name = "core"
          shards = rebase_path("//src/sys/core/meta/core.cml", root_build_dir)
        },
      ]

      # These are not included into the core.cml directly, but may be included
      # via other shards.
      component_includes = [
        {
          source =
              rebase_path("//sdk/lib/inspect/offer.shard.cml", root_build_dir)
          destination = "inspect/offer.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/syslog/offer.shard.cml", root_build_dir)
          destination = "syslog/offer.shard.cml"
        },
      ]
      foreach(
          include,
          [
            "//src/connectivity/bluetooth/profiles/bt-a2dp/meta/bt-a2dp-common.core_shard.cml",
            "//src/intl/intl_services/meta/intl.core_shard.base.cml",
            "//src/media/audio/audio_core/meta/audio_core.core_shard.base.cml",
            "//src/recovery/system/meta/core_shards/base.shard.cml",
            "//src/recovery/system/meta/core_shards/ui.shard.cml",
            "//src/session/bin/session_manager/meta/all_products_capabilities.core_shard.cml",
            "//src/session/bin/session_manager/meta/session.smart.from_platform.core_shard.cml",
            "//src/session/bin/session_manager/meta/some_products_capabilities.core_shard.cml",
            "//src/session/bin/session_manager/meta/terminal_capabilities.core_shard.cml",
            "//src/settings/service/meta/setui_service_base.core_shard.cml",
            "//src/testing/sl4f/meta/sl4f_base.core_shard.cml",
            "//src/ui/meta/ui_routes_base.shard.cml",
          ]) {
        component_includes += [
          {
            source = rebase_path(include, root_build_dir)
            destination = rebase_path(include, "//")
          },
        ]
      }
    },
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    # TODO:  These shards should be folded into the above
                    # `core.cml` file itself as they are never omitted from it.
                    "//src/developer/build_info/meta/build_info.core_shard.cml",
                    "//src/developer/forensics/forensics.core_shard.cml",
                    "//sdk/lib/inspect/offer.shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "system-update-realm"
      components = [
        {
          component_name = "system-update-realm"

          shards = rebase_path("//src/sys/pkg/meta/system-update-realm.cml",
                               root_build_dir)
        },
      ]
    },
  ]
}

# core_realm_networking
#
# This AIB adds all the children of `/core` that are expected to be present if
# networking is enabled.
#
# It does _not_ include either the `network` or `netstack` packages themselves,
# as which specific variant of those is added is controllable by the product, so
# they are in separate AIBs.
#
# "Utility" systems get this in the 'user' build-type only if they request that
# networking is added.  All other build-types (and all "standard" systems) get
# this AIB by mandatory inclusion.
assembly_input_bundle("core_realm_networking") {
  base_packages = [
    # Hardware Information
    "//src/hwinfo",

    # System Time
    "//src/sys/time/timekeeper:timekeeper-without-config",
    "//src/sys/time/httpsdate_time_source:httpsdate-time-source-pull",

    # Other
    "//src/sys/stash:pkg",
  ]
}

# Network realm definition.
#
# This AIB defines the base network package, which lays out the network realm.
# It must be used in conjunction with network_realm_packages or
# network_realm_packages_gub.
assembly_input_bundle("network_realm") {
  compiled_packages = [
    {
      name = "network"
      components = [
        {
          component_name = "network"
          shards =
              rebase_path("//src/connectivity/network/meta/common.shard.cml",
                          root_build_dir)
        },
      ]
      component_includes = [
        {
          source =
              rebase_path("//sdk/lib/inspect/offer.shard.cml", root_build_dir)
          destination = "inspect/offer.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/trace/offer.shard.cml", root_build_dir)
          destination = "trace/offer.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/syslog/offer.shard.cml", root_build_dir)
          destination = "syslog/offer.shard.cml"
        },
      ]
    },
  ]
}

# Network realm packages without unified binary.
#
# This AIB includes all the packages that are common across all products that
# require networking. It provides the network realm using packages that utilize
# separate, more-optimized, binaries, trading space for performance. This is
# the default implementation used.
#
# It is mutually-exclusive with 'network_realm_packages_gub'.
assembly_input_bundle("network_realm_packages") {
  base_packages = [
    "//src/connectivity/network/dhcpv4/server:package",
    "//src/connectivity/network/dhcpv6/client:package",
    "//src/connectivity/network/dns:package",
    "//src/connectivity/policy/http-client:package",
    "//src/connectivity/policy/reachability:package",
  ]
}

# Network realm packages with unified binary.
#
# This AIB is equivalent to network_realm_packages. It provides the network
# realm using packages that utilize a "grand unified binary" (GUB), saving space
# at the cost of a minor loss in performance.  This is for space- constrained
# devices that don't have the space for the non-GUB binaries.
#
# It is mutually-exclusive with 'network_realm_packages'.
assembly_input_bundle("network_realm_packages_gub") {
  base_packages = [
    "//src/connectivity/network/dhcpv4/server:package_gub",
    "//src/connectivity/network/dhcpv6/client:package_gub",
    "//src/connectivity/network/dns:package_gub",
    "//src/connectivity/policy/http-client:package_gub",
    "//src/connectivity/policy/reachability:package_gub",
  ]
}

# networking_with_virtualization
#
# This AIB adds the networking capabilities that include virtualization support.
# It is mutually-exclusive with networking_basic.
#
assembly_input_bundle("networking_with_virtualization") {
  base_packages = [ "//src/connectivity/policy/netcfg:package-advanced" ]
  compiled_packages = [
    {
      name = "network"
      component_shards = [
        {
          component_name = "network"
          shards = rebase_path(
                  [ "//src/connectivity/network/meta/network-with-virtualization.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Basic networking.
#
# This AIB adds the basic networking capabilities. It is mutually-exclusive with
# networking_with_virtualization.
#
# It must be used in conjunction with either network_basic_packages or
# network_basic_packages_gub.
assembly_input_bundle("networking_basic") {
  compiled_packages = [
    {
      name = "network"
      component_shards = [
        {
          component_name = "network"
          shards = rebase_path(
                  [ "//src/connectivity/network/meta/network-basic.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Basic networking packages without unified binary.
#
# This AIB provides packages for the networking_basic configuration. It is
# mutually exlucisve with networking_basic_packages_gub.
assembly_input_bundle("networking_basic_packages") {
  base_packages = [ "//src/connectivity/policy/netcfg:package-basic" ]
}

# Basic networking packages with unified binary.
#
# This AIB provides space-saving equivalent packages for the networking_basic
# configuration as found in networking_basic_packages. It is mutually exlucisve
# with networking_basic_packages.
assembly_input_bundle("networking_basic_packages_gub") {
  base_packages = [ "//src/connectivity/policy/netcfg:package-basic_gub" ]
}

# networking_test_collection
#
# Includes a test collection inside the network realm that has access to all
# networking administrative capabilities.
assembly_input_bundle("networking_test_collection") {
  testonly = true
  compiled_packages = [
    {
      name = "network"
      component_shards = [
        {
          component_name = "network"
          shards = rebase_path(
                  [ "//src/connectivity/network/meta/test-collection.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is common across all eng-mode products that include the core realm.
#
# This is mutually-exclusive with the `core_realm_user_and_userdebug` AIB.
#
assembly_input_bundle("core_realm_eng") {
  testonly = true
  base_packages = [
    "//src/sys/pkg/bin/pkg-resolver:pkg-resolver-eng",

    # Dash launcher should be available in every engineering-mode product.
    "//src/sys/tools/debug-dash-launcher",

    # The fs_realm component should be available in every engineering-mode product.
    "//src/storage/fs_realm",
    "//src/storage/bin:fs_realm_tools",
  ]
  shell_commands = [
    {
      package = "fs_realm_tools"
      components = [
        "mkfs",
        "fsck",
        "mount",
        "umount",
      ]
    },
  ]

  # Included with //bundles/tools.
  shell_commands += [
    {
      package = "sched"
      components = [ "sched" ]
    },
    {
      package = "cowsay"
      components = [ "cowsay" ]
    },
    {
      package = "hwstress-cli"
      components = [ "hwstress" ]
    },
    {
      package = "time"
      components = [ "time" ]
    },
    {
      package = "uname"
      components = [ "uname" ]
    },
    {
      package = "far"
      components = [ "far" ]
    },
    {
      package = "trace"
      components = [ "trace" ]
    },
    {
      package = "camera_benchmark"
      components = [ "camera_benchmark_bin" ]
    },
    {
      package = "camera_sensor_cli"
      components = [ "camera_sensor_cli_bin" ]
    },
    {
      package = "lowpanctl"
      components = [ "lowpanctl" ]
    },
    {
      package = "nc"
      components = [ "nc" ]
    },
    {
      package = "sockscripter"
      components = [ "sockscripter" ]
    },
    {
      package = "iperf3"
      components = [ "iperf3" ]
    },
    {
      package = "tcpdump"
      components = [ "tcpdump" ]
    },
    {
      package = "mdns-util"
      components = [ "mdns-util" ]
    },
    {
      package = "net-cli"
      components = [ "net" ]
    },
    {
      package = "donut"
      components = [ "donut" ]
    },
    {
      package = "dai-info"
      components = [ "dai-info" ]
    },
    {
      package = "bt-bredr-profile"
      components = [ "bt-bredr-profile" ]
    },
    {
      package = "bt-cli"
      components = [ "bt-cli" ]
    },
    {
      package = "bt-le-central"
      components = [ "bt-le-central" ]
    },
    {
      package = "bt-le-peripheral"
      components = [ "bt-le-peripheral" ]
    },
    {
      package = "bt-pairing-tool"
      components = [ "bt-pairing-tool" ]
    },
    {
      package = "bt-snoop-cli"
      components = [ "bt-snoop-cli" ]
    },
    {
      package = "bt-fct-hci"
      components = [ "bt-fct-hci" ]
    },
    {
      package = "bt-hci-tool"
      components = [ "bt-hci-tool" ]
    },
    {
      package = "bt-intel-tool"
      components = [ "bt-intel-tool" ]
    },
    {
      package = "bt-avdtp-tool"
      components = [ "bt-avdtp-tool" ]
    },
    {
      package = "bt-avrcp-controller"
      components = [ "bt-avrcp-controller" ]
    },
    {
      package = "display-detect"
      components = [ "display_detect" ]
    },
    {
      package = "display-png"
      components = [ "display_png" ]
    },
    {
      package = "display-tool"
      components = [ "display-tool" ]
    },
    {
      package = "display-tweak"
      components = [ "display-tweak" ]
    },
    {
      package = "magma-info"
      components = [ "magma-info" ]
    },
    {
      package = "mediasession_cli_tool"
      components = [ "mediasession_cli_tool" ]
    },
    {
      package = "fdr_cli"
      components = [ "fdr" ]
    },
    {
      package = "export-ffs"
      components = [ "export-ffs" ]
    },
    {
      package = "pm"
      components = [ "pm" ]
    },
    {
      package = "activity-ctl"
      components = [ "activity_ctl" ]
    },
    {
      package = "log"
      components = [ "log" ]
    },
    {
      package = "input"
      components = [ "input" ]
    },
    {
      package = "boringssl_tool"
      components = [ "bssl" ]
    },
    {
      package = "curl"
      components = [ "curl" ]
    },
    {
      package = "scp"
      components = [ "scp" ]
    },
    {
      package = "ssh-keygen"
      components = [ "ssh-keygen" ]
    },
    {
      package = "ssh"
      components = [ "ssh" ]
    },
  ]

  # Document the sbase shell commands in the on-demand package set (these are
  # not added to the product image).
  on_demand = []
  foreach(bin, sbase_binaries) {
    # To be enabled soon, but will cause errors in assembly.
    # on_demand += [ "//third_party/sbase:${bin}_pkg" ]
    shell_commands += [
      {
        package = bin
        components = [ bin ]
      },
    ]
  }

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    # The process_resolver core shard (either the base-resolver or
                    # pkg-resolver variant) should only be present in
                    # the `core_realm_development_access` AIB, but it's required
                    # here until optional exposes are available, as the
                    # `fuchsia.process.Resolver` capability is routed to the
                    # `/bootstrap/console-launcher` component which is currently
                    # present on all build-types (but is not needed on user, as
                    # there is no reachable console there).
                    # Note that the `process-resolver` component itself is not
                    # present except when the `core_realm_development_access` is
                    # added to the system.
                    #
                    # eng uses the pkg-resolver, as opposed to the base-resolver,
                    # to support ephemeral resolution of shell packages.
                    "//src/sys/process-resolver/meta/process_resolver.pkg-resolver.core_shard.cml",

                    "//src/sys/core/meta/core-env-full-resolver.core_shard.cml",
                    "//src/sys/core/meta/lavapipe.core_shard.cml",
                    "//src/sys/core/meta/unrestricted-storage.core_shard.cml",
                    "//src/sys/tools/debug-dash-launcher/meta/debug_dash_launcher.core_shard.cml",
                    "//src/storage/fs_realm/meta/fs_realm.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is common across all user and userdebug products that include the core
# realm.
#
# This is mutually-exclusive with the `core_realm_eng` AIB.
#
assembly_input_bundle("core_realm_user_and_userdebug") {
  base_packages = [ "//src/sys/pkg/bin/pkg-resolver" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    # user and userdebug only have the base resolver, not the full
                    # resolver.
                    "//src/sys/core/meta/core-env-base-resolver.core_shard.cml",

                    # The process_resolver core shard (either the base-resolver or
                    # pkg-resolver variant) should only be present in
                    # the `core_realm_development_access` AIB, but it's required
                    # here until optional exposes are available, as the
                    # `fuchsia.process.Resolver` capability is routed to the
                    # `/bootstrap/console-launcher` component which is currently
                    # present on all build-types (but is not needed on user, as
                    # there is no reachable console there).
                    # Note that the `process-resolver` component itself is not
                    # present except when the `core_realm_development_access` is
                    # added to the system.
                    #
                    # user and userdebug only have the base-resolver, not the
                    # pkg-resolver.
                    "//src/sys/process-resolver/meta/process_resolver.base-resolver.core_shard.cml",

                    # Lavapipe is only enabled on eng builds.
                    "//src/sys/core/meta/lavapipe-disabled.core_shard.cml",

                    # user and userdebug restrict access to the Storage capability
                    # to registered component ids.
                    "//src/sys/core/meta/restricted-storage.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is the AIB that adds the services necessary for developers to access a
# target running Fuchsia from their development host using tools like `ffx`.
#
# This is included with all eng and userdebug build-type systems.
#
assembly_input_bundle("core_realm_development_access") {
  base_packages = [
    # SSH is necessary for remote access for development
    "//src/developer/sshd-host",

    # Process resolver enables cli commands to be resolved to components.
    "//src/sys/process-resolver",

    # ffx's remote-control (remote access) components:
    "//src/developer/remote-control:remote-control-package",

    # The developer snapshot tool.
    "//src/developer/forensics/snapshot:pkg",

    # log_listener shell tool.
    "//src/diagnostics/log_listener:log_listener_shell_pkg",
  ]
  config_data_labels = [ "//src/developer/sshd-host:config" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/developer/debug/debug_agent/meta/debug_agent.core_shard.cml",
                    "//src/developer/meta/default-laboratory-env.core_shard.cml",
                    "//src/developer/remote-control/meta/laboratory.core_shard.cml",
                    "//src/developer/remote-control/meta/remote-control-base.core_shard.cml",
                    "//src/developer/sshd-host/meta/sshd-host.core_shard.cml",
                    "//src/developer/toolbox/meta/toolbox.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "toolbox"
      components = [
        {
          component_name = "toolbox"
          shards = rebase_path("//src/developer/toolbox/meta/toolbox.cml",
                               root_build_dir)
        },
      ]
    },
  ]
  shell_commands = [
    {
      package = "remote-control"
      components = [
        "remote_control_runner",
        "remote_control_bin",
      ]
    },
    {
      package = "snapshot"
      components = [ "snapshot" ]
    },
    {
      package = "log_listener_shell"
      components = [ "log_listener" ]
    },
  ]
}

assembly_input_bundle("mdns_fuchsia_device_wired_service") {
  config_data_labels =
      [ "//src/connectivity/network/mdns/service:mdns_fuchsia_udp_config" ]
}

assembly_input_bundle("core_realm_development_access_rcs_usb") {
  base_driver_packages = [
    {
      package_target = "//src/connectivity/overnet/usb:overnet-usb-package"
      driver_components = [ "meta/overnet-usb.cm" ]
    },
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/developer/remote-control/meta/remote-control-with-usb.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("core_realm_development_access_rcs_no_usb") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/developer/remote-control/meta/remote-control.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("radar_proxy_with_injector") {
  base_packages =
      [ "//src/devices/radar/bin/radar-proxy:radar-proxy-with-injector" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/devices/radar/bin/radar-proxy/meta/radar-proxy-with-injector.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("radar_proxy_without_injector") {
  base_packages =
      [ "//src/devices/radar/bin/radar-proxy:radar-proxy-without-injector" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/devices/radar/bin/radar-proxy/meta/radar-proxy-without-injector.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("feedback_low_memory_product_config") {
  config_data_labels =
      [ "//src/developer/forensics:feedback_low_memory_product_config" ]
}

assembly_input_bundle("feedback_remote_device_id_provider") {
  config_data_labels = [
    "//src/developer/forensics:feedback_remote_device_id_provider_for_assembly",
  ]
}

assembly_input_bundle("feedback_large_disk") {
  config_data_labels =
      [ "//src/developer/forensics:feedback_large_disk_product_config" ]
}

assembly_input_bundle("feedback_userdebug_config") {
  config_data_labels = [ "//src/developer/forensics:feedback_userdebug_config" ]
}

assembly_input_bundle("feedback_user_config") {
  config_data_labels = [ "//src/developer/forensics:feedback_user_config" ]
}

assembly_input_bundle("factory_reset_trigger") {
  base_packages = [ "//src/recovery/factory-reset-trigger" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/recovery/factory-reset-trigger/meta/factory-reset-trigger.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# The "standard" AIBs
#
# These historically corresponded to the use of "minimal.gni" as a basis for
# other products.
#
# All components here receive InspectSink and LogSink.
#
# TODO(https://fxbug.dev/42065169) Move the contents of common_standard to the right
# feature- or subsystem-specific AIBs (if not to the core realm AIBs).
#
# WARNING:  The only way to remove items from this AIB for a given product is to
# move them to other AIBs that are included by all other products.
#
assembly_input_bundle("common_standard") {
  bootfs_files_labels = [ "//src/sys/core:bootfs" ]

  base_packages = [
    # The SWD stack artifacts that enable OTAs
    "//src/sys/pkg/bin/system-updater",
    "//src/sys/full-resolver:full-resolver-pkg",

    # Cobalt
    "//src/cobalt/bin/app:cobalt",
    "//src/cobalt/bin/system-metrics:cobalt_system_metrics",

    # Diagnostics
    "//src/diagnostics/persistence:diagnostics-persistence",
    "//src/diagnostics/kcounter:diagnostics-kcounter",
    "//src/diagnostics/sampler",

    # Internationalization
    "//src/intl/tzdata_provider:tzdata_provider_pkg",

    # Security
    "//src/security/bin/root_ssl_certificates",

    # Activity
    "//src/sys/activity",

    # Recovery
    "//src/recovery/factory_reset:factory_reset_pkg",

    # Connectivity
    "//src/connectivity/network/mdns/service:mdns",
  ]

  config_data = [
    {
      package_name = "system-update-committer"
      files = [
        {
          # This file is generated by GN, but its contents are always the same
          # (the template which generates it is basically a macro, and has no
          # product-controlled GN arguments or metadata).
          source = "$root_build_dir/gen/src/sys/pkg/bin/system-update-committer/system_update_committer_config_enable_reboot_on_verification_failure.json"
          destination = "config.json"
          label = "//src/sys/pkg/bin/system-update-committer:enable_reboot_on_verification_failure"
        },
      ]
    },
    {
      # Ideally we would reference a config_data_for_assembly() target instead,
      # but they don't support deps yet, which is needed here.
      package_name = "cobalt"
      label = "//src/cobalt/bin/app:global_metrics_registry_gen"
      files = [
        {
          # This file is generated by GN, but its contents are always the same
          # (the template which generates it is basically a macro, and has no
          # product-controlled GN arguments or metadata).
          source = "$root_gen_dir/src/cobalt/bin/app/global_metrics_registry.pb"
          destination = "global_metrics_registry.pb"
        },
      ]
    },
    {
      package_name = "triage-detect"
      files = [
        {
          source =
              "//src/diagnostics/config/triage/detect/session-detect.triage"
          destination = "session-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/sysmem-detect.triage"
          destination = "sysmem-detect.triage"
        },
        {
          source = "//src/diagnostics/config/triage/detect/wlan-detect.triage"
          destination = "wlan-detect.triage"
        },
      ]
    },
    {
      package_name = "diagnostics-persistence"
      files = [
        {
          source = "//src/diagnostics/config/persistence/netstack.persist"
          destination = "netstack.persist"
        },
        {
          source = "//src/diagnostics/config/persistence/wlan.persist"
          destination = "wlan.persist"
        },
      ]
    },
  ]

  config_data_labels = [
    "//src/diagnostics/config/sampler:sampler_config_internal",
    "//src/diagnostics/config/fire:fire_config_component_list",
    "//src/diagnostics/config/fire/projects:fire_config_projects",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/diagnostics/kcounter/meta/diagnostics-kcounter.core_shard.cml",
                    "//src/diagnostics/realm/meta/diagnostics.core_shard.cml",
                    "//src/diagnostics/persistence/meta/diagnostics-persistence.core_shard.cml",
                    "//src/diagnostics/sampler/meta/sampler.core_shard.cml",
                    "//src/connectivity/network/meta/persistence.core_shard.cml",
                    "//src/intl/tzdata_provider/meta/tzdata_provider.core_shard.cml",
                    "//src/sys/cache_manager/meta/cache_manager.core_shard.cml",
                    "//src/sys/pkg/bin/system-updater/meta/system_updater.core_shard.cml",
                    "//src/recovery/factory_reset/meta/factory_reset.core_shard.cml",

                    # TODO(https://fxbug.dev/42160712): only include in eng builds
                    "//src/sys/test_manager/meta/test_manager.core_shard.cml",
                    "//src/sys/testing/meta/test_realm.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "diagnostics"
      components = [
        {
          component_name = "diagnostics"
          shards =
              rebase_path("//src/diagnostics/realm/meta/diagnostics_realm.cml",
                          root_build_dir)
        },
      ]
      component_includes = [
        {
          source =
              rebase_path("//sdk/lib/inspect/offer.shard.cml", root_build_dir)
          destination = "inspect/offer.shard.cml"
        },
      ]
    },
    {
      name = "diagnostics"
      component_shards = [
        {
          component_name = "diagnostics"
          shards = rebase_path(
                  [
                    "//src/diagnostics/kcounter/meta/diagnostics-kcounter.realm_shard.cml",
                    "//sdk/lib/inspect/offer.shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "system-update-realm"
      component_shards = [
        {
          component_name = "system-update-realm"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/system-updater/meta/system_updater.system_update_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is exclusive to user builds on the minimal support level.
#
assembly_input_bundle("standard_user") {
  base_packages = [
    # memory_monitor with profiling disabled.
    "//src/developer/memory/monitor:monitor_without_memory_sampler",
  ]

  config_data = [
    {
      package_name = "cobalt"
      files = [
        {
          source = "//src/cobalt/bin/app/configs/user_config.json"
          destination = "config.json"
        },
      ]
    },
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/developer/memory/monitor/meta/memory_monitor.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# This is exclusive to userdebug builds on the minimal support level.
#
assembly_input_bundle("standard_userdebug") {
  config_data = [
    {
      package_name = "cobalt"
      files = [
        {
          source = "//src/cobalt/bin/app/configs/userdebug_config.json"
          destination = "config.json"
        },
      ]
    },
    {
      package_name = "triage-detect"
      files = [
        {
          source = "//src/diagnostics/detect/configs/enable-filing.json"
          destination = "config.json"
        },
        {
          source = "//src/diagnostics/detect/configs/netstack-detect.triage"
          destination = "netstack-detect.triage"
        },
        {
          source = "//src/diagnostics/detect/configs/cobalt-detect.triage"
          destination = "cobalt-detect.triage"
        },
      ]
    },
    {
      package_name = "memory_monitor"
      files = [
        {
          source = "//src/developer/memory/monitor/config/send_critical_pressure_crash_reports"
          destination = "send_critical_pressure_crash_reports"
        },
      ]
    },
  ]
}

# This is common across all eng-mode products, at the minimal or higher service
# level.
#
assembly_input_bundle("standard_eng") {
  testonly = true
  base_packages = []
  cache_packages = [
    # Backend for ffx process command.
    "//src/developer/process_explorer:process_explorer_package",
    "//src/devices/bin/driver_playground:pkg",
    "//src/power/metrics-logger:metrics-logger-pkg",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/developer/process_explorer/meta/process_explorer.core_shard.cml",
                    "//src/devices/bin/driver_playground/meta/driver_playground.core_shard.cml",
                    "//src/performance/trace_manager/meta/trace_manager.core_shard.cml",
                    "//src/power/metrics-logger/meta/metrics-logger.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
  config_data = [
    {
      package_name = "cobalt"
      files = [
        {
          source = "//src/cobalt/bin/app/configs/default_config.json"
          destination = "config.json"
        },
      ]
    },
  ]
}

# This is common across all eng-mode and user-debug products, at the minimal or
# higher service level.
#
assembly_input_bundle("standard_userdebug_and_eng") {
  base_packages = [
    "//src/diagnostics/detect:triage-detect",
    "//src/sys/pkg/bin/pkgctl",
    "//src/sys/pkg/bin/update",

    # memory_monitor with profiling enabled.
    "//src/developer/memory/monitor:monitor_with_memory_sampler",
    "//src/performance/memory/sampler:memory_sampler",
  ]
  shell_commands = [
    {
      package = "pkgctl"
      components = [ "pkgctl" ]
    },
    {
      package = "update-bin"
      components = [ "update" ]
    },
  ]
  compiled_packages = [
    {
      name = "diagnostics"
      component_shards = [
        {
          component_name = "diagnostics"
          shards = rebase_path(
                  [ "//src/diagnostics/detect/meta/detect.realm_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/diagnostics/detect/meta/detect.core_shard.cml",
                    "//src/developer/memory/monitor/meta/memory_monitor.core_shard.cml",
                    "//src/developer/memory/monitor/meta/memory_monitor_with_memory_sampler.core_shard.cml",
                    "//src/performance/memory/sampler/meta/memory_sampler.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# Feature- and Subsystem-specific AIBs
#
# These are optionally present in all products that include the `/core` realm
# (via the `:core_realm` AIB).  Each should list which feature_set_level and
# build type that it is valid for.

# Input groups
#
# feature_set_levels: minimal
# build-types:all
#
# These AIBs are opaque groups of inputs that are common to many products, but
# have not been organized into specific features yet.
assembly_input_bundle("input_group_one") {
  kernel_cmdline = [ "kernel.oom.behavior=reboot" ]
  base_packages = [ "//src/sys/cache_manager" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    # TODO(https://fxbug.dev/42160712): only include in eng builds
                    "//src/sys/fuzzing/meta/fuzzing.core-shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("input_group_two") {
  kernel_cmdline = [ "kernel.render-dlog-to-crashlog=true" ]
  base_packages = [ "//src/session/bin/session_manager" ]
  flexible_packages = [
    "//src/connectivity/location/emergency",
    "//src/media/sessions:mediasession",
  ]
  if (current_cpu != "riscv64") {
    flexible_packages += [ "//src/media/codec:codec_factory" ]
  }
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/connectivity/location/emergency/meta/emergency.core_shard.cml",
                    "//src/media/codec/factory/meta/codec_factory.core_shard.cml",
                    "//src/media/sessions/meta/mediasession.core_shard.cml",
                    "//src/session/bin/session_manager/meta/session.smart.from_platform.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# Bluetooth Support

# Bluetooth profile support: A2DP
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("bluetooth_a2dp") {
  flexible_packages = [ "//src/connectivity/bluetooth/profiles/bt-a2dp" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/bluetooth/profiles/bt-a2dp/meta/bt-a2dp-eager.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Bluetooth profile support: AVRCP
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("bluetooth_avrcp") {
  flexible_packages = [
    "//src/connectivity/bluetooth/profiles/bt-avrcp",
    "//src/connectivity/bluetooth/profiles/bt-avrcp-target",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/bluetooth/profiles/bt-avrcp/meta/bt-avrcp.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Bluetooth core support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("bluetooth_core") {
  base_packages = [
    "//src/connectivity/bluetooth/core/bt-gap",
    "//src/connectivity/bluetooth/core/bt-host",
    "//src/connectivity/bluetooth/core/bt-init",
    "//src/connectivity/bluetooth/profiles/bt-rfcomm",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/bluetooth/core/bt-init/meta/bt-init.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Bluetooth profile support: HFP - AG
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("bluetooth_hfp_ag") {
  flexible_packages = [ "//src/connectivity/bluetooth/profiles/bt-hfp-audio-gateway:bt-hfp-audio-gateway-default" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/bluetooth/profiles/bt-hfp-audio-gateway/meta/bt-hfp-audio-gateway.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Bluetooth snoop support
#
# feature_set_levels: minimal
# build-types: all
# This AIB provides packages for the Bluetooth snoop configuration which lazily starts. It is
# mutually exclusive with the `bluetooth_snoop_eager` AIB.
#
assembly_input_bundle("bluetooth_snoop_lazy") {
  base_packages = [ "//src/connectivity/bluetooth/tools/bt-snoop" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/bluetooth/tools/bt-snoop/meta/bt-snoop.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Bluetooth snoop support
#
# feature_set_levels: minimal
# build-types: all
# This AIB provides packages for the Bluetooth snoop configuration which eagerly starts at device
# boot. It is mutually exclusive with the `bluetooth_snoop_lazy` AIB.
#
assembly_input_bundle("bluetooth_snoop_eager") {
  base_packages = [ "//src/connectivity/bluetooth/tools/bt-snoop" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/bluetooth/tools/bt-snoop/meta/bt-snoop-eager.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Support for Pandora Bluetooth test interface server and virtual HCI with Rootcanal.
#
# feature_set_levels: standard
# build-types: eng
#
assembly_input_bundle("bluetooth_pandora") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/connectivity/bluetooth/testing/pandora/bt-pandora-server/meta/bt-pandora-server.core_shard.cml",
                    "//src/connectivity/bluetooth/tools/bt-rootcanal/meta/bt-rootcanal.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

#
# Diagnostics Triage Support

# Triage-detect support for magma arm mali devices
assembly_input_bundle("diagnostics_triage_detect_mali") {
  config_data_labels = [ "//src/diagnostics/config/triage:mali-detect" ]
}

# Driver Framework Support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("driver_framework") {
  bootfs_packages = [
    "//src/devices/bin/devfs:package",
    "//src/devices/bin/driver_host:package",
    "//src/devices/bin/driver_manager:package",
    "//src/devices/bin/driver-index:package",
  ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path(
                  [ "//src/devices/bin/driver_framework/meta/driver_framework.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Full Package Driver Support
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("full_package_drivers") {
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path(
                  [ "//src/devices/bin/driver_framework/meta/full_package_drivers.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Core starnix support.
#
# optional: product must specify its inclusion
# valid feature_set_levels: minimal
# valid build-types: all
#
assembly_input_bundle("starnix_support") {
  flexible_packages = [
    "//src/starnix/runner:starnix_package",
    "//src/starnix/kernel:starnix_kernel_package",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/starnix/runner/meta/starnix_runner.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/starnix/config:bootfs" ]
}

# Core adb support. Does not include daemon. Daemon should be included separately.
#
# optional: product must specify its inclusion
# valid feature_set_levels: minimal
# valid build-types: all
#
assembly_input_bundle("adb_support") {
  kernel_cmdline = [ "driver.usb.peripheral=cdc_adb" ]
  base_driver_packages = [
    {
      package_target = "//src/developer/adb/drivers/usb-adb-function:package"
      driver_components = [ "meta/usb-adb-function.cm" ]
    },
  ]
}

# This AIB enables testing support, and is meant to be used with either the
# `common_standard_eng` and `common_standard_userdebug` AIBs.
#
# This includes testing support in the platform `base` package set, not just
# via `universe`
assembly_input_bundle("testing_support") {
  testonly = true
  base_packages = [ "//src/performance/trace_manager" ]
  bootfs_files_labels = [ "//src/tests/microbenchmarks/config:bootfs" ]
  cache_packages = [
    # test-manager and all of its runners:
    "//src/sys/test_manager:pkg",
    "//src/sys/test_runners/elf:elf-test-runner",
    "//src/sys/test_runners/elf:elf-test-ambient-exec-runner",
    "//src/sys/test_runners/elf:elf-test-create-raw-processes-runner",
    "//src/sys/test_runners/elf:elf-test-create-raw-processes-ambient-exec-runner",
    "//src/sys/test_runners/fuzz:fuzz-test-runner",
    "//src/sys/test_runners/gotests:go-test-runner",
    "//src/sys/test_runners/gtest:gtest-runner",
    "//src/sys/test_runners/gunit:gunit-runner",
    "//src/sys/test_runners/inspect:inspect-test-runner",
    "//src/sys/test_runners/lib_loader_cache:lib_loader_runner_cache",
    "//src/sys/test_runners/rust:rust-test-create-raw-processes-runner",
    "//src/sys/test_runners/rust:rust-test-next-vdso-runner",
    "//src/sys/test_runners/rust:rust-test-runner",
    "//src/sys/test_runners/starnix:starnix-test-runners",
    "//src/sys/test_runners/stress_test:stress-test-runner",
    "//src/connectivity/network/testing/netemul/runner:package",

    # required dependencies of test-manager
    "//src/sys/testing:testing",  # The test_realm component's package
    "//src/lib/fuchsia-component-test/realm_builder_server:pkg",
    "//src/sys/fuzzing:fuzz-manager",
    "//src/sys/fuzzing:fuzz-registry",
    "//src/sys/fuzzing/fuzzctl",
    "//src/sys/run_test_suite",

    # CPU profiler
    "//src/performance/experimental/profiler",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/performance/experimental/profiler/meta/profiler.core_shard.cml",
                    # These should only be added by this AIB, because their
                    # packages are only added by this AIB, however due to many
                    # routing issues, they are included in a wider set of
                    # assemblies than just those that include "testing_support"
                    #
                    # "//src/sys/test_manager/meta/test_manager.core_shard.cml",
                    # "//src/sys/fuzzing/meta/fuzzing.core-shard.cml",
                    # "//src/sys/testing/meta/test_realm.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
  shell_commands = [
    {
      package = "run_test_suite"
      components = [ "run-test-suite" ]
    },
    {
      package = "fuzzctl"
      components = [ "fuzz_ctl" ]
    },
  ]
}

# Basic camera support
#
assembly_input_bundle("camera") {
  flexible_packages = [
    "//src/camera/bin/device:camera_device",
    "//src/camera/bin/device_watcher:camera_device_watcher",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path([ "//src/camera/meta/camera.core_shard.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("factory_data") {
  flexible_packages = [ "//src/factory/factory_store_providers" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/factory/factory_store_providers/meta/factory_store_providers.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# AIB containing bootfs resources needed by all fshost variants
#
# There are "pervasively routed" capability shards included here because there
# is currently no better mechanism for providing them to the fshost component itself.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_common") {
  compiled_packages = [
    {
      bootfs_unpackaged = true
      name = "fshost"
      components = [
        {
          component_name = "fshost"
          shards = rebase_path("//src/storage/fshost/meta/base_fshost.cml",
                               root_build_dir)
        },
      ]
      component_includes = [
        {
          source =
              rebase_path("//sdk/lib/inspect/client.shard.cml", root_build_dir)
          destination = "inspect/client.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/inspect/offer.shard.cml", root_build_dir)
          destination = "inspect/offer.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/inspect/use.shard.cml", root_build_dir)
          destination = "inspect/use.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/syslog/client.shard.cml", root_build_dir)
          destination = "syslog/client.shard.cml"
        },
        {
          source =
              rebase_path("//sdk/lib/syslog/offer.shard.cml", root_build_dir)
          destination = "syslog/offer.shard.cml"
        },
        {
          source = rebase_path("//sdk/lib/syslog/use.shard.cml", root_build_dir)
          destination = "syslog/use.shard.cml"
        },
      ]
    },
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([
                            "//src/storage/lib/fs_management/client.shard.cml",
                            "//src/storage/fshost/meta/config.cml",
                          ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_common" ]
}

# AIB adding support for storage, needed by all fshost variants that use anything more than bootfs
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_storage") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards = rebase_path([ "//src/storage/fshost/meta/core_fshost.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels =
      [ "//src/storage/fshost:assembly_bundle_fshost_storage_common" ]
}

# AIB containing the fshost with fxfs.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fxfs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([ "//src/storage/fshost/meta/fxfs_blob_fshost.cml" ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost" ]
}

# AIB containing fshost with an fvm and blobfs only.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fvm") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([ "//src/storage/fshost/meta/blobfs_fshost.cml" ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_fvm" ]
}

# AIB containing fshost with an fvm and fxfs to hold the data.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fvm_fxfs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards = rebase_path([ "//src/storage/fshost/meta/fxfs_fshost.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels =
      [ "//src/storage/fshost:assembly_bundle_fshost_fvm_fxfs" ]
}

# AIB containing fshost support for minfs. Not compatible with fxfs.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fvm_minfs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([
                            "//src/storage/fshost/meta/minfs_fshost.cml",
                            "//src/storage/fshost/meta/non_fxfs_fshost.cml",
                          ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_minfs" ]
}

# AIB containing fshost support for minfs-to-fxfs migration.
# Should be included with fshost_fxfs_fxblob or fshost_fxfs when migration
# is necessary.
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
# requires: one of fshost_fxfs*
#
assembly_input_bundle("fshost_fvm_minfs_migration") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards = rebase_path([
                                 "//src/storage/fshost/meta/minfs_fshost.cml",
                                 "//src/storage/fshost/meta/fxfs_fshost.cml",
                               ],
                               root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [
    "//src/storage/fshost:assembly_bundle_fshost",
    "//src/storage/fshost:assembly_bundle_fshost_minfs",
  ]
}

# AIB containing fshost support for f2fs
#
# optional: product must specify its inclusion
# valid feature_set_levels: all
# valid build-types: all
#
assembly_input_bundle("fshost_fvm_f2fs") {
  compiled_packages = [
    {
      name = "fshost"
      component_shards = [
        {
          component_name = "fshost"
          shards =
              rebase_path([
                            "//src/storage/fshost/meta/f2fs_fshost.cml",
                            "//src/storage/fshost/meta/non_fxfs_fshost.cml",
                          ],
                          root_build_dir)
        },
      ]
    },
  ]
  bootfs_files_labels = [ "//src/storage/fshost:assembly_bundle_fshost_f2fs" ]
}

assembly_input_bundle("system_update_checker") {
  testonly = true
  base_packages = [ "//src/sys/pkg/bin/system-update-checker" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/system-update-checker/meta/system_update_checker.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "system-update-realm"
      component_shards = [
        {
          component_name = "system-update-realm"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/system-update-checker/meta/system_update_checker.system_update_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("omaha_client") {
  base_packages = [ "//src/sys/pkg/bin/omaha-client:omaha-client-unconfigured" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/omaha-client/meta/omaha_client_service.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "system-update-realm"
      component_shards = [
        {
          component_name = "system-update-realm"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/omaha-client/meta/omaha_client_service.system_update_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]

  config_data = [
    {
      package_name = "triage-detect"
      files = [
        {
          source = "//src/diagnostics/config/triage/detect/omaha-client-detect.triage"
          destination = "omaha-client-detect.triage"
        },
      ]
    },
  ]
}

assembly_input_bundle("omaha_client_empty_eager_config") {
  config_data = [
    {
      package_name = "omaha-client"
      label = "//src/sys/pkg/bin/omaha-client:empty_eager_package_config_eager_package_config_script"
      files = [
        {
          source = "$root_build_dir/gen/src/sys/pkg/bin/omaha-client/empty_eager_package_config/omaha_client/eager_package_config.json"
          destination = "eager_package_config.json"
        },
      ]
    },
    {
      package_name = "pkg-resolver"
      label = "//src/sys/pkg/bin/omaha-client:empty_eager_package_config_eager_package_config_script"
      files = [
        {
          source = "$root_build_dir/gen/src/sys/pkg/bin/omaha-client/empty_eager_package_config/pkg_resolver/eager_package_config.json"
          destination = "eager_package_config.json"
        },
      ]
    },
  ]
}

# Used on builds that do not include an update checker, i.e. neither system_update_checker nor omaha_client.
# This is needed to expose the update protocols from `void` in #system-update.
assembly_input_bundle("no_update_checker") {
  compiled_packages = [
    {
      name = "system-update-realm"
      component_shards = [
        {
          component_name = "system-update-realm"
          shards = rebase_path(
                  [ "//src/sys/pkg/meta/no_update_checker.system_update_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Include the system-update-configurator component as part of the SWD subsystem.
assembly_input_bundle("system_update_configurator") {
  base_packages = [ "//src/sys/pkg/bin/system-update-configurator" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/system-update-configurator/meta/core-shard.cml" ],
                  root_build_dir)
        },
      ]
    },
    {
      name = "system-update-realm"
      component_shards = [
        {
          component_name = "system-update-realm"
          shards = rebase_path(
                  [ "//src/sys/pkg/bin/system-update-configurator/meta/system-update-shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("pkgfs_disable_executability_restrictions") {
  system_packages =
      [ "//src/sys/pkg/bin/pkg-cache:disable-executability-restrictions" ]
}

# AIB to enable virtualization support.
#
# optional: product must specify its inclusion
# valid feature_set_levels: minimal
# valid build-types: all
#
assembly_input_bundle("virtualization_support") {
  # TODO(https://fxbug.dev/42079015): Move to the list above once build errors are resolved.
  if (current_cpu != "riscv64") {
    base_packages = [ "//src/virtualization/bin/vmm_launcher" ]
    compiled_packages = [
      {
        name = "core"
        component_shards = [
          {
            component_name = "core"
            shards = rebase_path(
                    [
                      "//src/connectivity/network/meta/virtualization.core_shard.cml",
                      "//src/virtualization/bin/vmm_launcher/meta/vmm_launcher.core_shard.cml",
                      "//src/virtualization/bin/guest_manager/meta/debian_guest_manager.core_shard.cml",
                      "//src/virtualization/bin/guest_manager/meta/termina_guest_manager.core_shard.cml",
                      "//src/virtualization/bin/guest_manager/meta/zircon_guest_manager.core_shard.cml",
                    ],
                    root_build_dir)
          },
        ]
      },
    ]
  }
}

# AIB to enable running Fuchsia as a virtualized guest.
#
# optional: product must specify its inclusion
# valid feature_set_levels: minimal
# valid build-types: all
#
assembly_input_bundle("paravirtualization_support") {
  base_packages = [ "//src/zircon/bin/vsock_service:vsock_service" ]
}

# AIB to include Netstack2 as the netstack for use by base networking.
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("netstack2") {
  # The Go toolchain used for netstack2 does not support RISC-V.
  if (current_cpu != "riscv64") {
    base_packages = [ "//src/connectivity/network:netstack2" ]
    compiled_packages = [
      {
        name = "network"
        component_shards = [
          {
            component_name = "network"
            shards = rebase_path(
                    [ "//src/connectivity/network/meta/netstack2.shard.cml" ],
                    root_build_dir)
          },
        ]
      },
    ]
  }
}

# Netstack3 as the netstack for use by base networking.
#
# feature_set_levels: minimal
# build-types: all
#
# To be used in conjunction with netstack3_packages or netstack3_packages_gub.
#
assembly_input_bundle("netstack3") {
  compiled_packages = [
    {
      name = "network"
      component_shards = [
        {
          component_name = "network"
          shards = rebase_path(
                  [ "//src/connectivity/network/meta/netstack3.shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Netstack3 packages without unified binary.
#
# This AIB provides packages for the netstack3 configuration. It is mutually
# exclusive with netstack3_packages_gub.
assembly_input_bundle("netstack3_packages") {
  base_packages = [ "//src/connectivity/network:netstack3" ]
}

# Netstack3 packages without unified binary.
#
# This AIB provides space-saving equivalent packages for the netstack3
# configuration as found in netstack3_packages. It is mutually exclusive with
# netstack3_packages.
assembly_input_bundle("netstack3_packages_gub") {
  base_packages = [ "//src/connectivity/network:netstack3_gub" ]
}

# Netstack-migration as the netstack for use by base networking.
#
# feature_set_levels: minimal
# build-types: all
#
# Must be used in conjunction with netstack_migration_packages or
# netstack_migration_packages_gub.
assembly_input_bundle("netstack_migration") {
  # The Go toolchain used for netstack2 does not support RISC-V and
  # netstack_migration contains netstack2.
  if (current_cpu != "riscv64") {
    compiled_packages = [
      {
        name = "network"
        component_shards = [
          {
            component_name = "network"
            shards = rebase_path(
                    [ "//src/connectivity/network/meta/netstack-migration.shard.cml" ],
                    root_build_dir)
          },
        ]
      },
      {
        name = "core"
        component_shards = [
          {
            component_name = "core"
            shards = rebase_path(
                    [ "//src/connectivity/network/meta/netstack-migration.core.shard.cml" ],
                    root_build_dir)
          },
        ]
      },
    ]
  }
}

# Netstack migration packages without unified binary.
#
# This AIB provides packages for the netstack_migration configuration. It is
# mutually exclusive with netstack_migration_packages_gub.
assembly_input_bundle("netstack_migration_packages") {
  if (current_cpu != "riscv64") {
    base_packages = [ "//src/connectivity/network:netstack-migration" ]
  }
}

# Netstack migration packages with unified binary.
#
# This AIB provides packages for the netstack_migration configuration. It is
# mutually exclusive with netstack_migration_packages.
assembly_input_bundle("netstack_migration_packages_gub") {
  if (current_cpu != "riscv64") {
    base_packages = [ "//src/connectivity/network:netstack-migration_gub" ]
  }
}

# Includes network-tun functionality.
assembly_input_bundle("network_tun") {
  flexible_packages = [ "//src/connectivity/network/tun/network-tun" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/network/tun/network-tun/meta/network-tun.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Includes thread LoWPAN functionality.
assembly_input_bundle("thread_lowpan") {
  base_packages = [
    "//src/connectivity/lowpan/drivers/lowpan-ot-driver",
    "//src/connectivity/lowpan/service:lowpanservice",
  ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/connectivity/lowpan/service/meta/lowpanservice.core_shard.cml",
                    "//src/connectivity/lowpan/drivers/lowpan-ot-driver/meta/lowpan-ot-driver.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# WLAN policy component
#
# feature_set_levels: utility, minimal
# build-types: all
#
# Not included in utility + user by default, but otherwise is included.
assembly_input_bundle("wlan_policy") {
  base_packages = [
    "//src/connectivity/location/regulatory_region",
    "//src/connectivity/wlan/wlancfg",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/wlan/wlancfg/meta/wlancfg.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# WLAN development support
#
# feature_set_levels: utility, minimal
# build-types: eng, userdebug
#
assembly_input_bundle("wlan_development") {
  base_packages = [ "//src/connectivity/wlan/tools/wlantool:wlan-dev" ]
  shell_commands = [
    {
      package = "wlan"
      components = [ "wlan-dev" ]
    },
  ]
}

# WLAN support for WEP and WPA
#
# feature_set_levels: utility, minimal
# build-types: all
#
# Not included in utility + user by default, but otherwise is included.
assembly_input_bundle("wlan_legacy_privacy_support") {
  base_packages = [ "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor-legacy-privacy" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/wlan/wlandevicemonitor/meta/wlandevicemonitor.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# WLAN support for WPA2 and later
#
# feature_set_levels: utility, minimal
# build-types: all
#
# Not included in utility + user by default, but otherwise is included.
assembly_input_bundle("wlan_contemporary_privacy_only_support") {
  base_packages =
      [ "//src/connectivity/wlan/wlandevicemonitor:wlandevicemonitor" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/wlan/wlandevicemonitor/meta/wlandevicemonitor.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# WLAN support for drivers that provide their own MAC
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_fullmac_support") {
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlanif"
      driver_components = [ "meta/wlanif.cm" ]
    },
  ]
}

# WLAN support for drivers that utilize a software MAC
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_softmac_support") {
  base_driver_packages = [
    {
      package_target = "//src/connectivity/wlan/drivers/wlansoftmac"
      driver_components = [ "meta/wlansoftmac.cm" ]
    },
  ]
}

# WLAN support for interfacing with starnix.
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("wlan_wlanix") {
  base_packages = [ "//src/connectivity/wlan/wlanix" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/connectivity/wlan/wlanix/meta/wlanix.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Support for interactive debugging/development of platform audio
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("audio_development_support") {
  base_driver_packages = [
    {
      package_target = "//src/media/audio/drivers/virtual_audio"
      driver_components = [ "meta/virtual_audio_driver.cm" ]
    },
  ]

  cache_packages = [
    "//src/media/audio/services/ffxdaemon:audio_ffx_daemon",
    "//src/media/audio/tools/audio-capture-timestamp-validator",
    "//src/media/audio/tools/audio-codec-ctl",
    "//src/media/audio/tools/audio-effects-ctl",
    "//src/media/audio/tools/audio_listener",
    "//src/media/audio/tools/dsputil",
    "//src/media/audio/tools/signal_generator",
    "//src/media/audio/tools/virtual_audio_util",
    "//src/media/audio/tools/vol",
    "//src/media/audio/tools/wav_player",
    "//src/media/audio/tools/wav_recorder",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/media/audio/services/ffxdaemon/meta/audio_ffx_daemon.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]

  # From //src/media/audio/tools.
  # audio-driver-ctl is included in bootfs, not here.
  shell_commands = [
    {
      package = "audio-capture-timestamp-validator"
      components = [ "audio-capture-timestamp-validator" ]
    },
    {
      package = "audio-codec-ctl"
      components = [ "audio-codec-ctl" ]
    },
    {
      package = "audio-effects-ctl"
      components = [ "audio-effects-ctl" ]
    },
    {
      package = "audio_listener"
      components = [ "audio_listener" ]
    },
    {
      package = "dsputil"
      components = [ "dsputil" ]
    },
    {
      package = "signal_generator"
      components = [ "signal_generator" ]
    },
    {
      package = "virtual_audio_util"
      components = [ "virtual_audio" ]
    },
    {
      package = "vol"
      components = [ "vol" ]
    },
    {
      package = "wav_player"
      components = [ "wav_player" ]
    },
    {
      package = "wav_recorder"
      components = [ "wav_recorder" ]
    },
  ]
}

assembly_input_bundle("video_development_support") {
  testonly = true
  cache_packages = [ "//src/media/codec/examples:encode-file" ]
  shell_commands = [
    {
      package = "encode-file"
      components = [ "encode-file" ]
    },
  ]
}

# Component that routes audio on Smart Displays
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("audio_core") {
  base_packages = [ "//src/media/audio/audio_core" ]
}

assembly_input_bundle("audio_core_routing") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/media/audio/audio_core/meta/audio_core.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("audio_core_use_adc_device") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/media/audio/audio_core/meta/audio_core.core_shard.use_adc_device.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Component that manages platform audio devices
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("audio_device_registry") {
  flexible_packages = [ "//src/media/audio/services/device_registry" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/media/audio/services/device_registry/meta/audio_device_registry.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Component that plays audio files using audio_core protocols.
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("soundplayer") {
  flexible_packages = [ "//src/media/sounds/soundplayer" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/media/sounds/soundplayer/meta/soundplayer.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("live_usb") {
  bootfs_packages = [ "//src/sys/live_usb:package" ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path([ "//src/sys/live_usb/meta/live-usb.shard.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
}

# Session manager support
#
# feature_set_levels: minimal
# build-types: all
assembly_input_bundle("session_manager") {
  base_packages = [ "//src/session/bin/session_manager" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/session/bin/session_manager/meta/minimal.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Element manager support
#
# feature_set_levels: minimal
# build-types: all
assembly_input_bundle("element_manager") {
  flexible_packages = [ "//src/session/bin/element_manager" ]
}

# UI support
#
# feature_set_levels: minimal
# build-types: all
#
assembly_input_bundle("ui") {
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards =
              rebase_path([ "//src/ui/meta/ui.core_shard.cml" ], root_build_dir)
        },
      ]
    },
  ]
}

# UI support for eng build types
#
# feature_set_levels: minimal
# build-types: eng
#
icu_assembly_input_bundle("ui_eng") {
  icu_cache_packages = [
    "//src/ui/a11y/bin/a11y_manager:a11y-manager",

    "//src/ui/bin/scene_manager:scene_manager",
  ]
  cache_packages = [
    "//src/graphics/display/bin/coordinator-connector",
    "//src/ui/bin/text:text_manager",
    "//src/ui/scenic:scenic_pkg",
    "//src/ui/bin/virtual_keyboard_manager",
  ]
}

# UI support for user and userdebug build types
#
# feature_set_levels: minimal
# build-types: user, userdebug
#
icu_assembly_input_bundle("ui_user_and_userdebug") {
  icu_base_packages = [
    "//src/ui/a11y/bin/a11y_manager:a11y-manager",

    "//src/ui/bin/scene_manager:scene_manager",
  ]
  base_packages = [
    "//src/graphics/display/bin/coordinator-connector",
    "//src/ui/bin/text:text_manager",
    "//src/ui/scenic:scenic_pkg",
    "//src/ui/bin/virtual_keyboard_manager",
  ]
}

# UI support for eng build types
#
# feature_set_levels: minimal
# build-types: eng
#
assembly_input_bundle("ui_package_eng") {
  cache_packages = [ "//src/ui:ui_package" ]
}

# UI support for user and userdebug build types
#
# feature_set_levels: minimal
# build-types: user, userdebug
#
assembly_input_bundle("ui_package_user_and_userdebug") {
  base_packages = [ "//src/ui:ui_package" ]
}

# UI support for builds wants synthetic device support
#
# Use PlatformUiConfig.with_synthetic_device_support to select this bundle
# over ui_package_eng / ui_package_user_and_userdebug.
#
# feature_set_levels: minimal
# build-types: eng, userdebug
#
assembly_input_bundle(
    "ui_package_eng_userdebug_with_synthetic_device_support") {
  flexible_packages = [ "//src/ui:ui_with_synthetic_device_support_package" ]
}

# Fan support
#
# feature_set_levels: utility, minimal
# build-types: all
#
assembly_input_bundle("fan") {
  base_packages = [ "//src/devices/thermal/bin/fan-controller" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/devices/thermal/bin/fan-controller/meta/fan-controller.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Battery support
#
# feature_set_levels: utility, minimal
# build-types: all
#
assembly_input_bundle("battery_manager") {
  base_packages = [ "//src/power/battery-manager" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/power/battery-manager/meta/battery_manager.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Power metrics recorder support
#
# feature_set_levels: minimal
# build-types: all
assembly_input_bundle("power_metrics_recorder") {
  base_packages = [ "//src/power/metrics-logger:metrics-logger-standalone-pkg" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/power/metrics-logger/meta/metrics-logger-standalone.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Sensors support
#
# features_set_levels: utility, minimal
# build-types: all
#
assembly_input_bundle("sensors_framework") {
  base_packages = [ "//src/sensors" ]
  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path([ "//src/sensors/meta/sensors.core_shard.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
}

# Sensor playback support.
#
# features_set_levels: utility, minimal
# build-types: eng
#
assembly_input_bundle("sensors_playback") {
  base_packages = [ "//src/sensors/playback:sensors_playback" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/sensors/playback/meta/sensors_playback.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Brightness Manager support
#
# features_set_levels: minimal
# build-types: all
#
assembly_input_bundle("brightness_manager") {
  flexible_packages =
      [ "//src/ui/bin/brightness_manager:brightness_manager_pkg" ]
}

# Legacy Power Framework support. Avoids including more modern power framework components.
#
# feature_set_levels: utility, minimal
# build-types: eng
#
assembly_input_bundle("legacy_power_framework") {
  bootfs_packages = [
    "//src/power/power-manager:package",
    "//src/power/cpu-manager:package",
  ]
  compiled_packages = [
    {
      name = "bootstrap"
      component_shards = [
        {
          component_name = "bootstrap"
          shards = rebase_path([ "//src/power/meta/power-framework.shard.cml" ],
                               root_build_dir)
        },
      ]
    },
  ]
}

assembly_input_bundle("power_framework") {
  bootfs_packages = [
    "//src/power/broker:package",
    "//src/power/system-activity-governor:package",
  ]
  base_packages = [ "//src/devices/hrtimer/bin:hrtimer-ctl" ]

  # When power framework becomes available on user builds,
  # this tool should be moved to core_realm_development_access
  shell_commands = [
    {
      package = "hrtimer-ctl"
      components = [ "hrtimer-ctl" ]
    },
  ]
}

# Example assembly input bundle for testing
#
# Restricted for testing assembly itself (and to provide example code)
#
assembly_input_bundle("example_assembly_bundle") {
  testonly = true
  compiled_packages = [
    # Main definition for another package
    {
      name = "for-test"

      # Test that multiple components work
      components = [
        {
          component_name = "bar"
          shards = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                  root_build_dir)
        },
        {
          component_name = "baz"
          shards = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                  root_build_dir)
        },
      ]

      # Test that component includes for bootfs packages work
      component_includes = [
        {
          source = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.include.cml",
                  root_build_dir)
          destination = "test/include.cml"
        },
      ]
    },

    {
      name = "for-test2"
      components = [
        {
          component_name = "qux"
          shards = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.cml",
                  root_build_dir)
        },
      ]

      # Test that component includes for bootfs packages work
      component_includes = [
        {
          source = rebase_path(
                  "//src/tests/assembly/assemble_image/compiled_package/meta/test.include.cml",
                  root_build_dir)
          destination = "test/include.cml"
        },
      ]

      # Test that bootfs packages work
      bootfs_unpackaged = true
    },

    # Add a shard to the `core` package which should have a main definition
    # in the legacy bundle
    {
      name = "core"
      component_shards = [
        {
          # All paths must be rebased since this is passed directly to the AIB
          # config.
          component_name = "core"
          shards = rebase_path(
                  [ "//src/tests/assembly/assemble_image/compiled_package/meta/test.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

########
#
# Hardware Support AIBs
#
# These are used to provide support for specific hardware

# Emulator Support
#
# This is the "emulator support" bundle, which provides the kernel that can be
# booted by an emulator, and which knows how to then boot the Fuchsia kernel
# itself (Zircon).
#
assembly_input_bundle("emulator_support") {
  qemu_kernel = qemu_boot_shim.path
  deps = qemu_boot_shim.deps
}

# Enabling a soft-transition, remove when complete
# TODO(122864) Remove transitional labels
group("third_party_sbase_for_transition") {
  public_deps = [ "//third_party/sbase:sbase-pkgs" ]
}

# Assembly may select at most one bundle with `intl_services` name prefix.
icu_assembly_input_bundle("intl_services") {
  icu_base_packages = [ "//src/intl/intl_services:pkg" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/intl/intl_services/meta/intl.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Assembly may select at most one bundle with `intl_services` name prefix.
icu_assembly_input_bundle("intl_services_small") {
  icu_base_packages = [ "//src/intl/intl_services:pkg_small" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/intl/intl_services/meta/intl_small_timezones.core_shard.cml",
                    "//src/intl/intl_services/meta/intl_small.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Assembly may select at most one bundle with `intl_services` name prefix.
icu_assembly_input_bundle("intl_services_small_with_timezone") {
  icu_base_packages = [
    "//src/intl/intl_services:pkg_small",
    "//src/intl/time_zone_info_service:pkg",
  ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [
                    "//src/intl/intl_services/meta/intl_small.core_shard.cml",
                    "//src/intl/time_zone_info_service/meta/time-zone-info-service.core_shard.cml",
                  ],
                  root_build_dir)
        },
      ]
    },
  ]
}

icu_assembly_input_bundle("setui") {
  icu_base_packages = [ "//src/settings/service:setui_service" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/settings/service/meta/setui_service.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

icu_assembly_input_bundle("setui_with_camera") {
  icu_base_packages = [ "//src/settings/service:setui_service" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/settings/service/meta/setui_service_with_camera.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}

# Legacy fonts setup: fonts sourced from config-data.
assembly_input_bundle("fonts") {
  base_packages = [ "//src/fonts:pkg" ]
}

# Hermetic fonts setup: fonts sourced from a component.
assembly_input_bundle("fonts_hermetic") {
  base_packages = [
    "//src/fonts/asset_providers:server.package",
    "//src/fonts/asset_providers:provider.package",
  ]
}

# Static resources files to make available to product assembly subsystems.
assembly_resources_directory("resources") {
  sources = [
    "//src/developer/memory/buckets/buckets.json",
    "//src/sys/core/core_component_id_index.json5",

    # Platform configs for the component_manager config.
    "//src/security/policy/component_manager_policy.json5",
    "//src/security/policy/component_manager_policy_base.json5",
    "//src/security/policy/component_manager_policy_build_type_base.json5",
    "//src/security/policy/component_manager_policy_eng.json5",
    "//src/security/policy/component_manager_policy_user.json5",
    "//src/security/policy/component_manager_policy_userdebug.json5",
    "//src/security/policy/subsystems/component_manager_policy_starnix.json5",
    "//src/sys/component_manager/configs/bootfs_config.json5",

    # Networking resources.
    "//src/connectivity/policy/netcfg/config/netcfg_default.json",

    # ICU resources.
    "${icu_tzres_path}/metaZones.res",
    "${icu_tzres_path}/timezoneTypes.res",
    "${icu_tzres_path}/zoneinfo64.res",
    "${root_gen_dir}/src/lib/icu/tzdata/revision.txt",

    # Core shard templates.
    "//src/connectivity/weave/meta/weavestack.core_shard.cml.template",
    "//src/developer/forensics/flash_ts_feedback_id/meta/flash_ts_feedback_id.core_shard.cml.template",
    "//src/media/audio/meta/multizone_leader.core_shard.cml.template",
    "//src/media/audio/meta/multizone_leader.core_shard_eng.cml",
  ]
  deps = [ "//src/lib/icu/tzdata:revision" ]
}

# Enables in kernel compression of anonymous memory with some common configuration options.
assembly_input_bundle("kernel_anonymous_memory_compression") {
  kernel_cmdline = [
    "kernel.compression.strategy=lz4",
    "kernel.compression.storage-strategy=tri_page",
    "kernel.compression.reclaim_anonymous=true",
    "kernel.compression.reclaim_zero_forks=true",
    "kernel.compression.at_memory_pressure=true",
  ]
}

# Enables in kernel contiguous physical pages with some common configuration options.
assembly_input_bundle("kernel_contiguous_physical_pages") {
  # Physical page loaning and borrowing.
  #
  # "k ppb stats" (see also "k ppb help") can be used to check whether the
  # vast majority of loaned pages are absorbed by using them for pager-backed
  # VMOs when running a relevant workload (not just mostly idle), or if some
  # loaned pages remain stranded even as the system approaches OOM. As long as
  # loaned free pages hits a low fraction of this value before any overall
  # OOM, pages aren't being stranded when it really matters.
  kernel_cmdline = [
    "kernel.ppb.loan=true",
    "kernel.ppb.borrow-in-supplypages=true",
    "kernel.ppb.borrow-on-mru=true",
    "kernel.ppb.replace-on-unloan=true",
  ]
}

# Extends compression to happen eagerly as part of queue rotation, only has meaning if
# "kernel_compression" is also included.
assembly_input_bundle("kernel_anonymous_memory_compression_eager_lru") {
  kernel_cmdline = [ "kernel.page-scanner.lru-action=compress_only" ]
}

# Assembly selects whether to include this AIB or not.
assembly_input_bundle("zoneinfo") {
  base_packages = [ "//src/intl/tzdata_provider:zoneinfo_provider_pkg" ]

  compiled_packages = [
    {
      name = "core"
      component_shards = [
        {
          component_name = "core"
          shards = rebase_path(
                  [ "//src/intl/tzdata_provider/meta/zoneinfo_provider.core_shard.cml" ],
                  root_build_dir)
        },
      ]
    },
  ]
}
