// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
#define SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_

// Warning:
// This file was autogenerated by cbindgen.
// Do not modify this file manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <zircon/types.h>

typedef struct {
  void *ctx;
  /**
   * Sends a WLAN MAC frame to the C++ portion of wlansoftmac.
   *
   * # Safety
   *
   * Behavior is undefined unless `payload` contains a persisted `FrameSender.WlanTx` request
   * and `payload_len` is the length of the persisted byte array.
   */
  zx_status_t (*wlan_tx)(void *ctx, const uint8_t *payload, uintptr_t payload_len);
  /**
   * Sends an Ethernet frame to the C++ portion of wlansoftmac.
   *
   * # Safety
   *
   * Behavior is undefined unless `payload` contains a persisted `FrameSender.EthernetRx` request
   * and `payload_len` is the length of the persisted byte array.
   */
  zx_status_t (*ethernet_rx)(void *ctx, const uint8_t *payload, uintptr_t payload_len);
} frame_sender_t;

/**
 * Type that wraps a pointer to a buffer allocated in the C++ portion of wlansoftmac.
 */
typedef struct {
  /**
   * Returns the buffer's ownership and free it.
   *
   * # Safety
   *
   * The `free` function is unsafe because the function cannot guarantee the pointer it's
   * called with is the `raw` field in this struct.
   *
   * By calling `free`, the caller promises the pointer it's called with is the `raw` field
   * in this struct.
   */
  void (*free)(void *raw);
  /**
   * Pointer to the buffer allocated in the C++ portion of wlansoftmac and owned by the Rust
   * portion of wlansoftmac.
   */
  void *raw;
  /**
   * Pointer to the start of bytes written in the buffer.
   */
  uint8_t *data;
  /**
   * Capacity of the buffer, starting at `data`.
   */
  uintptr_t capacity;
} wlansoftmac_buffer_t;

typedef struct {
  /**
   * Allocate and take ownership of a buffer allocated by the C++ portion of wlansoftmac
   * with at least `min_capacity` bytes of capacity.
   *
   * The returned `CBuffer` contains a pointer whose pointee the caller now owns, unless that
   * pointer is the null pointer. If the pointer is non-null, then the `Drop` implementation of
   * `CBuffer` ensures its `free` will be called if its dropped. If the pointer is null, the
   * allocation failed, and the caller must discard the `CBuffer` without calling its `Drop`
   * implementation.
   *
   * # Safety
   *
   * This function is unsafe because the returned `CBuffer` could contain null pointers,
   * indicating the allocation failed.
   *
   * By calling this function, the caller promises to call `mem::forget` on the returned
   * `CBuffer` if either the `raw` or `data` fields in the `CBuffer` are null.
   */
  wlansoftmac_buffer_t (*get_buffer)(uintptr_t min_capacity);
} wlansoftmac_buffer_provider_ops_t;

typedef struct {
  void (*wlan_rx)(const void *ctx, const uint8_t *request, uintptr_t request_size);
  zx_status_t (*ethernet_tx)(const void *ctx, const uint8_t *request, uintptr_t request_size);
} frame_processor_ops_t;

/**
 * Type containing pointers to the static `FRAME_PROCESSOR_OPS` and a `DriverEventSink`.
 *
 * The wlansoftmac driver copies the pointers from `CFrameProcessor` which means the code
 * constructing this type must ensure those pointers remain valid for their lifetime in
 * wlansoftmac.
 */
typedef struct {
  const frame_processor_ops_t *ops;
  const void *ctx;
} frame_processor_t;

/**
 * Start and run a bridged wlansoftmac driver hosting an MLME server and an SME server.
 *
 * The driver is "bridged" in the sense that it requires a bridge to a Fuchsia driver to
 * communicate with other Fuchsia drivers over the FDF transport. When initialization of the
 * bridged driver completes, `run_init_completer` will be called.
 *
 * # Safety
 *
 * There are two layers of safety documentation for this function. The first layer is for this
 * function itself, and the second is for the `run_init_completer` function.
 *
 * ## For this function itself
 *
 * This function is unsafe for the following reasons:
 *
 *   - This function cannot guarantee `run_init_completer` is thread-safe, i.e., that it's safe to
 *     to call at any time from any thread.
 *   - This function cannot guarantee `init_completer` points to a valid object when
 *     `run_init_completer` is called.
 *   - This function cannot guarantee `wlan_softmac_bridge_client_handle` is a valid handle.
 *
 * By calling this function, the caller promises the following:
 *
 *   - The `run_init_completer` function is thread-safe.
 *   - The `init_completer` pointer will point to a valid object at least until
 *     `run_init_completer` is called.
 *   - The `wlan_softmac_bridge_client_handle` is a valid handle.
 *
 * ## For `run_init_completer`
 *
 * The `run_init_completer` function is unsafe because it cannot guarantee the `init_completer`
 * argument will be the same `init_completer` passed to `start_and_run_bridged_wlansoftmac`, and
 * cannot guarantee it will be called exactly once.
 *
 * The caller of `run_init_completer` must promise to pass the same `init_completer` from
 * `start_and_run_bridged_wlansoftmac` to `run_init_completer` and call `run_init_completer`
 * exactly once.
 */
extern "C" zx_status_t start_and_run_bridged_wlansoftmac(
    void *init_completer, void (*run_init_completer)(void *init_completer, zx_status_t status),
    frame_sender_t frame_sender, wlansoftmac_buffer_provider_ops_t buffer_provider,
    zx_handle_t wlan_softmac_bridge_client_handle);

#endif  // SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
