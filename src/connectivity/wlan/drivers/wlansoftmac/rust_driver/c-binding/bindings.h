// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
#define SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_

// Warning:
// This file was autogenerated by cbindgen.
// Do not modify this file manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <zircon/types.h>

typedef struct {
  void *ctx;
  /**
   * Sends an Ethernet frame to the C++ portion of wlansoftmac.
   *
   * # Safety
   *
   * Behavior is undefined unless `payload` contains a persisted `EthernetRx.Transfer` request
   * and `payload_len` is the length of the persisted byte array.
   */
  zx_status_t (*transfer)(void *ctx, const uint8_t *payload, uintptr_t payload_len);
} ethernet_rx_t;

typedef struct {
  void *ctx;
  /**
   * Sends a WLAN MAC frame to the C++ portion of wlansoftmac.
   *
   * # Safety
   *
   * Behavior is undefined unless `payload` contains a persisted `WlanTx.Transfer` request
   * and `payload_len` is the length of the persisted byte array.
   */
  zx_status_t (*transfer)(void *ctx, const uint8_t *payload, uintptr_t payload_len);
} wlan_tx_t;

/**
 * Type that wraps a pointer to a buffer allocated in the C++ portion of wlansoftmac.
 */
typedef struct {
  /**
   * Returns the buffer's ownership and free it.
   *
   * # Safety
   *
   * The `free` function is unsafe because the function cannot guarantee the pointer it's
   * called with is the `ctx` field in this struct.
   *
   * By calling `free`, the caller promises the pointer it's called with is the `ctx` field
   * in this struct.
   */
  void (*free)(void *ctx);
  /**
   * Pointer to the buffer allocated in the C++ portion of wlansoftmac and owned by the Rust
   * portion of wlansoftmac. An `FfiBufferProvider` sets this pointer to null when the allocation
   * failed.
   */
  void *ctx;
  /**
   * Pointer to the start of bytes written in the buffer.
   */
  uint8_t *data;
  /**
   * Capacity of the buffer, starting at `data`.
   */
  uintptr_t capacity;
} wlansoftmac_buffer_t;

typedef struct {
  /**
   * Allocate and take ownership of a buffer allocated by the C++ portion of wlansoftmac
   * with at least `min_capacity` bytes of capacity.
   *
   * If the requested allocation is zero bytes, this function should return an `FfiBuffer`
   * with a null `ctx` pointer indicating the allocation failed.
   *
   * The returned `FfiBuffer` contains a pointer whose pointee the caller now owns, unless that
   * pointer is the null pointer. If the pointer is non-null, then the `Drop` implementation of
   * `FfiBuffer` ensures its `free` will be called if its dropped. Otherwise, `free` will not,
   * and should not, be called.
   */
  wlansoftmac_buffer_t (*get_buffer)(uintptr_t min_capacity);
} wlansoftmac_buffer_provider_ops_t;

typedef struct {
  const void *ctx;
  zx_status_t (*transfer)(const void *ctx, const uint8_t *request, uintptr_t request_size);
} ethernet_tx_t;

typedef struct {
  const void *ctx;
  void (*transfer)(const void *ctx, const uint8_t *request, uintptr_t request_size);
} wlan_rx_t;

/**
 * Start and run a bridged wlansoftmac driver hosting an MLME server and an SME server.
 *
 * The driver is "bridged" in the sense that it requires a bridge to a Fuchsia driver to
 * communicate with other Fuchsia drivers over the FDF transport. When initialization of the
 * bridged driver completes, `run_init_completer` will be called.
 *
 * # Safety
 *
 * There are two layers of safety documentation for this function. The first layer is for this
 * function itself, and the second is for the `run_init_completer` function.
 *
 * ## For this function itself
 *
 * This function is unsafe for the following reasons:
 *
 *   - This function cannot guarantee `run_init_completer` is thread-safe, i.e., that it's safe to
 *     to call at any time from any thread.
 *   - This function cannot guarantee `init_completer` points to a valid object when
 *     `run_init_completer` is called.
 *   - This function cannot guarantee `wlan_softmac_bridge_client_handle` is a valid handle.
 *
 * By calling this function, the caller promises the following:
 *
 *   - The `run_init_completer` function is thread-safe.
 *   - The `init_completer` pointer will point to a valid object at least until
 *     `run_init_completer` is called.
 *   - The `wlan_softmac_bridge_client_handle` is a valid handle.
 *
 * ## For `run_init_completer`
 *
 * The `run_init_completer` function is unsafe because it cannot guarantee the `init_completer`
 * argument will be the same `init_completer` passed to `start_and_run_bridged_wlansoftmac`, and
 * cannot guarantee it will be called exactly once.
 *
 * The caller of `run_init_completer` must promise to pass the same `init_completer` from
 * `start_and_run_bridged_wlansoftmac` to `run_init_completer` and call `run_init_completer`
 * exactly once.
 */
extern "C" zx_status_t start_and_run_bridged_wlansoftmac(
    void *init_completer, void (*run_init_completer)(void *init_completer, zx_status_t status),
    ethernet_rx_t ethernet_rx, wlan_tx_t wlan_tx, wlansoftmac_buffer_provider_ops_t buffer_provider,
    zx_handle_t wlan_softmac_bridge_client_handle);

#endif  // SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
