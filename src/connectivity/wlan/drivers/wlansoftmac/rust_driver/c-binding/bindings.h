// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
#define SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_

// Warning:
// This file was autogenerated by cbindgen.
// Do not modify this file manually.

#include <fuchsia/wlan/common/c/banjo.h>
#include <fuchsia/wlan/ieee80211/c/banjo.h>
#include <fuchsia/wlan/internal/c/banjo.h>
#include <fuchsia/wlan/softmac/c/banjo.h>
#include <lib/trace/event.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <zircon/types.h>

typedef struct wlansoftmac_handle_t wlansoftmac_handle_t;

typedef struct {
  void (*recv)(void *ctx, const wlan_rx_packet_t *packet);
  void (*complete_tx)(void *ctx, const wlan_tx_packet_t *packet, int32_t status);
  void (*report_tx_result)(void *ctx, const wlan_tx_result_t *tx_result);
  void (*scan_complete)(void *ctx, int32_t status, uint64_t scan_id);
} rust_wlan_softmac_ifc_protocol_ops_copy_t;

/**
 * Hand-rolled Rust version of the banjo wlan_softmac_ifc_protocol for communication from the driver
 * up. Note that we copy the individual fns out of this struct into the equivalent generated struct
 * in C++. Thanks to cbindgen, this gives us a compile-time confirmation that our function
 * signatures are correct.
 */
typedef struct {
  const rust_wlan_softmac_ifc_protocol_ops_copy_t *ops;
  void *ctx;
} rust_wlan_softmac_ifc_protocol_copy_t;

/**
 * An output buffer requires its owner to manage the underlying buffer's memory themselves.
 * An output buffer is used for every buffer handed from Rust to C++.
 */
typedef struct {
  /**
   * Pointer to the buffer's underlying data structure.
   */
  void *raw;
  /**
   * Pointer to the start of the buffer's data portion and the amount of bytes written.
   */
  uint8_t *data;
  uintptr_t written_bytes;
} wlansoftmac_out_buf_t;

/**
 * A `Device` allows transmitting frames and MLME messages.
 */
typedef struct {
  void *device;
  /**
   * Start operations on the underlying device and return the SME channel.
   */
  int32_t (*start)(void *device, const rust_wlan_softmac_ifc_protocol_copy_t *ifc,
                   zx_handle_t wlan_softmac_ifc_bridge_client_handle, zx_handle_t *out_sme_channel);
  /**
   * Request to deliver an Ethernet II frame to Fuchsia's Netstack.
   */
  int32_t (*deliver_eth_frame)(void *device, const uint8_t *data, uintptr_t len);
  /**
   * Deliver a WLAN frame directly through the firmware.
   */
  int32_t (*queue_tx)(void *device, uint32_t options, wlansoftmac_out_buf_t buf,
                      wlan_tx_info_t tx_info, trace_async_id_t async_id);
  /**
   * Reports the current status to the ethernet driver.
   */
  int32_t (*set_ethernet_status)(void *device, uint32_t status);
} rust_device_interface_t;

/**
 * An input buffer will always be returned to its original owner when no longer being used.
 * An input buffer is used for every buffer handed from C++ to Rust.
 */
typedef struct {
  /**
   * Returns the buffer's ownership and free it.
   */
  void (*free_buffer)(void *raw);
  /**
   * Pointer to the buffer's underlying data structure.
   */
  void *raw;
  /**
   * Pointer to the start of the buffer's data portion and its length.
   */
  uint8_t *data;
  uintptr_t len;
} wlansoftmac_in_buf_t;

typedef struct {
  /**
   * Acquire a `InBuf` with a given minimum length from the provider.
   * The provider must release the underlying buffer's ownership and transfer it to this crate.
   * The buffer will be returned via the `free_buffer` callback when it's no longer used.
   */
  wlansoftmac_in_buf_t (*get_buffer)(uintptr_t min_len);
} wlansoftmac_buffer_provider_ops_t;

/**
 * A convenient C-wrapper for read-only memory that is neither owned or managed by Rust
 */
typedef struct {
  const uint8_t *data;
  uintptr_t size;
} wlan_span_t;

/**
 * Start and run a bridged wlansoftmac driver hosting an MLME server and an SME server. The driver
 * is "bridged" in sense that it requires a bridge to a Fuchsia driver to communicate with other
 * Fuchsia drivers over the FDF transport. When initialization of the bridged driver completes,
 * run_init_completer will be called.
 *
 * # Safety
 *
 * The caller of this function should provide raw pointers that will be valid in the address space
 * where the Rust portion of wlansoftmac will run.
 */
extern "C" zx_status_t start_and_run_bridged_wlansoftmac(
    void *init_completer,
    void (*run_init_completer)(void *init_completer, zx_status_t status,
                               wlansoftmac_handle_t *wlan_softmac_handle),
    rust_device_interface_t device, wlansoftmac_buffer_provider_ops_t buf_provider,
    zx_handle_t wlan_softmac_bridge_client_handle);

/**
 * FFI interface: Stop a WlanSoftmac via the WlanSoftmacHandle. Takes ownership and invalidates
 * the passed WlanSoftmacHandle.
 *
 * # Safety
 *
 * This function casts a raw pointer to a WlanSoftmacHandle. This API is fundamentally
 * unsafe, and relies on the caller passing ownership of the correct pointer.
 */
extern "C" void stop_bridged_wlansoftmac(void *completer, void (*run_completer)(void *completer),
                                         wlansoftmac_handle_t *softmac);

/**
 * FFI interface: Queue an ethernet frame to be sent over the air. The caller should either end the
 * async trace event corresponding to |async_id| if an error occurs or deferred ending the trace to
 * a later call into the C++ portion of wlansoftmac.
 *
 * Assuming no errors occur, the Rust portion of wlansoftmac will eventually
 * rust_device_interface_t.queue_tx() with the same |async_id|. At that point, the C++ portion of
 * wlansoftmac will assume responsibility for ending the async trace event.
 */
extern "C" zx_status_t sta_queue_eth_frame_tx(wlansoftmac_handle_t *softmac, wlan_span_t frame,
                                              trace_async_id_t async_id);

#endif  // SRC_CONNECTIVITY_WLAN_DRIVERS_WLANSOFTMAC_RUST_DRIVER_C_BINDING_BINDINGS_H_
