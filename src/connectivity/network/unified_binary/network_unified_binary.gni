# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/dist/renamed_binary.gni")
import("//build/rust/rustc_binary.gni")
import("//build/rust/rustc_library.gni")

declare_args() {
  # Use the unified network Rust binary.
  #
  # This flag controls compiling network-related Rust components into a single
  # binary. Its purpose is to allow one-shot transition between the build modes
  # and accelerate build times locally once the default is to use unified
  # binaries.
  use_network_unified_binary = false
}

# Defines a renamed binary based on network_unified_binary.
#
# network_unified_binary is a single binary that merges together multiple
# networking Rust programs. The entry point to the combined program can identify
# which sub-program the caller intends to run based on the filename of the
# invocation (`argv[0]`).
#
# Takes the same arguments as rustc_binary.
template("network_unified_binary") {
  if (use_network_unified_binary) {
    output_name = target_name
    if (defined(invoker.name)) {
      output_name = invoker.name
    }
    _source_root = "src/main.rs"
    if (defined(invoker.source_root)) {
      _source_root = invoker.source_root
    }
    _with_unit_tests = false
    if (defined(invoker.with_unit_tests)) {
      _with_unit_tests = invoker.with_unit_tests
    }

    library_target_name = target_name + "_gub_lib"
    rustc_library(library_target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "name",
                               "source_root",
                               "with_unit_tests",
                             ])
      name = output_name
      source_root = _source_root
      with_unit_tests = _with_unit_tests
      configs -= [ "//build/config/rust/lints:allow_unused_results" ]
    }

    if (_with_unit_tests) {
      # Create a target that matches the shape of rustc_binary. We need to
      # rename the binary so it looks like it was generated by rustc_binary
      # instead of rustc_library.
      test_target_name = target_name + "_test"
      library_test_target = library_target_name + "_test"
      renamed_binary(test_target_name) {
        testonly = true
        source_deps = [ ":$library_test_target" ]
        source = "$root_out_dir/${output_name}_lib_test"
        dest = "bin/${output_name}_bin_test"
      }
    }

    renamed_binary(target_name) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      source_deps =
          [ "//src/connectivity/network/unified_binary:network_unified_binary" ]
      deps = [ ":$library_target_name" ]

      # Force a barrier on the library target, which prevents includes from all
      # the dependencies of the unified binary from causing check_includes to
      # bubble up to dependent components.
      metadata = {
        expect_includes_barrier = [ ":$library_target_name" ]
      }
      source = "$root_out_dir/network_unified_binary"
      dest = "bin/$output_name"
    }
  } else {
    # Behave like a regular rust binary if unified binary is off.
    rustc_binary(target_name) {
      forward_variables_from(invoker, "*")
      configs -= [ "//build/config/rust/lints:allow_unused_results" ]
    }
  }
}
