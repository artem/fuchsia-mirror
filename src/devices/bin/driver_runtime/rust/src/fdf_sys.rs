// Copyright 2024 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generated by src/devices/bin/driver_runtime/rust/bindgen.sh using bindgen 0.69.4

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub use fuchsia_zircon_types::*;

pub const DRIVER_REGISTRATION_VERSION_1: u32 = 1;
pub const DRIVER_REGISTRATION_VERSION_MAX: u32 = 1;
pub type async_dispatcher_t = async_dispatcher;
pub type async_guest_bell_trap_t = async_guest_bell_trap;
pub type async_wait_t = async_wait;
pub type async_task_t = async_task;
pub type async_receiver_t = async_receiver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_irq {
    _unused: [u8; 0],
}
pub type async_irq_t = async_irq;
pub type async_paged_vmo_t = async_paged_vmo;
pub type async_sequence_id_t = async_sequence_id;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_state_t {
    pub reserved: [usize; 2usize],
}
const _: () = {
    ["Size of async_state_t"][::core::mem::size_of::<async_state_t>() - 16usize];
    ["Alignment of async_state_t"][::core::mem::align_of::<async_state_t>() - 8usize];
    ["Offset of field: async_state_t::reserved"]
        [::core::mem::offset_of!(async_state_t, reserved) - 0usize];
};
pub type async_ops_version_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_ops {
    pub version: async_ops_version_t,
    pub reserved: u32,
    pub v1: async_ops_v1,
    pub v2: async_ops_v2,
    pub v3: async_ops_v3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_ops_v1 {
    pub now: ::core::option::Option<
        unsafe extern "C" fn(dispatcher: *mut async_dispatcher_t) -> zx_time_t,
    >,
    pub begin_wait: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            wait: *mut async_wait_t,
        ) -> zx_status_t,
    >,
    pub cancel_wait: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            wait: *mut async_wait_t,
        ) -> zx_status_t,
    >,
    pub post_task: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            task: *mut async_task_t,
        ) -> zx_status_t,
    >,
    pub cancel_task: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            task: *mut async_task_t,
        ) -> zx_status_t,
    >,
    pub queue_packet: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            receiver: *mut async_receiver_t,
            data: *const zx_packet_user_t,
        ) -> zx_status_t,
    >,
    pub set_guest_bell_trap: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            trap: *mut async_guest_bell_trap_t,
            guest: zx_handle_t,
            addr: zx_vaddr_t,
            length: usize,
        ) -> zx_status_t,
    >,
}
const _: () = {
    ["Size of async_ops_v1"][::core::mem::size_of::<async_ops_v1>() - 56usize];
    ["Alignment of async_ops_v1"][::core::mem::align_of::<async_ops_v1>() - 8usize];
    ["Offset of field: async_ops_v1::now"][::core::mem::offset_of!(async_ops_v1, now) - 0usize];
    ["Offset of field: async_ops_v1::begin_wait"]
        [::core::mem::offset_of!(async_ops_v1, begin_wait) - 8usize];
    ["Offset of field: async_ops_v1::cancel_wait"]
        [::core::mem::offset_of!(async_ops_v1, cancel_wait) - 16usize];
    ["Offset of field: async_ops_v1::post_task"]
        [::core::mem::offset_of!(async_ops_v1, post_task) - 24usize];
    ["Offset of field: async_ops_v1::cancel_task"]
        [::core::mem::offset_of!(async_ops_v1, cancel_task) - 32usize];
    ["Offset of field: async_ops_v1::queue_packet"]
        [::core::mem::offset_of!(async_ops_v1, queue_packet) - 40usize];
    ["Offset of field: async_ops_v1::set_guest_bell_trap"]
        [::core::mem::offset_of!(async_ops_v1, set_guest_bell_trap) - 48usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_ops_v2 {
    pub bind_irq: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            irq: *mut async_irq_t,
        ) -> zx_status_t,
    >,
    pub unbind_irq: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            irq: *mut async_irq_t,
        ) -> zx_status_t,
    >,
    pub create_paged_vmo: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            paged_vmo: *mut async_paged_vmo_t,
            options: u32,
            pager: zx_handle_t,
            vmo_size: u64,
            vmo_out: *mut zx_handle_t,
        ) -> zx_status_t,
    >,
    pub detach_paged_vmo: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            paged_vmo: *mut async_paged_vmo_t,
        ) -> zx_status_t,
    >,
}
const _: () = {
    ["Size of async_ops_v2"][::core::mem::size_of::<async_ops_v2>() - 32usize];
    ["Alignment of async_ops_v2"][::core::mem::align_of::<async_ops_v2>() - 8usize];
    ["Offset of field: async_ops_v2::bind_irq"]
        [::core::mem::offset_of!(async_ops_v2, bind_irq) - 0usize];
    ["Offset of field: async_ops_v2::unbind_irq"]
        [::core::mem::offset_of!(async_ops_v2, unbind_irq) - 8usize];
    ["Offset of field: async_ops_v2::create_paged_vmo"]
        [::core::mem::offset_of!(async_ops_v2, create_paged_vmo) - 16usize];
    ["Offset of field: async_ops_v2::detach_paged_vmo"]
        [::core::mem::offset_of!(async_ops_v2, detach_paged_vmo) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_ops_v3 {
    pub get_sequence_id: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            out_sequence_id: *mut async_sequence_id_t,
            out_error: *mut *const ::core::ffi::c_char,
        ) -> zx_status_t,
    >,
    pub check_sequence_id: ::core::option::Option<
        unsafe extern "C" fn(
            dispatcher: *mut async_dispatcher_t,
            sequence_id: async_sequence_id_t,
            out_error: *mut *const ::core::ffi::c_char,
        ) -> zx_status_t,
    >,
}
const _: () = {
    ["Size of async_ops_v3"][::core::mem::size_of::<async_ops_v3>() - 16usize];
    ["Alignment of async_ops_v3"][::core::mem::align_of::<async_ops_v3>() - 8usize];
    ["Offset of field: async_ops_v3::get_sequence_id"]
        [::core::mem::offset_of!(async_ops_v3, get_sequence_id) - 0usize];
    ["Offset of field: async_ops_v3::check_sequence_id"]
        [::core::mem::offset_of!(async_ops_v3, check_sequence_id) - 8usize];
};
const _: () = {
    ["Size of async_ops"][::core::mem::size_of::<async_ops>() - 112usize];
    ["Alignment of async_ops"][::core::mem::align_of::<async_ops>() - 8usize];
    ["Offset of field: async_ops::version"][::core::mem::offset_of!(async_ops, version) - 0usize];
    ["Offset of field: async_ops::reserved"][::core::mem::offset_of!(async_ops, reserved) - 4usize];
    ["Offset of field: async_ops::v1"][::core::mem::offset_of!(async_ops, v1) - 8usize];
    ["Offset of field: async_ops::v2"][::core::mem::offset_of!(async_ops, v2) - 64usize];
    ["Offset of field: async_ops::v3"][::core::mem::offset_of!(async_ops, v3) - 96usize];
};
pub type async_ops_t = async_ops;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_dispatcher {
    pub ops: *const async_ops_t,
}
const _: () = {
    ["Size of async_dispatcher"][::core::mem::size_of::<async_dispatcher>() - 8usize];
    ["Alignment of async_dispatcher"][::core::mem::align_of::<async_dispatcher>() - 8usize];
    ["Offset of field: async_dispatcher::ops"]
        [::core::mem::offset_of!(async_dispatcher, ops) - 0usize];
};
impl Default for async_dispatcher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type async_paged_vmo_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut async_dispatcher_t,
        paged_vmo: *mut async_paged_vmo_t,
        status: zx_status_t,
        request: *const zx_packet_page_request_t,
    ),
>;
#[repr(C)]
pub struct async_paged_vmo {
    pub state: async_state_t,
    pub handler: async_paged_vmo_handler_t,
    pub pager: zx_handle_t,
    pub vmo: zx_handle_t,
}
const _: () = {
    ["Size of async_paged_vmo"][::core::mem::size_of::<async_paged_vmo>() - 32usize];
    ["Alignment of async_paged_vmo"][::core::mem::align_of::<async_paged_vmo>() - 8usize];
    ["Offset of field: async_paged_vmo::state"]
        [::core::mem::offset_of!(async_paged_vmo, state) - 0usize];
    ["Offset of field: async_paged_vmo::handler"]
        [::core::mem::offset_of!(async_paged_vmo, handler) - 16usize];
    ["Offset of field: async_paged_vmo::pager"]
        [::core::mem::offset_of!(async_paged_vmo, pager) - 24usize];
    ["Offset of field: async_paged_vmo::vmo"]
        [::core::mem::offset_of!(async_paged_vmo, vmo) - 28usize];
};
impl Default for async_paged_vmo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for async_paged_vmo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "async_paged_vmo {{ state: {:?}, handler: {:?} }}", self.state, self.handler)
    }
}
extern "C" {
    pub fn async_create_paged_vmo(
        dispatcher: *mut async_dispatcher_t,
        paged_vmo: *mut async_paged_vmo_t,
        options: u32,
        pager: zx_handle_t,
        vmo_size: u64,
        vmo_out: *mut zx_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn async_detach_paged_vmo(
        dispatcher: *mut async_dispatcher_t,
        paged_vmo: *mut async_paged_vmo_t,
    ) -> zx_status_t;
}
pub type async_receiver_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut async_dispatcher_t,
        receiver: *mut async_receiver_t,
        status: zx_status_t,
        data: *const zx_packet_user_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_receiver {
    pub state: async_state_t,
    pub handler: async_receiver_handler_t,
}
const _: () = {
    ["Size of async_receiver"][::core::mem::size_of::<async_receiver>() - 24usize];
    ["Alignment of async_receiver"][::core::mem::align_of::<async_receiver>() - 8usize];
    ["Offset of field: async_receiver::state"]
        [::core::mem::offset_of!(async_receiver, state) - 0usize];
    ["Offset of field: async_receiver::handler"]
        [::core::mem::offset_of!(async_receiver, handler) - 16usize];
};
extern "C" {
    pub fn async_queue_packet(
        dispatcher: *mut async_dispatcher_t,
        receiver: *mut async_receiver_t,
        data: *const zx_packet_user_t,
    ) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_sequence_id {
    pub value: u64,
}
const _: () = {
    ["Size of async_sequence_id"][::core::mem::size_of::<async_sequence_id>() - 8usize];
    ["Alignment of async_sequence_id"][::core::mem::align_of::<async_sequence_id>() - 8usize];
    ["Offset of field: async_sequence_id::value"]
        [::core::mem::offset_of!(async_sequence_id, value) - 0usize];
};
extern "C" {
    pub fn async_get_sequence_id(
        dispatcher: *mut async_dispatcher_t,
        out_sequence_id: *mut async_sequence_id_t,
        out_error: *mut *const ::core::ffi::c_char,
    ) -> zx_status_t;
}
extern "C" {
    pub fn async_check_sequence_id(
        dispatcher: *mut async_dispatcher_t,
        sequence_id: async_sequence_id_t,
        out_error: *mut *const ::core::ffi::c_char,
    ) -> zx_status_t;
}
pub type async_task_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut async_dispatcher_t,
        task: *mut async_task_t,
        status: zx_status_t,
    ),
>;
#[repr(C)]
pub struct async_task {
    pub state: async_state_t,
    pub handler: async_task_handler_t,
    pub deadline: zx_time_t,
}
const _: () = {
    ["Size of async_task"][::core::mem::size_of::<async_task>() - 32usize];
    ["Alignment of async_task"][::core::mem::align_of::<async_task>() - 8usize];
    ["Offset of field: async_task::state"][::core::mem::offset_of!(async_task, state) - 0usize];
    ["Offset of field: async_task::handler"]
        [::core::mem::offset_of!(async_task, handler) - 16usize];
    ["Offset of field: async_task::deadline"]
        [::core::mem::offset_of!(async_task, deadline) - 24usize];
};
impl Default for async_task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for async_task {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "async_task {{ state: {:?}, handler: {:?} }}", self.state, self.handler)
    }
}
extern "C" {
    pub fn async_post_task(
        dispatcher: *mut async_dispatcher_t,
        task: *mut async_task_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn async_cancel_task(
        dispatcher: *mut async_dispatcher_t,
        task: *mut async_task_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn async_now(dispatcher: *mut async_dispatcher_t) -> zx_time_t;
}
pub type async_guest_bell_trap_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut async_dispatcher_t,
        trap: *mut async_guest_bell_trap_t,
        status: zx_status_t,
        bell: *const zx_packet_guest_bell_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct async_guest_bell_trap {
    pub state: async_state_t,
    pub handler: async_guest_bell_trap_handler_t,
}
const _: () = {
    ["Size of async_guest_bell_trap"][::core::mem::size_of::<async_guest_bell_trap>() - 24usize];
    ["Alignment of async_guest_bell_trap"]
        [::core::mem::align_of::<async_guest_bell_trap>() - 8usize];
    ["Offset of field: async_guest_bell_trap::state"]
        [::core::mem::offset_of!(async_guest_bell_trap, state) - 0usize];
    ["Offset of field: async_guest_bell_trap::handler"]
        [::core::mem::offset_of!(async_guest_bell_trap, handler) - 16usize];
};
extern "C" {
    pub fn async_set_guest_bell_trap(
        dispatcher: *mut async_dispatcher_t,
        trap: *mut async_guest_bell_trap_t,
        guest: zx_handle_t,
        addr: zx_vaddr_t,
        length: usize,
    ) -> zx_status_t;
}
pub type async_wait_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut async_dispatcher_t,
        wait: *mut async_wait_t,
        status: zx_status_t,
        signal: *const zx_packet_signal_t,
    ),
>;
#[repr(C)]
pub struct async_wait {
    pub state: async_state_t,
    pub handler: async_wait_handler_t,
    pub object: zx_handle_t,
    pub trigger: zx_signals_t,
    pub options: u32,
}
const _: () = {
    ["Size of async_wait"][::core::mem::size_of::<async_wait>() - 40usize];
    ["Alignment of async_wait"][::core::mem::align_of::<async_wait>() - 8usize];
    ["Offset of field: async_wait::state"][::core::mem::offset_of!(async_wait, state) - 0usize];
    ["Offset of field: async_wait::handler"]
        [::core::mem::offset_of!(async_wait, handler) - 16usize];
    ["Offset of field: async_wait::object"][::core::mem::offset_of!(async_wait, object) - 24usize];
    ["Offset of field: async_wait::trigger"]
        [::core::mem::offset_of!(async_wait, trigger) - 28usize];
    ["Offset of field: async_wait::options"]
        [::core::mem::offset_of!(async_wait, options) - 32usize];
};
impl Default for async_wait {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for async_wait {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "async_wait {{ state: {:?}, handler: {:?} }}", self.state, self.handler)
    }
}
extern "C" {
    pub fn async_begin_wait(
        dispatcher: *mut async_dispatcher_t,
        wait: *mut async_wait_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn async_cancel_wait(
        dispatcher: *mut async_dispatcher_t,
        wait: *mut async_wait_t,
    ) -> zx_status_t;
}
pub type fdf_handle_t = zx_handle_t;
pub type fdf_txid_t = zx_txid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdf_arena {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdf_channel_call_args {
    pub wr_arena: *mut fdf_arena,
    pub wr_data: *mut ::core::ffi::c_void,
    pub wr_num_bytes: u32,
    pub wr_handles: *mut zx_handle_t,
    pub wr_num_handles: u32,
    pub rd_arena: *mut *mut fdf_arena,
    pub rd_data: *mut *mut ::core::ffi::c_void,
    pub rd_num_bytes: *mut u32,
    pub rd_handles: *mut *mut zx_handle_t,
    pub rd_num_handles: *mut u32,
}
const _: () = {
    ["Size of fdf_channel_call_args"][::core::mem::size_of::<fdf_channel_call_args>() - 80usize];
    ["Alignment of fdf_channel_call_args"]
        [::core::mem::align_of::<fdf_channel_call_args>() - 8usize];
    ["Offset of field: fdf_channel_call_args::wr_arena"]
        [::core::mem::offset_of!(fdf_channel_call_args, wr_arena) - 0usize];
    ["Offset of field: fdf_channel_call_args::wr_data"]
        [::core::mem::offset_of!(fdf_channel_call_args, wr_data) - 8usize];
    ["Offset of field: fdf_channel_call_args::wr_num_bytes"]
        [::core::mem::offset_of!(fdf_channel_call_args, wr_num_bytes) - 16usize];
    ["Offset of field: fdf_channel_call_args::wr_handles"]
        [::core::mem::offset_of!(fdf_channel_call_args, wr_handles) - 24usize];
    ["Offset of field: fdf_channel_call_args::wr_num_handles"]
        [::core::mem::offset_of!(fdf_channel_call_args, wr_num_handles) - 32usize];
    ["Offset of field: fdf_channel_call_args::rd_arena"]
        [::core::mem::offset_of!(fdf_channel_call_args, rd_arena) - 40usize];
    ["Offset of field: fdf_channel_call_args::rd_data"]
        [::core::mem::offset_of!(fdf_channel_call_args, rd_data) - 48usize];
    ["Offset of field: fdf_channel_call_args::rd_num_bytes"]
        [::core::mem::offset_of!(fdf_channel_call_args, rd_num_bytes) - 56usize];
    ["Offset of field: fdf_channel_call_args::rd_handles"]
        [::core::mem::offset_of!(fdf_channel_call_args, rd_handles) - 64usize];
    ["Offset of field: fdf_channel_call_args::rd_num_handles"]
        [::core::mem::offset_of!(fdf_channel_call_args, rd_num_handles) - 72usize];
};
impl Default for fdf_channel_call_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fdf_channel_call_args_t = fdf_channel_call_args;
pub type fdf_arena_t = fdf_arena;
pub type fdf_arena_tag_t = u32;
extern "C" {
    pub fn fdf_arena_create(
        options: u32,
        tag: fdf_arena_tag_t,
        out_arena: *mut *mut fdf_arena_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_arena_allocate(arena: *mut fdf_arena_t, bytes: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn fdf_arena_free(arena: *mut fdf_arena_t, ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn fdf_arena_contains(
        arena: *mut fdf_arena_t,
        ptr: *const ::core::ffi::c_void,
        num_bytes: usize,
    ) -> bool;
}
extern "C" {
    pub fn fdf_arena_drop_ref(arena: *mut fdf_arena_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdf_dispatcher {
    _unused: [u8; 0],
}
pub type fdf_dispatcher_t = fdf_dispatcher;
pub type fdf_dispatcher_shutdown_observer_t = fdf_dispatcher_shutdown_observer;
pub type fdf_dispatcher_shutdown_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut fdf_dispatcher_t,
        observer: *mut fdf_dispatcher_shutdown_observer_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdf_dispatcher_shutdown_observer {
    pub handler: fdf_dispatcher_shutdown_handler_t,
}
const _: () = {
    ["Size of fdf_dispatcher_shutdown_observer"]
        [::core::mem::size_of::<fdf_dispatcher_shutdown_observer>() - 8usize];
    ["Alignment of fdf_dispatcher_shutdown_observer"]
        [::core::mem::align_of::<fdf_dispatcher_shutdown_observer>() - 8usize];
    ["Offset of field: fdf_dispatcher_shutdown_observer::handler"]
        [::core::mem::offset_of!(fdf_dispatcher_shutdown_observer, handler) - 0usize];
};
extern "C" {
    pub fn fdf_dispatcher_create(
        options: u32,
        name: *const ::core::ffi::c_char,
        name_len: usize,
        scheduler_role: *const ::core::ffi::c_char,
        scheduler_role_len: usize,
        observer: *mut fdf_dispatcher_shutdown_observer_t,
        out_dispatcher: *mut *mut fdf_dispatcher_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_dispatcher_get_async_dispatcher(
        dispatcher: *mut fdf_dispatcher_t,
    ) -> *mut async_dispatcher_t;
}
extern "C" {
    pub fn fdf_dispatcher_downcast_async_dispatcher(
        async_dispatcher: *mut async_dispatcher_t,
    ) -> *mut fdf_dispatcher_t;
}
extern "C" {
    pub fn fdf_dispatcher_get_current_dispatcher() -> *mut fdf_dispatcher_t;
}
extern "C" {
    pub fn fdf_dispatcher_get_options(dispatcher: *const fdf_dispatcher_t) -> u32;
}
extern "C" {
    pub fn fdf_dispatcher_shutdown_async(dispatcher: *mut fdf_dispatcher_t);
}
extern "C" {
    pub fn fdf_dispatcher_destroy(dispatcher: *mut fdf_dispatcher_t);
}
extern "C" {
    pub fn fdf_dispatcher_seal(dispatcher: *mut fdf_dispatcher_t, option: u32) -> zx_status_t;
}
extern "C" {
    pub fn fdf_handle_close(handle: fdf_handle_t);
}
extern "C" {
    pub fn fdf_channel_create(
        options: u32,
        out0: *mut fdf_handle_t,
        out1: *mut fdf_handle_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_channel_write(
        channel: fdf_handle_t,
        options: u32,
        arena: *mut fdf_arena_t,
        data: *mut ::core::ffi::c_void,
        num_bytes: u32,
        handles: *mut zx_handle_t,
        num_handles: u32,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_channel_read(
        channel: fdf_handle_t,
        options: u32,
        out_arena: *mut *mut fdf_arena_t,
        out_data: *mut *mut ::core::ffi::c_void,
        out_num_bytes: *mut u32,
        out_handles: *mut *mut zx_handle_t,
        out_num_handles: *mut u32,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_channel_wait_async(
        dispatcher: *mut fdf_dispatcher,
        channel_read: *mut fdf_channel_read,
        options: u32,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_channel_cancel_wait(handle: fdf_handle_t) -> zx_status_t;
}
extern "C" {
    pub fn fdf_channel_call(
        handle: fdf_handle_t,
        options: u32,
        deadline: zx_time_t,
        args: *const fdf_channel_call_args_t,
    ) -> zx_status_t;
}
pub type fdf_channel_read_t = fdf_channel_read;
pub type fdf_channel_read_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut fdf_dispatcher_t,
        read: *mut fdf_channel_read_t,
        status: zx_status_t,
    ),
>;
#[repr(C)]
pub struct fdf_channel_read {
    pub state: async_state_t,
    pub handler: fdf_channel_read_handler_t,
    pub channel: fdf_handle_t,
    pub options: u32,
}
const _: () = {
    ["Size of fdf_channel_read"][::core::mem::size_of::<fdf_channel_read>() - 32usize];
    ["Alignment of fdf_channel_read"][::core::mem::align_of::<fdf_channel_read>() - 8usize];
    ["Offset of field: fdf_channel_read::state"]
        [::core::mem::offset_of!(fdf_channel_read, state) - 0usize];
    ["Offset of field: fdf_channel_read::handler"]
        [::core::mem::offset_of!(fdf_channel_read, handler) - 16usize];
    ["Offset of field: fdf_channel_read::channel"]
        [::core::mem::offset_of!(fdf_channel_read, channel) - 24usize];
    ["Offset of field: fdf_channel_read::options"]
        [::core::mem::offset_of!(fdf_channel_read, options) - 28usize];
};
impl Default for fdf_channel_read {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for fdf_channel_read {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "fdf_channel_read {{ state: {:?}, handler: {:?} }}", self.state, self.handler)
    }
}
pub type fdf_env_driver_shutdown_observer_t = fdf_env_driver_shutdown_observer;
pub type fdf_env_driver_shutdown_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        driver: *const ::core::ffi::c_void,
        observer: *mut fdf_env_driver_shutdown_observer_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdf_env_driver_shutdown_observer {
    pub handler: fdf_env_driver_shutdown_handler_t,
}
const _: () = {
    ["Size of fdf_env_driver_shutdown_observer"]
        [::core::mem::size_of::<fdf_env_driver_shutdown_observer>() - 8usize];
    ["Alignment of fdf_env_driver_shutdown_observer"]
        [::core::mem::align_of::<fdf_env_driver_shutdown_observer>() - 8usize];
    ["Offset of field: fdf_env_driver_shutdown_observer::handler"]
        [::core::mem::offset_of!(fdf_env_driver_shutdown_observer, handler) - 0usize];
};
extern "C" {
    pub fn fdf_env_start() -> zx_status_t;
}
extern "C" {
    pub fn fdf_env_reset();
}
extern "C" {
    pub fn fdf_env_dispatcher_create_with_owner(
        driver: *const ::core::ffi::c_void,
        options: u32,
        name: *const ::core::ffi::c_char,
        name_len: usize,
        scheduler_role: *const ::core::ffi::c_char,
        scheduler_role_len: usize,
        observer: *mut fdf_dispatcher_shutdown_observer_t,
        out_dispatcher: *mut *mut fdf_dispatcher_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_env_dispatcher_dump(dispatcher: *mut fdf_dispatcher_t);
}
extern "C" {
    pub fn fdf_env_dispatcher_get_dump_deprecated(
        dispatcher: *mut fdf_dispatcher_t,
        out_dump: *mut *mut ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn fdf_env_shutdown_dispatchers_async(
        driver: *const ::core::ffi::c_void,
        observer: *mut fdf_env_driver_shutdown_observer_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_env_destroy_all_dispatchers();
}
extern "C" {
    pub fn fdf_env_register_driver_entry(driver: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn fdf_env_register_driver_exit();
}
extern "C" {
    pub fn fdf_env_get_current_driver() -> *const ::core::ffi::c_void;
}
extern "C" {
    pub fn fdf_env_dispatcher_has_queued_tasks(dispatcher: *mut fdf_dispatcher_t) -> bool;
}
extern "C" {
    pub fn fdf_env_get_thread_limit(
        scheduler_role: *const ::core::ffi::c_char,
        scheduler_role_len: usize,
    ) -> u32;
}
extern "C" {
    pub fn fdf_env_set_thread_limit(
        scheduler_role: *const ::core::ffi::c_char,
        scheduler_role_len: usize,
        max_threads: u32,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_testing_create_unmanaged_dispatcher(
        driver: *const ::core::ffi::c_void,
        options: u32,
        name: *const ::core::ffi::c_char,
        name_len: usize,
        observer: *mut fdf_dispatcher_shutdown_observer_t,
        out_dispatcher: *mut *mut fdf_dispatcher_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_testing_set_default_dispatcher(dispatcher: *mut fdf_dispatcher_t) -> zx_status_t;
}
extern "C" {
    pub fn fdf_testing_run(deadline: zx_time_t, once: bool) -> zx_status_t;
}
extern "C" {
    pub fn fdf_testing_run_until_idle() -> zx_status_t;
}
extern "C" {
    pub fn fdf_testing_quit();
}
extern "C" {
    pub fn fdf_testing_reset_quit() -> zx_status_t;
}
pub type fdf_token_t = fdf_token;
pub type fdf_token_transfer_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        dispatcher: *mut fdf_dispatcher_t,
        token: *mut fdf_token_t,
        status: zx_status_t,
        handle: fdf_handle_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fdf_token {
    pub handler: fdf_token_transfer_handler_t,
}
const _: () = {
    ["Size of fdf_token"][::core::mem::size_of::<fdf_token>() - 8usize];
    ["Alignment of fdf_token"][::core::mem::align_of::<fdf_token>() - 8usize];
    ["Offset of field: fdf_token::handler"][::core::mem::offset_of!(fdf_token, handler) - 0usize];
};
extern "C" {
    pub fn fdf_token_register(
        token: zx_handle_t,
        dispatcher: *mut fdf_dispatcher_t,
        handler: *mut fdf_token_t,
    ) -> zx_status_t;
}
extern "C" {
    pub fn fdf_token_transfer(token: zx_handle_t, handle: fdf_handle_t) -> zx_status_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DriverRegistration {
    pub version: u64,
    pub v1: DriverRegistration_driver_registration_v1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DriverRegistration_driver_registration_v1 {
    pub initialize: ::core::option::Option<
        unsafe extern "C" fn(server_handle: fdf_handle_t) -> *mut ::core::ffi::c_void,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(token: *mut ::core::ffi::c_void)>,
}
const _: () = {
    ["Size of DriverRegistration_driver_registration_v1"]
        [::core::mem::size_of::<DriverRegistration_driver_registration_v1>() - 16usize];
    ["Alignment of DriverRegistration_driver_registration_v1"]
        [::core::mem::align_of::<DriverRegistration_driver_registration_v1>() - 8usize];
    ["Offset of field: DriverRegistration_driver_registration_v1::initialize"]
        [::core::mem::offset_of!(DriverRegistration_driver_registration_v1, initialize) - 0usize];
    ["Offset of field: DriverRegistration_driver_registration_v1::destroy"]
        [::core::mem::offset_of!(DriverRegistration_driver_registration_v1, destroy) - 8usize];
};
const _: () = {
    ["Size of DriverRegistration"][::core::mem::size_of::<DriverRegistration>() - 24usize];
    ["Alignment of DriverRegistration"][::core::mem::align_of::<DriverRegistration>() - 8usize];
    ["Offset of field: DriverRegistration::version"]
        [::core::mem::offset_of!(DriverRegistration, version) - 0usize];
    ["Offset of field: DriverRegistration::v1"]
        [::core::mem::offset_of!(DriverRegistration, v1) - 8usize];
};
