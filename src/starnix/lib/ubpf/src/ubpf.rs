/* automatically generated by rust-bindgen 0.69.1 */

// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(non_camel_case_types)]
#![allow(dead_code)]
#![allow(non_upper_case_globals)]

pub const EBPF_CLS_MASK: u32 = 7;
pub const EBPF_ALU_OP_MASK: u32 = 240;
pub const EBPF_JMP_OP_MASK: u32 = 240;
pub const EBPF_CLS_LD: u32 = 0;
pub const EBPF_CLS_LDX: u32 = 1;
pub const EBPF_CLS_ST: u32 = 2;
pub const EBPF_CLS_STX: u32 = 3;
pub const EBPF_CLS_ALU: u32 = 4;
pub const EBPF_CLS_JMP: u32 = 5;
pub const EBPF_CLS_JMP32: u32 = 6;
pub const EBPF_CLS_ALU64: u32 = 7;
pub const EBPF_SRC_IMM: u32 = 0;
pub const EBPF_SRC_REG: u32 = 8;
pub const EBPF_SIZE_W: u32 = 0;
pub const EBPF_SIZE_H: u32 = 8;
pub const EBPF_SIZE_B: u32 = 16;
pub const EBPF_SIZE_DW: u32 = 24;
pub const EBPF_MODE_IMM: u32 = 0;
pub const EBPF_MODE_MEM: u32 = 96;
pub const EBPF_OP_ADD_IMM: u32 = 4;
pub const EBPF_OP_ADD_REG: u32 = 12;
pub const EBPF_OP_SUB_IMM: u32 = 20;
pub const EBPF_OP_SUB_REG: u32 = 28;
pub const EBPF_OP_MUL_IMM: u32 = 36;
pub const EBPF_OP_MUL_REG: u32 = 44;
pub const EBPF_OP_DIV_IMM: u32 = 52;
pub const EBPF_OP_DIV_REG: u32 = 60;
pub const EBPF_OP_OR_IMM: u32 = 68;
pub const EBPF_OP_OR_REG: u32 = 76;
pub const EBPF_OP_AND_IMM: u32 = 84;
pub const EBPF_OP_AND_REG: u32 = 92;
pub const EBPF_OP_LSH_IMM: u32 = 100;
pub const EBPF_OP_LSH_REG: u32 = 108;
pub const EBPF_OP_RSH_IMM: u32 = 116;
pub const EBPF_OP_RSH_REG: u32 = 124;
pub const EBPF_OP_NEG: u32 = 132;
pub const EBPF_OP_MOD_IMM: u32 = 148;
pub const EBPF_OP_MOD_REG: u32 = 156;
pub const EBPF_OP_XOR_IMM: u32 = 164;
pub const EBPF_OP_XOR_REG: u32 = 172;
pub const EBPF_OP_MOV_IMM: u32 = 180;
pub const EBPF_OP_MOV_REG: u32 = 188;
pub const EBPF_OP_ARSH_IMM: u32 = 196;
pub const EBPF_OP_ARSH_REG: u32 = 204;
pub const EBPF_OP_LE: u32 = 212;
pub const EBPF_OP_BE: u32 = 220;
pub const EBPF_OP_ADD64_IMM: u32 = 7;
pub const EBPF_OP_ADD64_REG: u32 = 15;
pub const EBPF_OP_SUB64_IMM: u32 = 23;
pub const EBPF_OP_SUB64_REG: u32 = 31;
pub const EBPF_OP_MUL64_IMM: u32 = 39;
pub const EBPF_OP_MUL64_REG: u32 = 47;
pub const EBPF_OP_DIV64_IMM: u32 = 55;
pub const EBPF_OP_DIV64_REG: u32 = 63;
pub const EBPF_OP_OR64_IMM: u32 = 71;
pub const EBPF_OP_OR64_REG: u32 = 79;
pub const EBPF_OP_AND64_IMM: u32 = 87;
pub const EBPF_OP_AND64_REG: u32 = 95;
pub const EBPF_OP_LSH64_IMM: u32 = 103;
pub const EBPF_OP_LSH64_REG: u32 = 111;
pub const EBPF_OP_RSH64_IMM: u32 = 119;
pub const EBPF_OP_RSH64_REG: u32 = 127;
pub const EBPF_OP_NEG64: u32 = 135;
pub const EBPF_OP_MOD64_IMM: u32 = 151;
pub const EBPF_OP_MOD64_REG: u32 = 159;
pub const EBPF_OP_XOR64_IMM: u32 = 167;
pub const EBPF_OP_XOR64_REG: u32 = 175;
pub const EBPF_OP_MOV64_IMM: u32 = 183;
pub const EBPF_OP_MOV64_REG: u32 = 191;
pub const EBPF_OP_ARSH64_IMM: u32 = 199;
pub const EBPF_OP_ARSH64_REG: u32 = 207;
pub const EBPF_OP_LDXW: u32 = 97;
pub const EBPF_OP_LDXH: u32 = 105;
pub const EBPF_OP_LDXB: u32 = 113;
pub const EBPF_OP_LDXDW: u32 = 121;
pub const EBPF_OP_STW: u32 = 98;
pub const EBPF_OP_STH: u32 = 106;
pub const EBPF_OP_STB: u32 = 114;
pub const EBPF_OP_STDW: u32 = 122;
pub const EBPF_OP_STXW: u32 = 99;
pub const EBPF_OP_STXH: u32 = 107;
pub const EBPF_OP_STXB: u32 = 115;
pub const EBPF_OP_STXDW: u32 = 123;
pub const EBPF_OP_LDDW: u32 = 24;
pub const EBPF_MODE_JA: u32 = 0;
pub const EBPF_MODE_JEQ: u32 = 16;
pub const EBPF_MODE_JGT: u32 = 32;
pub const EBPF_MODE_JGE: u32 = 48;
pub const EBPF_MODE_JSET: u32 = 64;
pub const EBPF_MODE_JNE: u32 = 80;
pub const EBPF_MODE_JSGT: u32 = 96;
pub const EBPF_MODE_JSGE: u32 = 112;
pub const EBPF_MODE_CALL: u32 = 128;
pub const EBPF_MODE_EXIT: u32 = 144;
pub const EBPF_MODE_JLT: u32 = 160;
pub const EBPF_MODE_JLE: u32 = 176;
pub const EBPF_MODE_JSLT: u32 = 192;
pub const EBPF_MODE_JSLE: u32 = 208;
pub const EBPF_OP_JA: u32 = 5;
pub const EBPF_OP_JEQ_IMM: u32 = 21;
pub const EBPF_OP_JEQ_REG: u32 = 29;
pub const EBPF_OP_JGT_IMM: u32 = 37;
pub const EBPF_OP_JGT_REG: u32 = 45;
pub const EBPF_OP_JGE_IMM: u32 = 53;
pub const EBPF_OP_JGE_REG: u32 = 61;
pub const EBPF_OP_JSET_REG: u32 = 77;
pub const EBPF_OP_JSET_IMM: u32 = 69;
pub const EBPF_OP_JNE_IMM: u32 = 85;
pub const EBPF_OP_JNE_REG: u32 = 93;
pub const EBPF_OP_JSGT_IMM: u32 = 101;
pub const EBPF_OP_JSGT_REG: u32 = 109;
pub const EBPF_OP_JSGE_IMM: u32 = 117;
pub const EBPF_OP_JSGE_REG: u32 = 125;
pub const EBPF_OP_CALL: u32 = 133;
pub const EBPF_OP_EXIT: u32 = 149;
pub const EBPF_OP_JLT_IMM: u32 = 165;
pub const EBPF_OP_JLT_REG: u32 = 173;
pub const EBPF_OP_JLE_IMM: u32 = 181;
pub const EBPF_OP_JLE_REG: u32 = 189;
pub const EBPF_OP_JSLT_IMM: u32 = 197;
pub const EBPF_OP_JSLT_REG: u32 = 205;
pub const EBPF_OP_JSLE_IMM: u32 = 213;
pub const EBPF_OP_JSLE_REG: u32 = 221;
pub const EBPF_OP_JEQ32_IMM: u32 = 22;
pub const EBPF_OP_JEQ32_REG: u32 = 30;
pub const EBPF_OP_JGT32_IMM: u32 = 38;
pub const EBPF_OP_JGT32_REG: u32 = 46;
pub const EBPF_OP_JGE32_IMM: u32 = 54;
pub const EBPF_OP_JGE32_REG: u32 = 62;
pub const EBPF_OP_JSET32_REG: u32 = 78;
pub const EBPF_OP_JSET32_IMM: u32 = 70;
pub const EBPF_OP_JNE32_IMM: u32 = 86;
pub const EBPF_OP_JNE32_REG: u32 = 94;
pub const EBPF_OP_JSGT32_IMM: u32 = 102;
pub const EBPF_OP_JSGT32_REG: u32 = 110;
pub const EBPF_OP_JSGE32_IMM: u32 = 118;
pub const EBPF_OP_JSGE32_REG: u32 = 126;
pub const EBPF_OP_JLT32_IMM: u32 = 166;
pub const EBPF_OP_JLT32_REG: u32 = 174;
pub const EBPF_OP_JLE32_IMM: u32 = 182;
pub const EBPF_OP_JLE32_REG: u32 = 190;
pub const EBPF_OP_JSLT32_IMM: u32 = 198;
pub const EBPF_OP_JSLT32_REG: u32 = 206;
pub const EBPF_OP_JSLE32_IMM: u32 = 214;
pub const EBPF_OP_JSLE32_REG: u32 = 222;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    _unused: [u8; 0],
}
pub type FILE = __sFILE;
#[doc = " @brief Opaque type for a the uBPF VM."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ubpf_vm {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type for a uBPF JIT compiled function."]
pub type ubpf_jit_fn = ::std::option::Option<
    unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void, mem_len: usize) -> u64,
>;
extern "C" {
    #[doc = " @brief Create a new uBPF VM.\n\n @return A pointer to the new VM, or NULL on failure."]
    pub fn ubpf_create() -> *mut ubpf_vm;
}
extern "C" {
    #[doc = " @brief Free a uBPF VM.\n\n @param[in] vm The VM to free."]
    pub fn ubpf_destroy(vm: *mut ubpf_vm);
}
extern "C" {
    #[doc = " @brief Enable / disable bounds_check. Bounds check is enabled by default, but it may be too restrictive.\n\n @param[in] vm The VM to enable / disable bounds check on.\n @param[in] enable Enable bounds check if true, disable if false.\n @retval true Bounds check was previously enabled."]
    pub fn ubpf_toggle_bounds_check(vm: *mut ubpf_vm, enable: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Set the function to be invoked if the program hits a fatal error.\n\n @param[in] vm The VM to set the error function on.\n @param[in] error_printf The function to be invoked on fatal error."]
    pub fn ubpf_set_error_print(
        vm: *mut ubpf_vm,
        error_printf: ::std::option::Option<
            unsafe extern "C" fn(
                stream: *mut FILE,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " @brief Register an external function.\n The immediate field of a CALL instruction is an index into an array of\n functions registered by the user. This API associates a function with\n an index.\n\n @param[in] vm The VM to register the function on.\n @param[in] index The index to register the function at.\n @param[in] name The human readable name of the function.\n @param[in] fn The function to register.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_register(
        vm: *mut ubpf_vm,
        index: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        fn_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Load code into a VM.\n This must be done before calling ubpf_exec or ubpf_compile and after\n registering all functions.\n\n 'code' should point to eBPF bytecodes and 'code_len' should be the size in\n bytes of that buffer.\n\n @param[in] vm The VM to load the code into.\n @param[in] code The eBPF bytecodes to load.\n @param[in] code_len The length of the eBPF bytecodes.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_load(
        vm: *mut ubpf_vm,
        code: *const ::std::os::raw::c_void,
        code_len: u32,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unload code from a VM.\n\n The VM must be reloaded with code before calling ubpf_exec or ubpf_compile.\n\n @param[in] vm The VM to unload the code from."]
    pub fn ubpf_unload_code(vm: *mut ubpf_vm);
}
extern "C" {
    #[doc = " @brief Load code from an ELF file.\n\n This must be done before calling ubpf_exec or ubpf_compile and after\n registering all functions.\n\n 'elf' should point to a copy of an ELF file in memory and 'elf_len' should\n be the size in bytes of that buffer.\n\n The ELF file must be 64-bit little-endian with a single text section\n containing the eBPF bytecodes. This is compatible with the output of\n Clang.\n\n @param[in] vm The VM to load the code into.\n @param[in] elf A pointer to a copy of an ELF file in memory.\n @param[in] elf_len The size of the ELF file.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_load_elf(
        vm: *mut ubpf_vm,
        elf: *const ::std::os::raw::c_void,
        elf_len: usize,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Execute a BPF program in the VM using the interpreter.\n\n A program must be loaded into the VM and all external functions must be\n registered before calling this function.\n\n @param[in] vm The VM to execute the program in.\n @param[in] mem The memory to pass to the program.\n @param[in] mem_len The length of the memory.\n @param[in] bpf_return_value The value of the r0 register when the program exits.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_exec(
        vm: *const ubpf_vm,
        mem: *mut ::std::os::raw::c_void,
        mem_len: usize,
        bpf_return_value: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compile a BPF program in the VM to native code.\n\n A program must be loaded into the VM and all external functions must be\n registered before calling this function.\n\n @param[in] vm The VM to compile the program in.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @return ubpf_jit_fn A pointer to the compiled program, or NULL on failure."]
    pub fn ubpf_compile(vm: *mut ubpf_vm, errmsg: *mut *mut ::std::os::raw::c_char) -> ubpf_jit_fn;
}
extern "C" {
    #[doc = " @brief Translate the eBPF byte code to x64 machine code.\n\n A program must be loaded into the VM and all external functions must be\n registered before calling this function.\n\n @param[in] vm The VM to translate the program in.\n @param[out] buffer The buffer to store the translated code in.\n @param[in] size The size of the buffer.\n @param[out] errmsg The error message, if any. This should be freed by the caller.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_translate(
        vm: *mut ubpf_vm,
        buffer: *mut u8,
        size: *mut usize,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instruct the uBPF runtime to apply unwind-on-success semantics to a helper function.\n If the function returns 0, the uBPF runtime will end execution of\n the eBPF program and immediately return control to the caller. This is used\n for implementing function like the \"bpf_tail_call\" helper.\n\n @param[in] vm The VM to set the unwind helper in.\n @param[in] idx Index of the helper function to unwind on success.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_set_unwind_function_index(
        vm: *mut ubpf_vm,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Override the storage location for the BPF registers in the VM.\n\n @param[in] vm The VM to set the register storage in.\n @param[in] regs The register storage."]
    pub fn ubpf_set_registers(vm: *mut ubpf_vm, regs: *mut u64);
}
extern "C" {
    #[doc = " @brief Retrieve the storage location for the BPF registers in the VM.\n\n @param[in] vm The VM to get the register storage from.\n @return uint64_t* A pointer to the register storage."]
    pub fn ubpf_get_registers(vm: *const ubpf_vm) -> *mut u64;
}
extern "C" {
    #[doc = " @brief Optional secret to improve ROP protection.\n\n @param[in] vm The VM to set the secret for.\n @param[in] secret Optional secret to improve ROP protection.\n Returns 0 on success, -1 on error (e.g. if the secret is set after\n the instructions are loaded)."]
    pub fn ubpf_set_pointer_secret(vm: *mut ubpf_vm, secret: u64) -> ::std::os::raw::c_int;
}
#[doc = " @brief Data relocation function that is called by the VM when it encounters a\n R_BPF_64_64 relocation in the maps section of the ELF file.\n\n @param[in] user_context The user context that was passed to ubpf_register_data_relocation.\n @param[in] data Pointer to start of the map section.\n @param[in] data_size Size of the map section.\n @param[in] symbol_name Name of the symbol that is referenced.\n @param[in] symbol_offset Offset of the symbol relative to the start of the map section.\n @param[in] symbol_size Size of the symbol.\n @return uint64_t The value to insert into the BPF program."]
pub type ubpf_data_relocation = ::std::option::Option<
    unsafe extern "C" fn(
        user_context: *mut ::std::os::raw::c_void,
        data: *const u8,
        data_size: u64,
        symbol_name: *const ::std::os::raw::c_char,
        symbol_offset: u64,
        symbol_size: u64,
    ) -> u64,
>;
extern "C" {
    #[doc = " @brief Set a relocation function for the VM.\n\n @param[in] vm The VM to set the relocation function for.\n @param[in] relocation The relocation function.\n @return int The value to insert into the BPF program."]
    pub fn ubpf_register_data_relocation(
        vm: *mut ubpf_vm,
        user_context: *mut ::std::os::raw::c_void,
        relocation: ubpf_data_relocation,
    ) -> ::std::os::raw::c_int;
}
pub type ubpf_bounds_check = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, addr: u64, size: u64) -> bool,
>;
extern "C" {
    #[doc = " @brief Set a bounds check function for the VM.\n\n @param[in] vm The VM to set the bounds check function for.\n @param[in] user_context The user context to pass to the bounds check function.\n @param[in] bounds_check The bounds check function.\n @retval 0 Success.\n @retval -1 Failure."]
    pub fn ubpf_register_data_bounds_check(
        vm: *mut ubpf_vm,
        user_context: *mut ::std::os::raw::c_void,
        bounds_check: ubpf_bounds_check,
    ) -> ::std::os::raw::c_int;
}
