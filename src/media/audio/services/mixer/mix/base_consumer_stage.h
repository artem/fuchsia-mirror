// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_MEDIA_AUDIO_SERVICES_MIXER_MIX_BASE_CONSUMER_STAGE_H_
#define SRC_MEDIA_AUDIO_SERVICES_MIXER_MIX_BASE_CONSUMER_STAGE_H_

#include <lib/zx/time.h>

#include <memory>
#include <string>

#include "src/media/audio/lib/format2/fixed.h"
#include "src/media/audio/lib/format2/format.h"
#include "src/media/audio/services/mixer/mix/mix_job_context.h"
#include "src/media/audio/services/mixer/mix/packet_view.h"
#include "src/media/audio/services/mixer/mix/pipeline_stage.h"
#include "src/media/audio/services/mixer/mix/ptr_decls.h"

namespace media_audio {

// Base class for consumers. A consumer has one source stream and zero destination streams. All data
// "consumed" from the source stream is written to an object that implements the
// `BaseConsumerStage::Writer` interface. Data is "consumed" in whole frame units, hence this class
// represents frame units with int64_t instead of Fixed.
class BaseConsumerStage : public PipelineStage {
 public:
  // This interface is used to write all packets generated by this consumer. Packets are written in
  // increasing order by start frame. Underflows will lead to gaps between packets. When the
  // consumer is stopped, it calls `End()` after writing the final packet. If the consumer is
  // started again, it starts writing more packets (there is no explicit "start" signal). This
  // interface is implemented by various kinds of audio sinks, such as packet queues and ring
  // buffers.
  //
  // Consumers always write data on integral boundaries. Hence these functions use `int64_t` frames
  // instead of `Fixed` frames to avoid ambiguity and unnecessary `Floor()` operations.
  //
  // TODO(https://fxbug.dev/42066188): Further clarify the semantics: is start_frame allowed to go backwards?
  class Writer {
   public:
    virtual ~Writer() = default;
    virtual void WriteData(int64_t start_frame, int64_t length, const void* data) = 0;
    virtual void WriteSilence(int64_t start_frame, int64_t length) = 0;
    virtual void End() = 0;
  };

  struct Args {
    // Name of this stage.
    std::string_view name;

    // Format of audio written to `writer`.
    Format format;

    // Reference clock used by this consumer.
    UnreadableClock reference_clock;

    // Which thread the consumer is assigned to.
    PipelineThreadPtr thread;

    // How to write all consumed packets.
    std::shared_ptr<Writer> writer;
  };

  explicit BaseConsumerStage(Args args);

  // Implements `PipelineStage`.
  void AddSource(PipelineStagePtr source, AddSourceOptions options) final;
  void RemoveSource(PipelineStagePtr source) final;
  void UpdatePresentationTimeToFracFrame(std::optional<TimelineFunction> f) override;

  // Copies `[start_frame, start_frame + frame_count)` from our source to `writer`.
  void CopyFromSource(MixJobContext& ctx, int64_t start_frame, int64_t length);

 protected:
  // Implements `PipelineStage`.
  void AdvanceSelfImpl(Fixed frame) final {
    UNREACHABLE << "Consumers cannot be advanced: there is no destination stream";
  }
  void AdvanceSourcesImpl(MixJobContext& ctx, Fixed frame) final {
    UNREACHABLE << "Consumers cannot be advanced: there is no destination stream";
  }
  std::optional<Packet> ReadImpl(MixJobContext& ctx, Fixed start_frame, int64_t frame_count) final {
    UNREACHABLE << "Consumers cannot be read: there is no destination stream";
  }

  PipelineStagePtr source() const { return source_; }

 private:
  const std::shared_ptr<Writer> writer_;
  PipelineStagePtr source_;
};

}  // namespace media_audio

#endif  // SRC_MEDIA_AUDIO_SERVICES_MIXER_MIX_BASE_CONSUMER_STAGE_H_
