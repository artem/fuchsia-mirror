// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Draft Prototype of Protocols to be used by Power Broker.
// None of these protocols should be considered fully baked at this time
// and should be expected to change in the future as we gain information
// through this prototype testbed about coverage and usability.
@available(added=HEAD)
library fuchsia.power.broker;

using zx;

/// Used to describe the power level of an element.
/// Could extend this further to support additional types of power
/// levels, such as ACPI.
type PowerLevel = strict union {
    1: binary BinaryPowerLevel;
    2: user_defined UserDefinedPowerLevel;
};

type BinaryPowerLevel = strict enum : uint32 {
    OFF = 0;
    ON = 1;
};

type UserDefinedPowerLevel = struct {
    level uint8;
};

// Unique ID provided by Power Broker (currently a UUID but subject to change).
alias LeaseId = string:64;

type WatchRequiredLevelError = flexible enum {
    INTERNAL = 1;
    NOT_AUTHORIZED = 2;
};

type UpdateCurrentPowerLevelError = flexible enum {
    NOT_AUTHORIZED = 1;
};

/// Offered by the Power Broker to managed Power Element owners to receive
/// current power level status and initiate power level changes.
open protocol LevelControl {
    /// Request made by element owners on behalf of a single power element to
    /// the Power Broker as a hanging GET:
    /// If last_required_level does not match the current required power level
    /// this will return immediately with the new required power level.
    /// If last_required_level matches the current level, the call will
    /// hang until the required level changes.
    flexible WatchRequiredLevel(resource struct {
        /// Provided by the client with the last level received, or None if
        /// this is the first call.
        last_required_level PowerLevel:optional;
    }) -> (resource struct {
        required_level PowerLevel;
    }) error WatchRequiredLevelError;

    /// Sent by the element on initial startup and whenever there is a change
    /// in power level.
    flexible UpdateCurrentPowerLevel(resource struct {
        current_level PowerLevel;
    }) -> () error UpdateCurrentPowerLevelError;
};

type LeaseError = flexible enum {
    INTERNAL = 1;
    NOT_AUTHORIZED = 2;
};

/// Offered by the Power Broker to consumer Power Element owners (elements
/// that initiate leases).
@discoverable
open protocol Lessor {
    /// Request made to indicate client intends to raise the given element
    /// to the given power level and wants to have its direct and transitive
    /// power dependencies satisfied.
    flexible Lease(resource struct {
        /// Must supply a token to a previously registered Credential for
        /// the element with Permissions.ACQUIRE_LEASE.
        token zx.Handle:EVENTPAIR;
        /// Power level of this element to be raised to.
        level PowerLevel;
    }) -> (resource struct {
        /// Channel for actions to be taken on the lease.
        /// When this channel is closed, the lease will be dropped.
        lease_control client_end:LeaseControl;
    }) error LeaseError;
};

type LeaseStatus = flexible enum {
    UNKNOWN = 0;
    PENDING = 1;
    SATISFIED = 2;
};

/// Actions that can be taken on a previously acquired lease.
open protocol LeaseControl {
    /// Get the current status of the lease.
    /// If last_status is UNKNOWN, the call will return immediately
    /// with the current status. Otherwise, the call will block
    /// until the current status differs from last_status.
    flexible WatchStatus(struct {
        last_status LeaseStatus;
    }) -> (struct {
        status LeaseStatus;
    });
};

type AddElementError = flexible enum {
    INTERNAL = 1;
    INVALID = 2;
    NOT_AUTHORIZED = 3;
};

type AddDependencyError = flexible enum {
    ALREADY_EXISTS = 1;
    ELEMENT_NOT_FOUND = 2;
    NOT_AUTHORIZED = 3;
    REQUIRED_ELEMENT_NOT_FOUND = 4;
};

type RemoveDependencyError = flexible enum {
    NOT_AUTHORIZED = 1;
    NOT_FOUND = 2;
};

type RegisterCredentialsError = flexible enum {
    INTERNAL = 1;
    NOT_AUTHORIZED = 2;
};

type UnregisterCredentialsError = flexible enum {
    NOT_AUTHORIZED = 1;
};

type ElementLevel = resource struct {
    /// A token to a Credential previously registered on the element
    /// with the relevant Permissions for the action requested.
    token zx.Handle:EVENTPAIR;
    level PowerLevel;
};

/// Power dependency from one element's PowerLevel to another.
/// The Element and PowerLevel specified by `dependent` depends on
/// the Element and PowerLevel specified by `requires`.
type Dependency = resource struct {
    dependent ElementLevel;
    requires ElementLevel;
};

/// Power dependency from an already specified element's PowerLevel to another.
/// Only use this struct where the dependent Element is already known from
/// context (e.g. in AddElement).
type LevelDependency = resource struct {
    dependent_level PowerLevel;
    requires ElementLevel;
};

/// Offered by the Power Broker to allow Power Element owners to register
/// Power Elements and dependencies.
@discoverable
open protocol Topology {
    /// Made by a Power Element owner to register a new Power Element.
    flexible AddElement(resource struct {
        /// Human-readable name for logging and debug purposes.
        element_name string:1024;
        /// Default level (i.e. OFF or the lowest possible power level) for
        /// this element.
        default_level PowerLevel;
        /// List of dependencies for this element's power levels.
        /// dependency.requires.token must include Permissions.MODIFY_DEPENDENT.
        /// Note: dependencies ON this element's levels cannot be added here.
        dependencies vector<LevelDependency>:128;
        /// List of initial credentials to register for this element.
        /// You may not register credentials for other elements here.
        credentials_to_register vector<Credential>:128;
    }) -> (resource struct {
        /// ElementControl channel for this element.
        element_control_channel client_end:ElementControl;
        /// LevelControl channel for this element.
        level_control_channel client_end:LevelControl;
    }) error AddElementError;

    /// Made by a Power Element owner to register a dependency on or for an
    /// existing Power Element.
    flexible AddDependency(resource struct {
        /// Must supply two tokens to previously registered Credentials:
        /// dependency.dependent.token must have Permissions.MODIFY_DEPENDENCY and
        /// dependency.requires.token must have Permissions.MODIFY_DEPENDENT
        dependency Dependency;
    }) -> () error AddDependencyError;

    /// Made by a Power Element owner to remove a dependency from a Power Element.
    flexible RemoveDependency(resource struct {
        /// Must supply two tokens to previously registered Credentials:
        /// dependency.dependent.token must have Permissions.MODIFY_DEPENDENCY and
        /// dependency.requires.token must have Permissions.MODIFY_DEPENDENT
        dependency Dependency;
    }) -> () error RemoveDependencyError;

    /// Made by a Power Element owner to register credentials for an existing Power
    /// Element.
    flexible RegisterCredentials(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.MODIFY_CREDENTIAL and all permissions included by
        /// credentials_to_register.
        token zx.Handle:EVENTPAIR;
        /// Credentials to be registered for the Element of the above token.
        credentials_to_register vector<Credential>:128;
    }) -> () error RegisterCredentialsError;

    /// Made by a Power Element owner to unregister credentials from a Power
    /// Element. This will remove all authorization for these credentials.
    flexible UnregisterCredentials(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.MODIFY_CREDENTIAL for this element.
        token zx.Handle:EVENTPAIR;
        /// Pair tokens of the credentials to unregister.
        tokens_to_unregister vector<zx.Handle:EVENTPAIR>:128;
    }) -> () error UnregisterCredentialsError;
};

/// Provides element-scoped access to a previously added element.
/// Obtained via Topology.AddElement.
open protocol ElementControl {
    /// Register a new Status channel on which Power Broker will send
    /// read-only updates of the element's current power level. This method
    /// is intended to allow element owners to give read-only access to the
    /// element's current power level to clients by opening and transferring
    /// this channel.
    OpenStatusChannel(resource struct {
        status_channel server_end:Status;
    });

    /// Called by a Power Element owner to remove their Power Element.
    /// Removing a Power Element also removes dependencies on other elements,
    /// but dependencies on this element will remain permanently unsatisfied.
    /// The level control channel and open status channels will be closed and
    /// all tokens registered to this element will be unregistered.
    /// TODO(b/314814975): Make the above actually true.
    flexible RemoveElement() -> ();
};

/// This protocol can be used to get the current PowerLevel of an element or
/// watch changes to an element's power level. A new channel to this protocol
/// can be obtained by calling OpenStatus on the element's ElementControl
/// channel.
open protocol Status {
    /// Listen for changes to the element's current power level.
    /// If last_level is passed, it will block until the current level is
    /// different than last_level. Otherwise, it will return immediately
    /// with the current level.
    flexible WatchPowerLevel(resource struct {
        last_level PowerLevel:optional;
    }) -> (resource struct {
        current_level PowerLevel;
    });
};

/// Element Permissions
type Permissions = strict bits : uint32 {
    READ_POWER_LEVEL = 0x00000001;
    MODIFY_POWER_LEVEL = 0x00000002;
    MODIFY_DEPENDENT = 0x00000004;
    MODIFY_DEPENDENCY = 0x00000008;
    MODIFY_CREDENTIAL = 0x00000010;
    REMOVE_ELEMENT = 0x00000020;
    ACQUIRE_LEASE = 0x00000040;
};

/// A Credential associates an EventPair to a set of Permissions that
/// authorize actions that can be taken for a specific Power Element.
/// When registering a Credential, one end of the EventPair should be
/// passed to Power Broker, which will retain it. The other end of the
/// EventPair should be used by the Power Element owner or passed to
/// clients to authorize future operations on this Element.
type Credential = resource struct {
    /// The end of an EventPair that Power Broker will retain. The other
    /// end should be kept by the caller to use for future authentication.
    broker_token zx.Handle:EVENTPAIR;
    /// Bitmask using Element Permissions defined above.
    permissions Permissions;
};
