// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Draft Prototype of Protocols to be used by Power Broker.
// None of these protocols should be considered fully baked at this time
// and should be expected to change in the future as we gain information
// through this prototype testbed about coverage and usability.
@available(added=HEAD)
library fuchsia.power.broker;

/// Used to describe the power level of an element.
/// Could extend this further to support additional types of power
/// levels, such as ACPI.
type PowerLevel = strict union {
    1: binary BinaryPowerLevel;
};

type BinaryPowerLevel = strict enum : uint32 {
    OFF = 0;
    ON = 1;
};

// Unique ID provided by Power Broker (currently a UUID but subject to change).
alias LeaseId = string:64;
// Unique ID, provided by Power Broker. Could be a zx.Handle?
// TODO(b/297543815): Temporary placeholder until a formal system of tokens
// or paths is determined.
alias ElementId = string:1024;

type UpdateCurrentPowerLevelError = flexible enum {
    NOT_FOUND = 0;
};

/// Offered by the Power Broker to managed Power Element owners to receive
/// current power level status and initiate power level changes.
@discoverable
open protocol LevelControl {
    /// Request made by element owners on behalf of a single power element to
    /// the Power Broker as a hanging GET:
    /// If last_required_level does not match the current required power level
    /// this will return immediately with the new required power level.
    /// If last_required_level matches the current level, the call will
    /// hang until the required level changes.
    flexible WatchRequiredLevel(resource struct {
        // TODO(b/297543815): See note on PowerLessor.Lease below.
        element ElementId;
        /// Provided by the client with the last level received, or None if
        /// this is the first call.
        last_required_level PowerLevel:optional;
    }) -> (resource struct {
        required_level PowerLevel;
    });

    /// Sent by the element on initial startup and whenever there is a change
    /// in power level.
    flexible UpdateCurrentPowerLevel(resource struct {
        element ElementId;
        current_level PowerLevel;
    }) -> () error UpdateCurrentPowerLevelError;
};

/// Offered by the Power Broker to consumer Power Element owners (elements
/// that initiate leases).
@discoverable
open protocol Lessor {
    /// Request made to indicate client intends to raise the given element
    /// to the given power level and wants to have its direct and transitive
    /// power dependencies satisfied.
    flexible Lease(resource struct {
        // TODO(b/297543815): Replace these. The method by which clients
        // identify their power elements and the elements they intend to use
        // is still TBD. We will need something beyond handles to express
        // these links generically (i.e. not runtime handles), either in the
        // component manifest as capabilities or some other method linked to
        // the topology definition, which is also TBD.
        /// ID and PowerLevel of the element requesting the lease
        element ElementId;
        level PowerLevel;
    }) -> (resource struct {
        lease_id LeaseId;
    });

    /// Request made to drop a previously acquired lease.
    flexible DropLease(resource struct {
        lease_id LeaseId;
    });
};

type PowerLevelError = flexible enum {
    NOT_FOUND = 0;
};

/// Offered by the Power Broker to components (including drivers).
@discoverable
open protocol Status {
    /// Made by a component to get the current power level of an element.
    flexible GetPowerLevel(resource struct {
        element ElementId;
    }) -> (resource struct {
        cur_level PowerLevel;
    }) error PowerLevelError;

    /// Made by a component to listen for changes to element power levels.
    /// Request is made as a hanging GET which only returns if the new level
    /// has changed from the previous cur_level.
    flexible WatchPowerLevel(resource struct {
        element ElementId;
        last_level PowerLevel;
    }) -> (resource struct {
        new_level PowerLevel;
    }) error PowerLevelError;
};

type RemoveElementError = flexible enum {
    NOT_FOUND = 0;
};

type AddDependencyError = flexible enum {
    ALREADY_EXISTS = 0;
    ELEMENT_NOT_FOUND = 1;
    REQUIRED_ELEMENT_NOT_FOUND = 2;
};

type RemoveDependencyError = flexible enum {
    NOT_FOUND = 0;
};

type ElementLevel = resource struct {
    element ElementId;
    level PowerLevel;
};

/// Power dependency from one element's PowerLevel to another.
/// The Element and PowerLevel specified by `level` depends on
/// the Element and PowerLevel specified by `requires`.
type Dependency = resource struct {
    level ElementLevel;
    requires ElementLevel;
};

/// Offered by the Power Broker to allow Power Element owners to register
/// Power Elements and dependencies.
@discoverable
open protocol Topology {
    /// Made by a Power Element owner to register a new Power Element.
    flexible AddElement(resource struct {
        /// Human-readable name for logging and debug purposes.
        element_name string:1024;
        /// List of dependencies for this element.
        /// Empty ElementIds will be treated as referring to this Element.
        dependencies vector<Dependency>:128;
    }) -> (resource struct {
        /// Unique ID for this element (and access tokens).
        element ElementId;
    });

    /// Made by a Power Element owner to remove their Power Element.
    /// Removing a Power Element also removes all associated Dependencies.
    flexible RemoveElement(resource struct {
        element ElementId;
    }) -> () error RemoveElementError;

    /// Made by a Power Element owner to register a dependency on or for an
    /// existing Power Element.
    flexible AddDependency(resource struct {
        dependency Dependency;
    }) -> () error AddDependencyError;

    /// Made by a Power Element owner to remove a dependency from a Power Element.
    flexible RemoveDependency(resource struct {
        dependency Dependency;
    }) -> () error RemoveDependencyError;
};
