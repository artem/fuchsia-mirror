// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Draft Prototype of Protocols to be used by Power Broker.
// None of these protocols should be considered fully baked at this time
// and should be expected to change in the future as we gain information
// through this prototype testbed about coverage and usability.
@available(added=HEAD)
library fuchsia.power.broker;

using zx;

/// Used to describe the power level of an element.
/// Could extend this further to support additional types of power
/// levels, such as ACPI.
type PowerLevel = strict union {
    1: binary BinaryPowerLevel;
};

type BinaryPowerLevel = strict enum : uint32 {
    OFF = 0;
    ON = 1;
};

// Unique ID provided by Power Broker (currently a UUID but subject to change).
alias LeaseId = string:64;
// Unique ID, provided by Power Broker. Could be a zx.Handle?
// TODO(b/297543815): Temporary placeholder until a formal system of tokens
// or paths is determined.
alias ElementId = string:1024;

type WatchRequiredLevelError = flexible enum {
    NOT_AUTHORIZED = 0;
};

type UpdateCurrentPowerLevelError = flexible enum {
    NOT_AUTHORIZED = 0;
};

/// Offered by the Power Broker to managed Power Element owners to receive
/// current power level status and initiate power level changes.
@discoverable
open protocol LevelControl {
    /// Request made by element owners on behalf of a single power element to
    /// the Power Broker as a hanging GET:
    /// If last_required_level does not match the current required power level
    /// this will return immediately with the new required power level.
    /// If last_required_level matches the current level, the call will
    /// hang until the required level changes.
    flexible WatchRequiredLevel(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.MODIFY_POWER_LEVEL.
        token zx.Handle:EVENTPAIR;
        /// Provided by the client with the last level received, or None if
        /// this is the first call.
        last_required_level PowerLevel:optional;
    }) -> (resource struct {
        required_level PowerLevel;
    }) error WatchRequiredLevelError;

    /// Sent by the element on initial startup and whenever there is a change
    /// in power level.
    flexible UpdateCurrentPowerLevel(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.MODIFY_POWER_LEVEL.
        token zx.Handle:EVENTPAIR;
        current_level PowerLevel;
    }) -> () error UpdateCurrentPowerLevelError;
};

/// Offered by the Power Broker to consumer Power Element owners (elements
/// that initiate leases).
@discoverable
open protocol Lessor {
    /// Request made to indicate client intends to raise the given element
    /// to the given power level and wants to have its direct and transitive
    /// power dependencies satisfied.
    flexible Lease(resource struct {
        // TODO(b/297543815): Replace these. The method by which clients
        // identify their power elements and the elements they intend to use
        // is still TBD. We will need something beyond handles to express
        // these links generically (i.e. not runtime handles), either in the
        // component manifest as capabilities or some other method linked to
        // the topology definition, which is also TBD.
        /// ID and PowerLevel of the element requesting the lease
        element ElementId;
        level PowerLevel;
    }) -> (resource struct {
        lease_id LeaseId;
    });

    /// Request made to drop a previously acquired lease.
    flexible DropLease(resource struct {
        lease_id LeaseId;
    });
};

type PowerLevelError = flexible enum {
    NOT_AUTHORIZED = 0;
    NOT_FOUND = 1;
};

/// Offered by the Power Broker to components (including drivers).
@discoverable
open protocol Status {
    /// Made by a component to get the current power level of an element.
    flexible GetPowerLevel(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.READ_POWER_LEVEL.
        token zx.Handle:EVENTPAIR;
    }) -> (resource struct {
        cur_level PowerLevel;
    }) error PowerLevelError;

    /// Made by a component to listen for changes to element power levels.
    /// Request is made as a hanging GET which only returns if the new level
    /// has changed from the previous cur_level.
    flexible WatchPowerLevel(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.READ_POWER_LEVEL.
        token zx.Handle:EVENTPAIR;
        last_level PowerLevel;
    }) -> (resource struct {
        new_level PowerLevel;
    }) error PowerLevelError;
};

type AddElementError = flexible enum {
    INTERNAL = 0;
};

type RemoveElementError = flexible enum {
    NOT_AUTHORIZED = 0;
    NOT_FOUND = 1;
};

type AddDependencyError = flexible enum {
    ALREADY_EXISTS = 0;
    ELEMENT_NOT_FOUND = 1;
    NOT_AUTHORIZED = 2;
    REQUIRED_ELEMENT_NOT_FOUND = 3;
};

type RemoveDependencyError = flexible enum {
    NOT_AUTHORIZED = 0;
    NOT_FOUND = 1;
};

type RegisterCredentialsError = flexible enum {
    INTERNAL = 0;
    NOT_AUTHORIZED = 1;
};

type UnregisterCredentialsError = flexible enum {
    NOT_AUTHORIZED = 0;
};

type ElementLevel = resource struct {
    /// A token to a Credential previously registered on the element
    /// with the relevant Permissions for the action requested.
    token zx.Handle:EVENTPAIR;
    level PowerLevel;
};

/// Power dependency from one element's PowerLevel to another.
/// The Element and PowerLevel specified by `dependent` depends on
/// the Element and PowerLevel specified by `requires`.
type Dependency = resource struct {
    dependent ElementLevel;
    requires ElementLevel;
};

/// Offered by the Power Broker to allow Power Element owners to register
/// Power Elements and dependencies.
@discoverable
open protocol Topology {
    /// Made by a Power Element owner to register a new Power Element.
    flexible AddElement(resource struct {
        /// Human-readable name for logging and debug purposes.
        element_name string:1024;
        /// List of initial credentials to register for this element.
        /// You may not register credentials for other elements here.
        credentials_to_register vector<Credential>:128;
    }) -> (resource struct {
        /// Unique ID for this element, assigned by Power Broker.
        element ElementId;
    }) error AddElementError;

    /// Made by a Power Element owner to remove their Power Element.
    /// Removing a Power Element also removes all associated Dependencies.
    flexible RemoveElement(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.REMOVE_ELEMENT for the element to be removed.
        token zx.Handle:EVENTPAIR;
    }) -> () error RemoveElementError;

    /// Made by a Power Element owner to register a dependency on or for an
    /// existing Power Element.
    flexible AddDependency(resource struct {
        /// Must supply two tokens to previously registered Credentials:
        /// dependency.dependent.token must have Permissions.MODIFY_DEPENDENCY and
        /// dependency.requires.token must have Permissions.MODIFY_DEPENDENT
        dependency Dependency;
    }) -> () error AddDependencyError;

    /// Made by a Power Element owner to remove a dependency from a Power Element.
    flexible RemoveDependency(resource struct {
        /// Must supply two tokens to previously registered Credentials:
        /// dependency.dependent.token must have Permissions.MODIFY_DEPENDENCY and
        /// dependency.requires.token must have Permissions.MODIFY_DEPENDENT
        dependency Dependency;
    }) -> () error RemoveDependencyError;

    /// Made by a Power Element owner to register credentials for an existing Power
    /// Element.
    flexible RegisterCredentials(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.MODIFY_CREDENTIAL and all permissions included by
        /// credentials_to_register.
        token zx.Handle:EVENTPAIR;
        /// Credentials to be registered for the Element of the above token.
        credentials_to_register vector<Credential>:128;
    }) -> () error RegisterCredentialsError;

    /// Made by a Power Element owner to unregister credentials from a Power
    /// Element. This will remove all authorization for these credentials.
    flexible UnregisterCredentials(resource struct {
        /// Must supply a token to a previously registered Credential with
        /// Permissions.MODIFY_CREDENTIAL for this element.
        token zx.Handle:EVENTPAIR;
        /// Pair tokens of the credentials to unregister.
        tokens_to_unregister vector<zx.Handle:EVENTPAIR>:128;
    }) -> () error UnregisterCredentialsError;
};

/// Element Permissions
type Permissions = strict bits : uint32 {
    READ_POWER_LEVEL = 0x00000001;
    MODIFY_POWER_LEVEL = 0x00000002;
    MODIFY_DEPENDENT = 0x00000004;
    MODIFY_DEPENDENCY = 0x00000008;
    MODIFY_CREDENTIAL = 0x00000010;
    REMOVE_ELEMENT = 0x00000020;
};

/// A Credential associates an EventPair to a set of Permissions that
/// authorize actions that can be taken for a specific Power Element.
/// When registering a Credential, one end of the EventPair should be
/// passed to Power Broker, which will retain it. The other end of the
/// EventPair should be used by the Power Element owner or passed to
/// clients to authorize future operations on this Element.
type Credential = resource struct {
    /// The end of an EventPair that Power Broker will retain. The other
    /// end should be kept by the caller to use for future authentication.
    broker_token zx.Handle:EVENTPAIR;
    /// Bitmask using Element Permissions defined above.
    permissions Permissions;
};
