// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Draft Prototype of Protocols to be used by Power Broker.
// None of these protocols should be considered fully baked at this time
// and should be expected to change in the future as we gain information
// through this prototype testbed about coverage and usability.
@available(added=HEAD)
library fuchsia.power.broker;

/// Used to describe the power level of an element.
/// Could extend this further to support additional types of power
/// levels, such as ACPI.
type PowerLevel = strict union {
    1: binary BinaryPowerLevel;
};

type BinaryPowerLevel = strict enum : uint32 {
    OFF = 0;
    ON = 1;
};

type PowerLevelError = flexible enum {
    NOT_FOUND = 0;
};

// TODO(b/297543815) Temporary placeholder until a formal system of tokens
// or paths is determined.
// Provided by Element owner for now.
alias ElementId = string:1024;
// Unique ID provided by Power Broker (currently a UUID but subject to change).
alias LeaseId = string:64;

/// Offered by the Power Broker to managed Power Element owners to receive
/// current power level status and initiate power level changes.
@discoverable
open protocol Control {
    /// Request made by element owners on behalf of a single power element to
    /// the Power Broker as a hanging GET:
    /// If last_required_level does not match the current required power level
    /// this will return immediately with the new required power level.
    /// If last_required_level matches the current level, the call will
    /// hang until the required level changes.
    flexible GetRequiredLevelUpdate(resource struct {
        // TODO(b/297543815): See note on PowerLessor.Lease below.
        element_id ElementId;
        /// Provided by the client with the last level received, or None if
        /// this is the first call.
        last_required_level PowerLevel:optional;
    }) -> (resource struct {
        required_level PowerLevel;
    });

    /// Sent by the element on initial startup and whenever there is a change
    /// in power level. Fire and forget.
    flexible UpdateCurrentPowerLevel(resource struct {
        element_id ElementId;
        current_level PowerLevel;
    });
};

/// Offered by the Power Broker to consumer Power Element owners (elements
/// that initiate leases).
@discoverable
open protocol Lessor {
    /// Request made to indicate client is using a given element and needs it to be
    /// at the given minimum power state.
    flexible Lease(resource struct {
        // TODO(b/297543815): Replace these. The method by which clients
        // identify their power elements and the elements they intend to use
        // is still TBD. We will need something beyond handles to express
        // these links generically (i.e. not runtime handles), either in the
        // component manifest as capabilities or some other method linked to
        // the topology definition, which is also TBD.
        /// ID and PowerLevel of the element requesting the lease
        requesting_element_id ElementId;
        requesting_element_level PowerLevel;
        /// ID and PowerLevel of the element required by this lease
        required_element_id ElementId;
        required_element_level PowerLevel;
    }) -> (resource struct {
        lease_id LeaseId;
    });

    /// Request made to drop a previously acquired lease.
    flexible DropLease(resource struct {
        lease_id LeaseId;
    });
};

/// Offered by the Power Broker to components (including drivers).
@discoverable
open protocol Status {
    /// Made by a component to get the current power level of an element.
    flexible GetPowerLevel(resource struct {
        element_id ElementId;
    }) -> (resource struct {
        cur_level PowerLevel;
    }) error PowerLevelError;

    /// Made by a component to listen for changes to element power levels.
    /// Request is made as a hanging GET which only returns if the new level
    /// has changed from the previous cur_level.
    flexible GetPowerLevelOnChange(resource struct {
        element_id ElementId;
        cur_level PowerLevel;
    }) -> (resource struct {
        new_level PowerLevel;
    });
};
