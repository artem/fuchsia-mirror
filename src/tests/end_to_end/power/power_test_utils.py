#!/usr/bin/env fuchsia-vendored-python
# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Fuchsia power test utility library."""

import csv
from dataclasses import dataclass
import json
import os

from trace_processing import trace_metrics


def _avg(avg: float, value: float, count: int) -> float:
    return avg + (value - avg) / count


@dataclass
class PowerMetricSample:
    """A sample of collected power metrics.

    Args:
      timestamp: timestamp of sample in nanoseconds since epoch.
      voltage: voltage in Volts.
      current: current in milliAmpere.
    """

    timestamp: int
    voltage: float
    current: float

    def compute_power(self) -> float:
        """Compute the power in Watts from sample.

        Returns:
          Power in Watts.
        """
        return self.voltage * self.current * 1e-3


@dataclass
class AggregatePowerMetrics:
    """Aggregate power metrics representation.

    Represents aggregated metrics over a number of power metrics samples.

    Args:
      sample_count: number of power metric samples.
      max_power: maximum power in Watts over all samples.
      mean_power: average power in Watts over all samples.
      min_power: minimum power in Watts over all samples.
    """

    sample_count: int = 0
    max_power: float = float("-inf")
    mean_power: float = 0
    min_power: float = float("inf")

    def process_sample(self, sample: PowerMetricSample):
        """Process a sample of power metrics.

        Args:
            sample: A sample of power metrics.
        """
        power = sample.compute_power()
        self.sample_count += 1
        self.max_power = max(self.max_power, power)
        self.mean_power = _avg(self.mean_power, power, self.sample_count)
        self.min_power = min(self.min_power, power)

    def to_fuchsiaperf_results(self) -> list[trace_metrics.TestCaseResult]:
        """Converts Power metrics to fuchsiaperf JSON object.

        Returns:
          List of JSON object.
        """
        results: List[trace_metrics.TestCaseResult] = [
            trace_metrics.TestCaseResult(
                metric="MinPower",
                unit=trace_metrics.Unit.watts,
                values=[self.min_power],
            ),
            trace_metrics.TestCaseResult(
                metric="MeanPower",
                unit=trace_metrics.Unit.watts,
                values=[self.mean_power],
            ),
            trace_metrics.TestCaseResult(
                metric="MaxPower",
                unit=trace_metrics.Unit.watts,
                values=[self.max_power],
            ),
        ]
        return results


class PowerMetricsProcessor:
    """Power metric processor to extract performance data from raw samples.

    Args:
      power_samples_path: path to power samples CSV file.
    """

    def __init__(self, power_samples_path: str):
        self._power_samples_path: str = power_samples_path
        self._power_metrics: AggregatePowerMetrics = AggregatePowerMetrics()

    def process_metrics(self):
        """Coverts CSV samples into aggregate metrics."""
        with open(self._power_samples_path, "r") as f:
            reader = csv.reader(f)
            header = next(reader)
            assert header[0] == "Timestamp"
            assert header[1] == "Current"
            assert header[2] == "Voltage"
            for row in reader:
                sample = PowerMetricSample(
                    timestamp=int(row[0]),
                    voltage=float(row[1]),
                    current=float(row[2]),
                )
                self._power_metrics.process_sample(sample)

    def write_fuchsiaperf_json(
        self,
        output_dir: str,
        metric_name: str,
        trace_results: list[trace_metrics.TestCaseResult] = [],
    ) -> str:
        """Writes the fuchsia_perf JSON file to specified directory.

        Args:
          output_dir: path to the output directory to write to.
          metric_name: name of the power metric being measured.
          trace_metrics: trace-based metrics to include in the output.

        Returns:
          The fuchiaperf.json file generated by trace processing.
        """
        fuchsiaperf_json_path = os.path.join(
            output_dir,
            f"{metric_name}_power.fuchsiaperf.json",
        )

        suite = f"fuchsia.power.{metric_name}"
        results = self._power_metrics.to_fuchsiaperf_results() + trace_results
        results_json = [r.to_json(suite) for r in results]
        with open(fuchsiaperf_json_path, "w") as outfile:
            json.dump(results_json, outfile, indent=4)

        return fuchsiaperf_json_path
