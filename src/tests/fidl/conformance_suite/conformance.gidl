// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

decode_failure("UnconsumedBytesInline") {
    type = EmptyStruct,
    bytes = {
        v2 = [
            0x00, padding:7,
            repeat(0x00):8, // error: extra bytes
        ],
    },
    err = TOO_MANY_BYTES_IN_MESSAGE,
}

decode_failure("UnconsumedBytesOutOfLine") {
    type = OutOfLinePaddingZeroed7,
    bytes = {
        v2 = [
            repeat(0xff):8, // a*
            repeat(0xff):8, // b*
            0x01, padding:7, // a + 7 padding
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // b
            repeat(0x00):8 // error: extra bytes
        ],
    },
    err = TOO_MANY_BYTES_IN_MESSAGE,
}

decode_failure("PayloadTooSmall") {
    type = EmptyStruct,
    bytes = {
        v2 = [0x00],
    },
    err = TOO_FEW_BYTES_IN_PRIMARY_OBJECT,
}

success("EmptyStructSandwich") {
    value = EmptyStructSandwich{
        before: "before",
        es: EmptyStruct{},
        after: "after",
    },
    bytes = {
        v2 = [
            6, 0, 0, 0, 0, 0, 0, 0, // length of "before"
            255, 255, 255, 255, 255, 255, 255, 255, // "before" is present
            0, // empty struct zero field
            0, 0, 0, 0, 0, 0, 0, // 7 bytes of padding after empty struct, to align to 64 bits
            5, 0, 0, 0, 0, 0, 0, 0, // length of "after"
            255, 255, 255, 255, 255, 255, 255, 255, // "after" is present
            'b', 'e', 'f', 'o', 'r', 'e',
            0, 0, // 2 bytes of padding after "before", to align to 64 bits
            'a', 'f', 't', 'e', 'r', // "after" string
            0, 0, 0, // 3 bytes of padding after "after", to align to 64 bits
        ],
    },
}

success("Uint8Uint16Uint32Uint64") {
    value = Uint8Uint16Uint32Uint64{
        f1: 0x01,
        f2: 0x0203,
        f3: 0x04050607,
        f4: 0x08090a0b0c0d0e0f,
    },
    bytes = {
        v2 = [
            0x01, // f1
            0x00, // padding
            0x03, 0x02, // f2
            0x07, 0x06, 0x05, 0x04, // f3
            0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, // f4
        ],
    },
}

success("Uint64Uint32Uint16Uint8") {
    value = Uint64Uint32Uint16Uint8{
        f1: 0x08090a0b0c0d0e0f,
        f2: 0x04050607,
        f3: 0x0203,
        f4: 0x01,
    },
    bytes = {
        v2 = [
            0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, // f1
            0x07, 0x06, 0x05, 0x04, // f2
            0x03, 0x02, // f3
            0x01, // f4
            0x00, // padding
        ],
    },
}

success("InlineXUnionInStruct") {
    value = TestInlineXUnionInStruct{
        before: "before",
        xu: SampleXUnion{
            u: 0xdeadbeef,
        },
        after: "after",
    },
    bytes = {
        v2 = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x01, 0x00, // num bytes + num handles + inlined

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ],
    },
}

success("OptionalXUnionInStructAbsent") {
    value = TestOptionalXUnionInStruct{
        before: "before",
        // no SampleXUnion
        after: "after",
    },
    bytes = {
        v2 = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles + not inlined

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ],
    },
}

success("OptionalXUnionInStructPresent") {
    value = TestOptionalXUnionInStruct{
        before: "before",
        xu: SampleXUnion{
            u: 0xdeadbeef,
        },
        after: "after",
    },
    bytes = {
        v2 = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x01, 0x00, // num bytes + num handles + inlined

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ],
    },
}

decode_failure("OptionalXUnionInStructPresentInvalidNumBytes") {
    type = TestOptionalXUnionInStruct,
    bytes = {
        v2 = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes (invalid) + num handles + not inlined

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 2: xunion content
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x00, 0x00, // xunion envelope content (0xdeadbeef) + padding

            // secondary object 3: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ],
    },
    err = INVALID_NUM_BYTES_IN_ENVELOPE,
}

decode_failure("OptionalXUnionInStructPresentInvalidNumHandles") {
    type = TestOptionalXUnionInStruct,
    bytes = {
        v2 = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" presence

            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0xef, 0xbe, 0xad, 0xde, 0x01, 0x00, 0x01, 0x00, // num bytes + num handles (invalid) + inlined

            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" presence

            // secondary object 1: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00,

            // secondary object 32: "after"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00,
        ],
    },
    err = INVALID_NUM_HANDLES_IN_ENVELOPE,
}

success("XUnionInTableXUnionAbsent") {
    value = TestXUnionInTable{
        value: XUnionInTable{
            before: "before",
            // no SampleXUnion
            after: "after",
        },
    },
    bytes = {
        v2 = [
            // primary object
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vector<envelope> element count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // vector<envelope> present

            // secondary object 1: vector data
            // vector[0]: envelope<string before>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            // vector[1]: envelope<SampleXUnion xu>
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero envelope
            // vector[2]: envelope<string after>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count

            // secondary object 2: "before" length + pointer
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 3: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00, // "before"

            // secondary object 4: "after" length + pointer
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 5: "before"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00, // "after"
        ],
    },
}

success("XUnionInTableXUnionPresent") {
    value = TestXUnionInTable{
        value: XUnionInTable{
            before: "before",
            xu: SampleXUnion{
                u: 0xdeadbeef,
            },
            after: "after",
        },
    },
    bytes = {
        v2 = [
            // primary object
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vector<envelope> element count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // vector<envelope> present

            // secondary object 1: vector data
            // vector[0]: envelope<string before>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            // vector[1]: envelope<SampleXUnion xu>
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            // vector[2]: envelope<string after>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count

            // secondary object 2: "before" length + pointer
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 3: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00, // "before"

            // secondary object 4: xunion
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x01, 0x00, // value + num handles + inlined

            // secondary object 5: "after" length + pointer
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 6: "before"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00, // "after"
        ],
    },
}

decode_failure("XUnionInTableXUnionPresentInvalidNumBytes") {
    type = TestXUnionInTable,
    bytes = {
        v2 = [
            // primary object
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vector<envelope> element count
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // vector<envelope> present

            // secondary object 1: vector data
            // vector[0]: envelope<string before>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count
            // vector[1]: envelope<SampleXUnion xu>
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size (invalid) + handle count
            // vector[2]: envelope<string after>
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size + handle count

            // secondary object 2: "before" length + pointer
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "before" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "before" present

            // secondary object 3: "before"
            'b', 'e', 'f', 'o', 'r', 'e', 0x00, 0x00, // "before"

            // secondary object 4: xunion
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // xunion discriminator + padding
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x01, 0x00, // value + num handles + inlined

            // secondary object 5: "after" length + pointer
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "after" length
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // "after" present

            // secondary object 6: "before"
            'a', 'f', 't', 'e', 'r', 0x00, 0x00, 0x00, // "after"
        ],
    },
    err = INVALID_NUM_BYTES_IN_ENVELOPE,
}

success("StrictXUnion") {
    value = TestStrictXUnionInStruct{
        xu: SampleStrictXUnion{
            u: 0xdeadbeef,
        },
    },
    bytes = {
        v2 = [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xef, 0xbe, 0xad, 0xde, 0x00, 0x00, 0x01, 0x00,
        ],
    },
}

success("RecursiveVectorUnionStruct") {
    // TODO(https://fxbug.dev/7644): Fix self-references and enable for Dart.
    bindings_denylist = [dart],
    value = RecursiveVectorUnionStruct{
        u: RecursiveVectorUnion{
            vec: [
                RecursiveVectorUnion{
                    vec: [],
                },
            ],
        },
    },
    bytes = {
        v2 = [
            // primary object: outer union
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ordinal
            0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            // secondary object 1: outer vector
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // present
            // secondary object 2: inner union
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ordinal
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            // secondary object 3: inner vector
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // size 0
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // present
        ],
    },
}

success("MutualRecursionUnionStruct") {
    // TODO(https://fxbug.dev/7644): Fix self-references and enable for Dart.
    bindings_denylist = [dart],
    value = MutualRecursionUnionStruct{
        u: MutualRecursionUnion{
            s: MutualRecursionUnionStruct{
                u: MutualRecursionUnion{
                    s: MutualRecursionUnionStruct{},
                },
            },
        },
    },
    bytes = {
        v2 = [
            // primary object: outer union
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ordinal
            0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            // secondary object 1: inner union
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ordinal
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles
            // secondary object 2: null union
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ordinal
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num bytes + num handles + not inlined
        ],
    },
}

success("AddEthernetDeviceRequest") {
    value = TestAddEthernetDeviceRequest{
        topological_path: "/dev/sys/pci/00:03.0/e1000/ethernet",
        config: InterfaceConfig{
            name: "ethp0003",
            ip_address_config: IpAddressConfig{
                dhcp: true,
            },
        },
        // TODO(https://fxbug.dev/7947): This should be a handle.
        this_should_be_a_handle: 0xffffffff,
    },
    bytes = {
        v2 = [
            0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // topological_path
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // topological_path
            0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // name
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // name
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // subnet (dhcp ordinal)
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, //   value, num handle, inlined
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, // device (handle present)

            // topological path
            0x2f, 0x64, 0x65, 0x76, 0x2f, 0x73, 0x79, 0x73, // /dev/sys
            0x2f, 0x70, 0x63, 0x69, 0x2f, 0x30, 0x30, 0x3a, // /pci/00:
            0x30, 0x33, 0x2e, 0x30, 0x2f, 0x65, 0x31, 0x30, // 03.0/e10
            0x30, 0x30, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, // 00/ether
            0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, // net

            // name
            0x65, 0x74, 0x68, 0x70, 0x30, 0x30, 0x30, 0x33, // ethp0003
        ],
    },
}

success("PackageResolverResolveRequest") {
    value = TestPackageResolverResolveRequest{
        package_url: "a",
        selectors: ["a"],
        update_policy: UpdatePolicy{
            fetch_if_absent: true,
            allow_old_versions: true,
        },
        // TODO(https://fxbug.dev/7947): This should be a handle.
        this_should_be_a_handle: 0xffffffff,
    },
    bytes = {
        v2 = [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // package url size
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // package url ptr
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // selectors size
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // selectors ptr
            0x01, 0x01, 0x00, 0x00, // policy struct + padding
            0xFF, 0xFF, 0xFF, 0xFF, // request handle
            // out of line data
            0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
}

success("FileGetAttrResponse") {
    value = FileGetAttrResponse{
        s: 0x7eadbeaf,
        attributes: NodeAttributes{
            mode: 0x962381a4,
            id: 1,
            content_size: 231,
            storage_size: 231,
            link_count: 1,
            creation_time: 0x8877665544332211,
            modification_time: 0x00ffeeddccbbaa99,
        },
    },
    bytes = {
        v2 = [
            0xaf, 0xbe, 0xad, 0x7e, 0x00, 0x00, 0x00, 0x00,
            0xa4, 0x81, 0x23, 0x96, 0x00, 0x00, 0x00, 0x00,
            1, 0, 0, 0, 0, 0, 0, 0,
            231, 0, 0, 0, 0, 0, 0, 0,
            231, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0,
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
            0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        ],
    },
}

// See comment in optionals.test.fidl for why this test case exists.
success("Optionals") {
    value = StructWithOptionals{
        s: EmptyStruct{},
        s2: EmptyStruct{},
        t: TableWithEmptyStruct{
            s: EmptyStruct{},
        },
        xu: XUnionWithEmptyStruct{
            s: EmptyStruct{},
        },
        xu2: XUnionWithEmptyStruct{
            s: EmptyStruct{},
        },
        u: UnionWithEmptyStruct{
            s: EmptyStruct{},
        },
        u2: UnionWithEmptyStruct{
            s: EmptyStruct{},
        },
    },
    bytes = {
        v2 = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // EmptyStruct? present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // TableWithEmptyStruct length 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XUnionWithEmptyStruct ordinal
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, //   value, 0 handles, inline
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XUnionWithEmptyStruct? ordinal
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, //   value, 0 handles, inline
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // UnionWithEmptyStruct ordinal
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, //   value, 0 handles, inline
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // UnionWithEmptyStruct? ordinal
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, //   value, 0 handles, inline

            // secondary objects
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // EmptyStruct
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, //   value, 0 handles, inline
        ],
    },
}

success("OutOfLinePaddingZeroed7") {
    value = OutOfLinePaddingZeroed7{
        a: Uint8Struct{
            val: 0x01,
        },
        b: Uint64Struct{
            val: 2,
        },
    },
    bytes = {
        v2 = [
            repeat(0xff):8, // a*
            repeat(0xff):8, // b*
            0x01, padding:7, // a + 7 padding
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // b
        ],
    },
}

success("OutOfLinePaddingZeroed6") {
    value = OutOfLinePaddingZeroed6{
        a: Uint16Struct{
            val: 0x0201,
        },
        b: Uint64Struct{
            val: 3,
        },
    },
    bytes = {
        v2 = [
            repeat(0xff):8, // a*
            repeat(0xff):8, // b*
            0x01, 0x02, padding:6, // a + 6 padding
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // b
        ],
    },
}

success("OutOfLinePaddingZeroed4") {
    value = OutOfLinePaddingZeroed4{
        a: Uint32Struct{
            val: 0x04030201,
        },
        b: Uint64Struct{
            val: 5,
        },
    },
    bytes = {
        v2 = [
            repeat(0xff):8, // a*
            repeat(0xff):8, // b*
            0x01, 0x02, 0x03, 0x04, padding:4, // a + 4 padding
            0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // b
        ],
    },
}

success("Arrays") {
    value = StructWithArrays{
        arr_int: [1, 2],
        arr_string: ["a", "b"],
        arr_nullable_string: ["c", null],
        arr_struct: [StructWithInt{x: 1}, StructWithInt{x: 2}],
        arr_nullable_struct: [null, StructWithInt{x: 0x01020304}],
        arr_arr_int: [[1, 2, 3], [4, 5, 6]],
    },
    bytes = {
        v2 = [
            // primary object
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // arr_int: 1, 2
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // arr_string: "a" size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   "a" present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   "b" size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   "b" present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // arr_nullable_string: "c" size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   "c" present
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   null size 0
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   null not present
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // arr_struct: {x: 1}, {x: 2}
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // arr_nullable_struct: null not present
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   {x: 0x01020304} present
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // arr_arr_int: 1, 2,
            0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, //   3, 4,
            0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, //   5, 6,

            // secondary objects
            0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "a"
            0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "b"
            0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "c"
            0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, // {x: 0x01020304} + padding
        ],
    },
}

success("Vectors") {
    value = StructWithVectors{
        vec_empty: [],
        vec_int: [1, 2],
        vec_string: ["a", "b"],
        vec_nullable_string: [null, "c", null],
        vec_struct: [StructWithInt{x: 1}],
        vec_nullable_struct: [null, null, StructWithInt{x: 2}],
        vec_vec_int: [[1, 2], [3]],
    },
    bytes = {
        v2 = [
            // primary object
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_empty: size 0
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_int: size 2
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_string: size 2
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_nullable_string: size 3
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_struct: size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_nullable_struct: size 3
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_vec_int: size 2
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   present

            // secondary objects
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // vec_int: 1, 2
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_string: "a" size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   "a" present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   "b" size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   "b" present
            0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "a"
            0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "b"
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_nullable_string: null size 0
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   null not present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   "c" size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   "c" present
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   null size 0
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   null not present
            0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // "c"
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_struct: {x: 1}
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_nullable_struct: null not present
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   null not present
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   {x: 2} present
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // {x: 2}
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // vec_vec_int: [1, 2] size 2
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   [1, 2] present
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //   [3] size 1
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //   [3] present
            0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // [1, 2]
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // [3]
        ],
    },
}

// Test that bindings can use large arrays. Before const generics, Rust did not
// support arrays with more than 32 elements.
success("LargeArrays") {
    value = LargeArrays{
        a33: [
            "first", null, null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null, null, null,
            null, null, null, null, null, null, null, null, null, null, "last",
        ],
        a100: [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
            0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
            0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
            0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
            0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
            0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
            0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
            0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
            0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
        ],
        nested: [],
    },
    bytes = {
        v2 = [
            num(5):8, repeat(0xff):8, // "first" length + present
            repeat(0):496, // 31x length + absent (16)
            num(4):8, repeat(0xff):8, // "last" length + present
            // a100 array
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
            0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
            0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
            0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
            0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
            0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
            0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
            0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
            0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
            0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
            padding:4,
            num(0):8, repeat(0xff):8, // nested vector length + present
            // "first" and "last" secondary objects
            'f', 'i', 'r', 's', 't', padding:3,
            'l', 'a', 's', 't', padding:4,
        ],
    },
}

// This tests the default input used in fidlviz:
// https://fuchsia.googlesource.com/fidl-misc/+/HEAD/fidlviz/
success("FidlvizDemo") {
    handle_defs = {
        #0 = event(),
    },
    value = FidlvizDemo{
        // Integers
        f1: 0, f2: -1, f3: 2, f4: 3, f5: 4,

        // Other bases
        f6: 0b1010, f7: 0xff, f8: 0o755,

        // Floats
        f9: 1.0, f10: 1.0e-8,

        // Booleans
        f11: true, f12: false,

        // Strings
        f13: "Hello 🌎\u0021",
        f14: null, f15: "",

        // Handles
        f16: null, f17: #0,

        // Arrays and vectors
        f18: [12, 223, 0xff],
        f19: [1.0, 2.0, 0.3],
        f20: null,
        f21: [],

        // Bits and enums
        f22: 0b111, f23: 42,

        // Structs
        f24: FidlvizStruct1{},
        f25: FidlvizStruct2{x: 1},
        f26: null,
        f27: FidlvizStruct2{x: 42},

        // Tables
        f28: FidlvizTable{},
        f29: FidlvizTable{f1: true, f3: false},

        // Unions
        f30: null,
        f31: FidlvizUnion{f7: "hi"},
    },
    bytes = {
        v2 = [
            // f1-f4
            0x00, 0xff, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00,
            // f5
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f6-f9
            0x0a, 0xff, 0xed, 0x01, 0x00, 0x00, 0x80, 0x3f,
            // f10
            0x3a, 0x8c, 0x30, 0xe2, 0x8e, 0x79, 0x45, 0x3e,
            // f11-f12
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f13 string header
            0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f14 string header optional (absent)
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f15 string header empty
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f16, f17
            0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
            // f18
            0x0c, 0xdf, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f19 vector header
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f20 vector header optional (absent)
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f21 vector header
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f22, f23, f24
            0x07, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f25
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f26 absent struct pointer
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f27 present struct pointer
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f28 table header (max ordinal 0)
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f29 table header (max ordinal 3)
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            // f30 absent union header
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f31 present union header
            0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

            // f13 "Hello 🌎\u0021"
            0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xf0, 0x9f,
            0x8c, 0x8e, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f19 [1.0, 2.0, 3.0]
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
            0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xd3, 0x3f,
            // f27
            0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // f29
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            // f31
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x68, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
    },
    handles = {
        v2 = [#0],
    },
}
