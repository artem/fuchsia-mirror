// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_GRAPHICS_DISPLAY_DRIVERS_AMLOGIC_DISPLAY_HOT_PLUG_DETECTION_H_
#define SRC_GRAPHICS_DISPLAY_DRIVERS_AMLOGIC_DISPLAY_HOT_PLUG_DETECTION_H_

#include <fidl/fuchsia.hardware.gpio/cpp/wire.h>
#include <lib/async/cpp/irq.h>
#include <lib/fit/function.h>
#include <lib/zx/interrupt.h>
#include <lib/zx/result.h>
#include <threads.h>
#include <zircon/compiler.h>
#include <zircon/syscalls/port.h>

#include <cstddef>
#include <cstdint>
#include <memory>

#include <fbl/mutex.h>

#include "src/graphics/display/lib/driver-framework-migration-utils/dispatcher/dispatcher-factory.h"
#include "src/graphics/display/lib/driver-framework-migration-utils/dispatcher/dispatcher.h"
#include "src/graphics/display/lib/driver-framework-migration-utils/namespace/namespace.h"

namespace amlogic_display {

// The logical state of a Hot-Plug Detect pin.
enum class HotPlugDetectionState : uint8_t {
  kNotDetected = 0,  // No display is attached.
  kDetected = 1,     // A display is attached.
};

// Manages the GPIO connected to the HDMI HPD (Hot-Plug Detect) pin.
class HotPlugDetection {
 public:
  // Internal state size for the function called when the HPD pin state changes.
  static constexpr size_t kOnStateChangeTargetSize = 16;

  // The type of the function called when the HPD pin state changes.
  using OnStateChangeHandler =
      fit::inline_function<void(HotPlugDetectionState), kOnStateChangeTargetSize>;

  // Factory method intended for production use.
  //
  // `on_state_change` is called when the HPD pin state changes. The initial
  // state is HPD not detected. The target call must outlive the newly created
  // HotPlugDetection instance. The target may be called on an arbitrary thread.
  static zx::result<std::unique_ptr<HotPlugDetection>> Create(
      display::Namespace& incoming, display::DispatcherFactory& dispatcher_factory,
      OnStateChangeHandler on_state_change);

  // Production code should prefer the Create() factory method.
  //
  // `pin_gpio` is a FIDL client for the driver of the GPIO connected to the
  // HDMI plug's HPD (Hot-Plug Detect) pin. `pin_gpio_interrupt` is the
  // interrupt generated by the GPIO driver for the HDMI plug's HPD pin.
  //
  // `on_state_change` is called when the HPD (Hot-Plug Detection) state
  // changes. The target call must outlive the newly created HotPlugDetection
  // instance. The target may be called on an arbitrary thread.
  HotPlugDetection(fidl::ClientEnd<fuchsia_hardware_gpio::Gpio> pin_gpio,
                   zx::interrupt pin_gpio_interrupt, OnStateChangeHandler on_state_change,
                   std::unique_ptr<display::Dispatcher> irq_handler_dispatcher);

  HotPlugDetection(const HotPlugDetection&) = delete;
  HotPlugDetection& operator=(const HotPlugDetection&) = delete;

  ~HotPlugDetection();

  // The most recently reported HPD state.
  //
  // The state change handler will be called when the HPD state changes from the
  // value returned here.
  HotPlugDetectionState CurrentState();

  // Initialization work that is not suitable for the constructor.
  //
  // Called by Create().
  zx::result<> Init();

  // Updates internal state state to reflect the current HPD pin GPIO state.
  //
  // Should be called in response to GPIO state change interrupts.
  zx::result<> UpdateState();

 private:
  // Translates raw values from the GPIO connected to the HPD pin.
  static HotPlugDetectionState GpioValueToState(uint8_t gpio_value);

  // The GPIO polarity for detecting an HPD state change.
  static fuchsia_hardware_gpio::wire::GpioPolarity GpioPolarityForStateChange(
      HotPlugDetectionState current_state);

  zx::result<> SetPinGpioPolarity(fuchsia_hardware_gpio::GpioPolarity polarity);

  zx::result<HotPlugDetectionState> ReadPinGpioState();

  void InterruptHandler(async_dispatcher_t* dispatcher, async::IrqBase* irq, zx_status_t status,
                        const zx_packet_interrupt_t* interrupt);

  const fidl::WireSyncClient<fuchsia_hardware_gpio::Gpio> pin_gpio_;
  const zx::interrupt pin_gpio_irq_;

  // Guaranteed to have a target.
  const OnStateChangeHandler on_state_change_;

  std::unique_ptr<display::Dispatcher> irq_handler_dispatcher_;
  async::IrqMethod<HotPlugDetection, &HotPlugDetection::InterruptHandler> pin_gpio_irq_handler_{
      this};

  // Protects the state that may be accessed on multiple threads.
  fbl::Mutex mutex_;

  HotPlugDetectionState current_pin_state_ __TA_GUARDED(mutex_) =
      HotPlugDetectionState::kNotDetected;
};

}  // namespace amlogic_display

#endif  // SRC_GRAPHICS_DISPLAY_DRIVERS_AMLOGIC_DISPLAY_HOT_PLUG_DETECTION_H_
