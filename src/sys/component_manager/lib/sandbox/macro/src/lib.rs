// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use darling::{FromDeriveInput, FromMeta};
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, GenericParam, Lifetime, LifetimeDef};

/// Lifetime used in trait impls generated by the [Capability] macro.
static CAPABILITY_LIFETIME_NAME: &str = "'capability";

/// Attributes for the [Capability] derive macro.
#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(capability))]
struct CapabilityAttributes {
    /// If set, generate a [TryClone] implementation.
    try_clone: Option<TryClone>,

    /// If set, generate a [Convert] implementation.
    convert: Option<Convert>,
}

/// Generated implementation to use for [TryClone].
#[derive(FromMeta, Debug)]
#[darling(rename_all = "snake_case")]
enum TryClone {
    /// The type is clonable using [std::clone::Clone].
    ///
    /// [TryClone.try_clone] will always return an `Ok` value.
    Clone,
    /// The type is not clonable.
    ///
    /// [TryClone.try_clone] will always return an `Err` value.
    Err,
}

/// Generated implementation to use for [Convert].
#[derive(FromMeta, Debug)]
#[darling(rename_all = "snake_case")]
enum Convert {
    /// The type can only be converted to itself.
    ///
    /// [Convert.try_into_capability] will return an error for any [TypeId] that
    /// does not match the `Self` type.
    ToSelfOnly,
}

/// Derive macro that implements [Capability] and its super traits.
///
/// # Example
///
/// ```
/// #[derive(Capability, Debug)]
/// struct MyCapability;
/// ```
///
/// # `TryFrom<AnyCapability>`
///
/// The derived Capability implements `TryFrom<AnyCapability>`, and by extension,
/// `TryInto<T> for AnyCapability`, for convenient downcasting and conversion to a concrete type.
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
/// let downcast: MyCapability = any.try_into()?;
/// ```
///
/// The capability can be converted to a different type, provided that its
/// [Convert.try_into_capability] implementation allows it:
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
/// let some_other: SomeOtherCapability = any.try_into()?;
/// ```
///
/// # `TryFrom<&dyn ErasedCapability>`, `TryFrom<&AnyCapability>`, and `&mut` references
///
/// The derived Capability also implements conversion from a (mutable) reference to a type-erased
/// capability. This is used to downcast a reference to a reference to the concrete type:
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
///
/// let ref_any: &AnyCapability = &any;
/// let downcast_ref: &MyCapability = ref_any.try_into()?;
///
/// let mut_ref_any: &mut AnyCapability = &mut any;
/// let downcast_mut_ref: &mut MyCapability = mut_ref_any.try_into()?;
/// ```
///
/// # `TryClone`
///
/// All capabilities must implement `TryClone`. If your capability implements the standard Rust
/// `Clone` trait, use the `try_clone = "clone"` attribute to generate a `TryClone` implementation
/// that delegates to `Clone`:
///
/// ```
/// #[derive(Capability, Clone, Debug)]
/// #[capability(try_clone = "clone")]
/// struct MyCloneableCapability;
///
/// let cap = MyCloneableCapability {};
/// assert!(cap.try_clone().is_ok());  // TryClone always succeeds because it uses Clone.
/// ```
///
/// This works regardless if `Clone` is derived or explicitly implemented.
///
/// If your type is not cloneable, use `try_clone = "err"` to generate an implementation
/// that always returns an error.
///
/// ```
/// #[derive(Capability, Debug)]
/// #[capability(try_clone = "err")]
/// struct MyCapability;
///
/// let cap = MyCapability {};
/// assert!(cap.try_clone().is_err());  // TryClone always fails.
/// ```
///
/// Omit the `try_clone` attribute if you want to supply your own `TryClone` implementation.
///
/// # `Convert`
///
/// All capabilities must implement the `Convert`. This trait converts between capability types,
/// used in the `TryFrom<AnyCapability>` implementation.
///
/// Use the `convert = "to_self_only"` attribute to generate a minimal `Convert` implementation
/// that can convert the value into its own type:
///
/// ```
/// #[derive(Capability, Debug)]
/// #[capability(convert = "to_self_only")]
/// struct MyCapability;
///
/// let cap = MyCapability {};
/// let converted: Box<dyn Any> = cap.try_into_capability(TypeId::of::<MyCapability>()).unwrap();
/// let cap: MyCapability = *converted.downcast::<MyCapability>().unwrap();
/// ```
///
/// Omit the `convert` attribute if you want to supply your own `Convert` implementation.
#[proc_macro_derive(Capability, attributes(capability))]
pub fn derive_capability(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    let attrs = CapabilityAttributes::from_derive_input(&input).expect("invalid options");
    let name = &input.ident;

    // Create a `capability lifetime, used in impls that operate on references.
    let lifetime = LifetimeDef::new(Lifetime::new(CAPABILITY_LIFETIME_NAME, Span::call_site()));

    let mut lifetime_with_bounds = lifetime.clone();
    for param in input.generics.params.iter() {
        if let GenericParam::Lifetime(lifetime_def) = param {
            lifetime_with_bounds.bounds.push(lifetime_def.lifetime.clone());
        }
    }

    // Add the `capability lifetime to generics, and split it to get a piece suitable
    // for an `impl` declaration.
    //
    // For example, if the input type is `Foo<T>`, `impl_generics_with_lifetime`
    // is `<'capability, T>`, used as `impl<'capability, T> ...`
    let mut generics_with_lifetime = input.generics.clone();
    generics_with_lifetime.params.push(lifetime_with_bounds.into());
    let (impl_generics_with_lifetime, _, _) = generics_with_lifetime.split_for_impl();

    // Split the generics into pieces used in the trait impl declaration.
    //
    // For example, for the input type `Foo<T> where T: Bar`:
    //   * `impl_generics` is `<T>`, used as `impl<T>`
    //   * `ty_generics` is `<T>`, used as `Foo<T>`
    //   * `where_clause` is `where T: Bar`
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
    // The name of the type with generic parameters, e.g. `Open`, or `Data<T>`
    let typename = quote! { #name #ty_generics };

    // The [TryClone] trait impl body.
    let try_clone = match attrs.try_clone {
        Some(TryClone::Clone) => quote! {
            impl #impl_generics ::sandbox::TryClone for #typename #where_clause {
                #[inline]
                fn try_clone(&self) -> Result<Self, ()> {
                    Ok(self.clone())
                }
            }
        },
        Some(TryClone::Err) => quote! {
            impl #impl_generics ::sandbox::TryClone for #typename #where_clause {
                #[inline]
                fn try_clone(&self) -> Result<Self, ()> {
                    Err(())
                }
            }
        },
        None => quote! {},
    };

    // The [Convert] trait impl body.
    let convert = match attrs.convert {
        Some(Convert::ToSelfOnly) => quote! {
            impl #impl_generics ::sandbox::Convert for #typename #where_clause {
                #[inline]
                fn try_into_capability(self, type_id: ::std::any::TypeId) -> Result<Box<dyn ::std::any::Any>, ()> {
                    if type_id == ::std::any::TypeId::of::<Self>() {
                        return Ok(Box::new(self) as Box<dyn ::std::any::Any>);
                    }
                    Err(())
                }
            }
        },
        None => quote! {},
    };

    TokenStream::from(quote! {
        impl #impl_generics ::sandbox::Capability for #typename #where_clause {}

        #try_clone

        #convert

        impl #impl_generics TryFrom<::sandbox::AnyCapability> for #typename #where_clause {
            type Error = ();

            fn try_from(value: ::sandbox::AnyCapability) -> Result<Self, Self::Error> {
                if value.as_any().is::<Self>() {
                    return Ok(*value.into_any().downcast::<Self>().unwrap());
                }
                if let Ok(converted) = <::sandbox::AnyCapability as ::sandbox::Convert>::try_into_capability(value, std::any::TypeId::of::<Self>()) {
                    return Ok(*converted.downcast::<Self>().unwrap());
                }
                return Err(());
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime dyn ::sandbox::ErasedCapability> for &#lifetime #typename #where_clause {
            type Error = ();

            fn try_from(value: &dyn ::sandbox::ErasedCapability) -> Result<&#typename, ()> {
                value.as_any().downcast_ref::<#typename>().ok_or(())
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime mut dyn ::sandbox::ErasedCapability> for &#lifetime mut #typename #where_clause {
            type Error = ();

            fn try_from(value: &mut dyn ::sandbox::ErasedCapability) -> Result<&mut #typename, ()> {
                value.as_any_mut().downcast_mut::<#typename>().ok_or(())
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime ::sandbox::AnyCapability> for &#lifetime #typename #where_clause {
            type Error = ();

            fn try_from(value: &::sandbox::AnyCapability) -> Result<&#typename, ()> {
                value.as_ref().try_into()
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime mut ::sandbox::AnyCapability> for &#lifetime mut #typename #where_clause {
            type Error = ();

            fn try_from(value: &mut ::sandbox::AnyCapability) -> Result<&mut #typename, ()> {
                let borrowed: &mut dyn ::sandbox::ErasedCapability = <::sandbox::AnyCapability as ::std::borrow::BorrowMut<dyn ::sandbox::ErasedCapability>>::borrow_mut(value);
                borrowed.try_into()
            }
        }
    })
}
