// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use darling::{util::PathList, FromDeriveInput};
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, GenericParam, Lifetime, LifetimeDef, Path};

/// Lifetime used in trait impls generated by the [Capability] macro.
static CAPABILITY_LIFETIME_NAME: &str = "'capability";

/// Attributes for the [Capability] derive macro.
#[derive(FromDeriveInput, Default)]
#[darling(default, attributes(capability))]
struct CapabilityAttributes {
    /// If set, generate an [AsTrait] implementation that vend out trait objects
    /// corresponding to the specified traits.
    ///
    /// If not set, generates an [AsTrait] implementation that does not support
    /// any trait.
    as_trait: Option<PathList>,
}

/// Derive macro that implements [Capability] and its super traits.
///
/// # Example
///
/// ```
/// #[derive(Capability, Debug)]
/// struct MyCapability;
/// ```
///
/// # `TryFrom<AnyCapability>`
///
/// The derived Capability implements `TryFrom<AnyCapability>`, and by extension,
/// `TryInto<T> for AnyCapability`, for convenient downcasting and conversion to a concrete type.
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
/// let downcast: MyCapability = any.try_into()?;
/// ```
///
/// The capability can be converted to a different type, provided that its
/// [Convert.try_into_capability] implementation allows it:
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
/// let some_other: SomeOtherCapability = any.try_into()?;
/// ```
///
/// # `TryFrom<&dyn ErasedCapability>`, `TryFrom<&AnyCapability>`, and `&mut` references
///
/// The derived Capability also implements conversion from a (mutable) reference to a type-erased
/// capability. This is used to downcast a reference to a reference to the concrete type:
///
/// ```
/// let cap = MyCapability {};
/// let any: AnyCapability = Box::new(cap);
///
/// let ref_any: &AnyCapability = &any;
/// let downcast_ref: &MyCapability = ref_any.try_into()?;
///
/// let mut_ref_any: &mut AnyCapability = &mut any;
/// let downcast_mut_ref: &mut MyCapability = mut_ref_any.try_into()?;
/// ```
///
/// # Trait downcasting
///
/// All capabilities must implement the `AsTrait` trait. This supports downcasting the capability
/// to a trait object if it implements that trait. The `AsTrait` trait is unsafe so you should rely
/// on the derive macro to implement it for you:
///
/// ```
/// #[derive(Capability, Debug)]
/// #[capability(as_trait(MyTrait))]
/// struct MyCapability;
///
/// let cap = MyCapability {};
/// let cap: AnyCapability = Box::new(cap);
/// let my_trait: Result<&dyn MyTrait, AsTraitError> = crate::try_as_trait(MyTrait, &cap);
/// ```
#[proc_macro_derive(Capability, attributes(capability))]
pub fn derive_capability(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    let attrs = CapabilityAttributes::from_derive_input(&input).expect("invalid options");
    let name = &input.ident;

    // Create a `capability lifetime, used in impls that operate on references.
    let lifetime = LifetimeDef::new(Lifetime::new(CAPABILITY_LIFETIME_NAME, Span::call_site()));

    let mut lifetime_with_bounds = lifetime.clone();
    for param in input.generics.params.iter() {
        if let GenericParam::Lifetime(lifetime_def) = param {
            lifetime_with_bounds.bounds.push(lifetime_def.lifetime.clone());
        }
    }

    // Add the `capability lifetime to generics, and split it to get a piece suitable
    // for an `impl` declaration.
    //
    // For example, if the input type is `Foo<T>`, `impl_generics_with_lifetime`
    // is `<'capability, T>`, used as `impl<'capability, T> ...`
    let mut generics_with_lifetime = input.generics.clone();
    generics_with_lifetime.params.push(lifetime_with_bounds.into());
    let (impl_generics_with_lifetime, _, _) = generics_with_lifetime.split_for_impl();

    // Split the generics into pieces used in the trait impl declaration.
    //
    // For example, for the input type `Foo<T> where T: Bar`:
    //   * `impl_generics` is `<T>`, used as `impl<T>`
    //   * `ty_generics` is `<T>`, used as `Foo<T>`
    //   * `where_clause` is `where T: Bar`
    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
    // The name of the type with generic parameters, e.g. `Open`, or `Data<T>`
    let typename = quote! { #name #ty_generics };

    // The [AsTrait] trait impl body.
    let path_list: &[Path] = match &attrs.as_trait {
        Some(path_list) => &path_list[..],
        None => &([] as [Path; 0])[..],
    };
    let mut trait_matchers = proc_macro2::TokenStream::new();
    for ident in path_list.iter() {
        let matcher = quote! {
            if type_id == ::std::any::TypeId::of::<dyn #ident>() {
                let object = self as &dyn #ident;
                let any = ::std::mem::transmute::<&(dyn #ident), &dyn ::std::any::Any>(object);
                return Ok(any);
            }
        };
        trait_matchers.extend(matcher);
    }
    TokenStream::from(quote! {
        impl #impl_generics ::sandbox::AsTrait for #typename #where_clause {
            #[inline]
            unsafe fn try_as_trait(&self, type_id: ::std::any::TypeId) -> Result<&dyn ::std::any::Any, ::sandbox::AsTraitError> {
                #trait_matchers
                Err(::sandbox::AsTraitError(type_id))
            }
        }

        impl #impl_generics TryFrom<::sandbox::AnyCapability> for #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: ::sandbox::AnyCapability) -> Result<Self, Self::Error> {
                if value.as_any().is::<Self>() {
                    return Ok(*value.into_any().downcast::<Self>().unwrap());
                }
                let converted = <::sandbox::AnyCapability as ::sandbox::Capability>::try_into_capability(value, std::any::TypeId::of::<Self>())?;
                Ok(*converted.downcast::<Self>().unwrap())
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime dyn ::sandbox::ErasedCapability> for &#lifetime #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &dyn ::sandbox::ErasedCapability) -> Result<&#typename, Self::Error> {
                value.as_any().downcast_ref::<#typename>().ok_or(::sandbox::ConversionError::NotSupported)
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime mut dyn ::sandbox::ErasedCapability> for &#lifetime mut #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &mut dyn ::sandbox::ErasedCapability) -> Result<&mut #typename, Self::Error> {
                value.as_any_mut().downcast_mut::<#typename>().ok_or(::sandbox::ConversionError::NotSupported)
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime ::sandbox::AnyCapability> for &#lifetime #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &::sandbox::AnyCapability) -> Result<&#typename, Self::Error> {
                value.as_ref().try_into()
            }
        }

        impl #impl_generics_with_lifetime TryFrom<&#lifetime mut ::sandbox::AnyCapability> for &#lifetime mut #typename #where_clause {
            type Error = ::sandbox::ConversionError;

            fn try_from(value: &mut ::sandbox::AnyCapability) -> Result<&mut #typename, Self::Error> {
                let borrowed: &mut dyn ::sandbox::ErasedCapability = <::sandbox::AnyCapability as ::std::borrow::BorrowMut<dyn ::sandbox::ErasedCapability>>::borrow_mut(value);
                borrowed.try_into()
            }
        }
    })
}
