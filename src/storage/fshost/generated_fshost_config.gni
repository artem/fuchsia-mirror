# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components.gni")
import("//build/images/args.gni")

declare_args() {
  # If format_minfs_on_corruption is true (the default), fshost formats minfs partition on finding
  # it corrupted.  Set to false to keep the devices in a corrupted state which might be of help to
  # debug issues.
  # Set by products
  format_minfs_on_corruption = true

  # Set to one of "minfs", "fxfs", "f2fs" (unstable).
  # If set to anything other than "minfs", any existing minfs partition will be
  # migrated in-place to the specified format when fshost mounts it.
  # Set by products
  data_filesystem_format = "fxfs"

  # The format blobfs should store blobs in.
  # Set by boards.
  blob_layout_format = "compact"

  # The size of the FVM partition images "slice size". The FVM slice size is a
  # minimum size of a particular chunk of a partition that is stored within
  # FVM. A very small slice size may lead to decreased throughput. A very large
  # slice size may lead to wasted space. The selected default size of 8mb is
  # selected for conservation of space, rather than performance.
  # LINT.IfChange
  # Set by boards.
  fvm_slice_size = 8388608

  # LINT.ThenChange(/src/storage/fshost/generated_fshost_config.gni)

  # The following blobfs_* arguments are used to determine the
  # initial dimensions of the blobfs partition added to a FVM
  # image. If they are unset, the sizes of the input blobfs image will
  # determine the dimensions of the respective partition within FVM.
  #
  # These dimensions cannot make a partition smaller than the image provided
  # to the FVM tool; in that case, the partition dimensions would be expanded
  # to fit the input image.
  #
  # There are both board-level overrides and product-level dimensions. The
  # product-level overrides, if set, will take precedence.

  # minimum_inodes is the number of inodes to reserve for the fs
  # A value of false does not reserve any additional space than minimum
  # required for the filesystem.
  # Set by boards.
  blobfs_board_minimum_inodes = false

  # blobfs_maximum_runtime_bytes is an upper bound on the partition size on the device. Partitions
  # can grow as needed if there are extra slices available in FVM. This limit prevents the blobfs
  # partition from taking too much space away from other uses.
  #
  # Pass the empty string for no limit.
  # Set by boards.
  blobfs_maximum_runtime_bytes = ""

  # minfs_maximum_runtime_bytes is an upper bound on the partition size on the device. Partitions
  # can grow as needed if there are extra slices available in FVM. This limit prevents the minfs
  # partition from taking too much space away from other uses.
  #
  # Pass the empty string for no limit.
  # Set by boards.
  minfs_maximum_runtime_bytes = ""

  # Make fshost watch for NAND devices.
  # Set by boards.
  fshost_watch_for_nand = false

  # Use Fxfs's blob implementation
  # Changes the flashing logic because the outputs changed.
  # Toggles a bunch of tests to use fxfs.
  # Set by boards.
  fxfs_blob = false

  # If true, will enable content-detection for partition format, supporting both
  # minfs and fxfs filesystems. A special "fs_switch" file can be written to the root directory
  # containing the string "minfs", "fxfs" or "toggle" to trigger a migration from the current
  # format to the specified format. (The "toggle" option will migrate back and forth at each boot.)
  # Set by developers in fx set.
  use_disk_migration = false
}

# Generates a structured config value file for fshost.
#
# Parameters:
#
#   component_name (optional)
#     [string] The name of the component for which to produce config, defaults to "fshost".
#
#   options (optional)
#     [scope] A block of fshost configuration options to include in the config file.
#     Unrecognized options cause errors. Later options override earlier options. The provided
#     values override all other values, including defaults and build args.
#
template("generated_fshost_config") {
  _manifest_target = "${target_name}_manifest"
  _component_name = "fshost"
  if (defined(invoker.component_name)) {
    _component_name = invoker.component_name
  }

  fuchsia_component_manifest(_manifest_target) {
    component_name = _component_name
    manifest = "//src/storage/fshost/meta/config.cml"
    metadata = {
      # we don't want this in the packaged output, it's just to give cmc something to work with
      distribution_entries_barrier = []
    }
  }

  fuchsia_structured_config_values(target_name) {
    cm_label = ":$_manifest_target"
    values = {
      # Defaults
      # LINT.IfChange
      blobfs = true
      blobfs_allow_delivery_blobs = true
      blobfs_max_bytes = 0
      bootpart = true
      check_filesystems = true
      data = true
      data_max_bytes = 0
      disable_block_watcher = false
      factory = false
      fvm = true
      ramdisk_image = false
      fxfs_blob = false
      gpt = true
      gpt_all = false
      mbr = false
      netboot = false
      no_zxcrypt = false

      # LINT.ThenChange(/src/lib/assembly/platform_configuration/src/subsystems/storage.rs)

      # Parameters from //build/images/fvm.gni
      fvm_slice_size = fvm_slice_size

      # Parameters from //build/images/args.gni
      if (blobfs_board_minimum_inodes != false) {
        blobfs_initial_inodes = blobfs_board_minimum_inodes
      } else {
        blobfs_initial_inodes = 0
      }
      assert(blob_layout_format == "compact" ||
                 blob_layout_format == "deprecated_padded",
             "Unrecognized format for blob layout.")
      if (blob_layout_format == "deprecated_padded") {
        blobfs_use_deprecated_padded_format = true
      } else {
        blobfs_use_deprecated_padded_format = false
      }

      # Build args
      data_filesystem_format = data_filesystem_format
      format_data_on_corruption = format_minfs_on_corruption
      nand = fshost_watch_for_nand
      use_disk_migration = use_disk_migration

      if (minfs_maximum_runtime_bytes != "") {
        data_max_bytes = minfs_maximum_runtime_bytes
      }
      if (blobfs_maximum_runtime_bytes != "") {
        blobfs_max_bytes = blobfs_maximum_runtime_bytes
      }

      if (defined(invoker.options)) {
        forward_variables_from(invoker.options, "*")
      }
    }

    # Don't allow these configurations into production.
    # Partition limits should always be set on production builds.
    if (values.no_zxcrypt || values.gpt_all || values.blobfs_max_bytes == 0 ||
        values.data_max_bytes == 0) {
      if (!defined(deps)) {
        deps = []
      }
      deps += [ "//build/validate:non_production_tag" ]
    }
  }
}
