# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/assembled_system.gni")
import("//build/board.gni")
import("//build/images/args.gni")
import("//build/product.gni")
import("//build/sdk/product_bundle.gni")
import("//build/testing/boot_tests/zbi_test.gni")
import("//src/storage/fshost/generated_fshost_config.gni")

declare_args() {
  # Defines the default value of `kernel_zbi_test()` template `generate_cuckoo` parameters.
  # When true, all instances of `kernel_zbi_tests()` will default to generating a `cuckoo_zbi_test()`
  # which is a full system image generated for exfiltrating instrumentation data from a target system.
  generate_cuckoo_tests = false

  # Default value for `disabled` parameter for generated `cuckoo_test()`.
  # TODO(https://fxbug.dev/320511796): Cleanup when no longer necessary.
  disable_cuckoo_tests = false
}

cuckoo_kernel_zbi_test_params = {
  # List of assembly input groups that the kernel cuckoo zbi will use. Each one may provide
  # packages, core realm shards, etc.
  input_groups = [
    "bootstrap",
    "network",
  ]
}

template("_cuckoo_product_bundle") {
  assert(current_toolchain == default_toolchain)
  assert(defined(invoker.kernel_zbi))

  target_environments = [ emu_env ]
  if (defined(invoker.device_types)) {
    # Translate `device_types` to environments.
    target_environments = []
    foreach(device_type, invoker.device_types) {
      target_environments += [
        {
          dimensions = {
            device_type = device_type
          }
        },
      ]
    }
  }

  if ((!defined(invoker.disabled) && disable_cuckoo_tests) ||
      (defined(invoker.disabled) && invoker.disabled)) {
    target_environments = []
  }

  main_target = target_name
  assembled_system_target = "${target_name}.assembled_system"
  stub_test_target = "${target_name}.test"

  assembled_system_namespace = assembled_system_target

  # This creates the target test to run against the cuckoo images, the purpose of
  # this test is to trigger coverage collection.
  fuchsia_unittest_package(stub_test_target) {
    deps = [
      "//src/sys/early_boot_instrumentation/test:early-boot-collector-stub",
    ]
    test_specs = {
      environments = target_environments
      isolated = true
      product_bundle = main_target

      bootup_timeout_secs = default_boot_test_timeout_secs
      if (defined(invoker.timeout)) {
        bootup_timeout_secs = invoker.timeout
      }
    }
  }

  # Generate the assembled system with the provided kernel_zbi.
  assembly_kernel_zbi = invoker.kernel_zbi
  assembly_kernel_image_name = get_label_info(assembly_kernel_zbi, "name")
  if (defined(invoker.kernel_image_name)) {
    assembly_kernel_image_name = invoker.kernel_image_name
  }

  assembly_input = {
    testonly = true
    namespace = assembled_system_namespace
    image_name = "fuchsia"
    kernel_zbi = assembly_kernel_zbi
    kernel_image_name = assembly_kernel_image_name
    bootfs_labels = board_bootfs_labels
    base_packages =
        board_package_labels + board_driver_package_labels + [
          # This package is needed to provide a fake intl_services
          # so that snapshot won't time out trying to collect
          # locale and timezone annotations.
          "//src/testing/fidl/intl_property_manager:fake_intl_services_package",
          ":$stub_test_target",
        ]
    cmdline_deps = []
    system_image_deps = board_system_image_deps
    core_realm_definition = "//build/testing:cuckoo-core-realm"
    board_config_label = board_configuration_label
    allow_eng_platform_bundle_use = true

    if (fxfs_blob) {
      product_assembly_config_label =
          "//build/testing:cuckoo-product-configuration"
      generate_fxfs = true
    } else {
      if (data_filesystem_format == "fxfs") {
        product_assembly_config_label =
            "//build/testing:cuckoo-product-configuration-fxfs"
      } else {
        product_assembly_config_label =
            "//build/testing:cuckoo-product-configuration-minfs"
      }
      generate_fvm = true
      generate_fvm_fastboot = generate_fvm && assembly_generate_fvm_fastboot
      generate_fvm_nand = generate_fvm && assembly_generate_fvm_nand
    }

    generate_vbmeta = use_vbmeta
  }

  foreach(input_group, cuckoo_kernel_zbi_test_params.input_groups) {
    input_group_label = "//bundles/assembly_input_groups:${input_group}"
    assembly_input.base_packages += [ "${input_group_label}.base_packages" ]
    assembly_input.bootfs_labels += [ "${input_group_label}.bootfs_labels" ]
    assembly_input.cmdline_deps += [ "${input_group_label}.cmdline_deps" ]
    assembly_input.system_image_deps +=
        [ "${input_group_label}.system_image_deps" ]
  }

  assembled_system(assembled_system_target) {
    forward_variables_from(assembly_input, "*")
  }

  # The following logic to determine the product bundle's partition information
  # (including the location of the assembly manifest of the system A contents)
  # is a standard dance with product bundles and is replicated from
  # similar logic in `boot_test()`.
  _partition_config_label = "//boards/partitions:default($default_toolchain)"
  if (has_board) {
    assert(partitions_config_label != false,
           "Need to define partitions_config_label")
    _partition_config_label = partitions_config_label
  }

  product_bundle(main_target) {
    testonly = true

    name = main_target
    system_a = "${target_out_dir}/${assembled_system_namespace}/images.json"
    partitions = get_label_info(_partition_config_label, "target_out_dir") +
                 "/" + get_label_info(_partition_config_label, "name") + ".json"
    partitions_contents = partitions_config_contents

    deps = [
      ":$assembled_system_target",
      _partition_config_label,

      # While it is already a transitive dependency of the assembled system,
      # that dependency is subject to package metadata barrier. Accordingly, we
      # also depend directly the stub test package so it ends up in main
      # repository.
      ":$stub_test_target",
    ]
  }
}

# Composes a bootable kernel zbi test. That is, a zircon kernel that will launch
# a custom user space process instead of component manager.
#
# Subtargets
#
#   * `${target_name}.cuckoo.assembled_system`
#     Specifies a "cuckoo assembled system": an `assembled_system()` that
#     contains a test package with a stub test component, and which boots the
#     associated ZBI to a full Fuchsia system. This subtarget is only emitted if
#     `generate_cuckoo = true`.
#
# Parameters
#
#   * generate_cuckoo
#     - Optional: Whether to generate a cuckoo assembled system and emit the
#       `.cuckoo.assembled_system` subtarget (see above).
#     - Type: boolean
#     - Default: `kernel_zbi_test_generates_cuckoo`
#
#   * disabled
#     - Optional:  When true, the generated images and the test tied to them are
#       treated as disabled, that is, they will not be automatically executed.
#     - Type: boolean
#     - Default: false
#
# Additionally supports all parameters from `zbi_test()`.
template("kernel_zbi_test") {
  generate_cuckoo = generate_cuckoo_tests
  if (defined(invoker.generate_cuckoo)) {
    generate_cuckoo = invoker.generate_cuckoo
  }

  main_target = target_name
  cuckoo_deps = []

  if (generate_cuckoo) {
    cuckoo_target_name = "${target_name}.cuckoo"
    if (default_toolchain == current_toolchain) {
      _cuckoo_product_bundle(cuckoo_target_name) {
        forward_variables_from(invoker,
                               [
                                 "disabled",
                                 "timeout",
                                 "device_types",
                               ])
        kernel_zbi = ":$main_target.zbi"
        kernel_image_name = "$main_target"
      }
    } else {
      group(cuckoo_target_name) {
        testonly = true
        deps = [ ":$cuckoo_target_name($default_toolchain)" ]
      }
    }
    cuckoo_deps = [ ":$cuckoo_target_name($default_toolchain)" ]
  }

  zbi_test(main_target) {
    assert(current_cpu != "")
    deps = []
    data_deps = []
    forward_variables_from(invoker, "*", [ "generate_cuckoo" ])
    data_deps += cuckoo_deps
    deps += [ "//zircon/kernel" ]
  }
}
