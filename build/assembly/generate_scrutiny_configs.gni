# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/python/python_action.gni")
import("//build/testing/golden_files.gni")

# Generates the platform configs to pass into scrutiny rules.
#
# Arguments
#   assembly_input_bundles (required)
#     [list of paths] The paths to assembly input bundle config files.
#
#   static_packages_golden (required)
#     [path] The static packages list source-of-truth.
#     This lists base, cache, flexible, and base_driver packages.
#
#   bootfs_packages_golden (required)
#     [path] The bootfs packages list source-of-truth.
#
#   bootfs_files_golden (required)
#     [path] The bootfs files list source-of-truth.
#
#   kernel_cmdline_golden (required)
#     [path] The kernel cmdline list source-of-truth.
#
#   assembly_build_type (optional)
#     [string] When provided, the assembly artifacts for the given build type
#     will be included. Valid options are "userdebug" and "user".
#
template("generate_scrutiny_configs") {
  assert(defined(invoker.assembly_input_bundles),
         "Need to define assembly_input_bundles")
  assert(invoker.assembly_input_bundles != [],
         "Need to provide at least one assembly input bundle")
  assert(defined(invoker.static_packages_golden),
         "Need to define static_packages_golden")
  assert(defined(invoker.bootfs_packages_golden),
         "Need to define bootfs_packages_golden")
  assert(defined(invoker.bootfs_files_golden),
         "Need to define bootfs_files_golden")
  assert(defined(invoker.kernel_cmdline_golden),
         "Need to define kernel_cmdline_golden")

  _assembly_build_type = false
  if (defined(invoker.assembly_build_type)) {
    assert(invoker.assembly_build_type == "userdebug" ||
               invoker.assembly_build_type == "user",
           "assembly_build_type must be either 'userdebug' or 'user'")
    _assembly_build_type = invoker.assembly_build_type
  }

  files = {
    assembly_static_packages =
        "${target_out_dir}/${target_name}/assembly_static_packages.txt"
    assembly_bootfs_files =
        "${target_out_dir}/${target_name}/assembly_bootfs_files.txt"
    static_packages = "${target_out_dir}/${target_name}/static_packages.txt"
    bootfs_packages = "${target_out_dir}/${target_name}/bootfs_packages.txt"
    bootfs_files = "${target_out_dir}/${target_name}/bootfs_files.txt"
    kernel_cmdline = "${target_out_dir}/${target_name}/kernel_cmdline.txt"
  }
  labels = {
    generate_assembly = "${target_name}_generate_assembly"
    generate = "${target_name}_generate"
  }

  if (_assembly_build_type != false) {
    compiled_action(labels.generate_assembly) {
      tool = "//build/assembly/tools/generate_assembly_scrutiny_configs"
      outputs = [
        files.assembly_static_packages,
        files.assembly_bootfs_files,
      ]
      args = [
        "--packages",
        rebase_path(files.assembly_static_packages, root_build_dir),
        "--bootfs",
        rebase_path(files.assembly_bootfs_files, root_build_dir),
        "--build-type",
        _assembly_build_type,
      ]
    }
  }

  python_action(labels.generate) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "visibility",
                           ])
    testonly = true
    binary_label = "//build/assembly/scripts:generate_scrutiny_configs"

    depfile = "${target_out_dir}/${target_name}.depfile"
    inputs = invoker.assembly_input_bundles
    outputs = [
      files.static_packages,
      files.bootfs_packages,
      files.bootfs_files,
      files.kernel_cmdline,
    ]
    args = [
      "--static-packages-output",
      rebase_path(files.static_packages, root_build_dir),
      "--bootfs-packages-output",
      rebase_path(files.bootfs_packages, root_build_dir),
      "--bootfs-files-output",
      rebase_path(files.bootfs_files, root_build_dir),
      "--kernel-cmdline-output",
      rebase_path(files.kernel_cmdline, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--assembly-input-bundles",
    ]
    foreach(aib, invoker.assembly_input_bundles) {
      args += [ rebase_path(aib, root_build_dir) ]
    }

    if (_assembly_build_type != false) {
      inputs += [
        files.assembly_static_packages,
        files.assembly_bootfs_files,
      ]
      args += [
        "--static-packages-input",
        rebase_path(files.assembly_static_packages, root_build_dir),
        "--bootfs-files-input",
        rebase_path(files.assembly_bootfs_files, root_build_dir),
      ]
      deps += [ ":${labels.generate_assembly}" ]
    }
  }

  golden_files(target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    testonly = true
    deps = [ ":${labels.generate}" ]
    comparisons = [
      {
        golden = invoker.static_packages_golden
        candidate = files.static_packages
      },
      {
        golden = invoker.bootfs_packages_golden
        candidate = files.bootfs_packages
      },
      {
        golden = invoker.bootfs_files_golden
        candidate = files.bootfs_files
      },
      {
        golden = invoker.kernel_cmdline_golden
        candidate = files.kernel_cmdline
      },
    ]
  }
}
