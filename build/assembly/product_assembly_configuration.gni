# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/group_with_inputs.gni")

# Create a product assembly config file from the lists of packages and config
# passed into the template.
#
# This template specifically converts lists of labels for fuchsia_package() and
# prebuilt_package() into the lists of output paths needed.  This keeps the
# contract about where those two templates place the package manifest internal
# to fuchsia.git.
#
# As outputs, this creates:
#
#  outputs = [
#       "${target_out_dir}/${target_name}/product_assembly_config.json"
#  ]
#
#
# Arguments:
#
#   Product-specified Package Sets:
#    These are optional lists of targets that produce Fuchsia Packages.  These
#    are NOT walked for metadata, but must be the exact desired package-creating
#    targets.
#
#   base_packages [optional]
#     [list, GN scopes] A list of GN scopes that hold the information for a
#     product-provided package to place into the base set. The scope must have a
#     'package_target' field pointing to the GN target of the fuchsia_package.
#
#   base_driver_packages (optional)
#     [list, GN scopes] A list of GN scopes that hold the driver packages to
#     include in the base package set. Packages listed here should not be
#     listed in the base_packages and will be included automatically in
#     the base package set as driver packages.
#
#     Each scope added to this list needs to be in the following form:
#       {
#         # This is the label that creates the package, this can not be a group
#         package_target = "//gn/label/that/to/the/driver:package"
#
#         # These are paths to the driver components within the above package.
#         driver_components = [
#           "meta/driver_1.cm",
#           "meta/driver_2.cm",
#         ]
#       }
#
#   cache_packages [optional]
#     [list, GN scopes] A list of GN scopes that hold the information for a
#     product-provided package to place into the cache set. The scope must have a
#     'package_target' field pointing to the GN target of the fuchsia_package.
#
#   font_asset_provider_packages [optional]
#     [list, GN labels] A list of GN labels pointing at product-provided
#     packages containing font assets.  These fonts end up as base packages,
#     since that is the only font distribution method we support at the moment.
#
#   platform [optional]
#   [scope] This is the platform configuration scope
#
#   product [optional]
#   [scope] This is the product configuration scope
#
# GN Usual:
#   deps
#   testonly
#   visibility
template("product_assembly_configuration") {
  labels = {
    # So it can be reused.
    target_name = target_name

    assembly_config = "${target_name}.product_assembly_config.json"

    # This is a publicly visible, test-only target, that allows the assembly
    # config to be used without needing the deps used create it.
    assembly_config_for_validation =
        "${target_name}.product_assembly_config.json.for_validation"

    base_package_set = "${target_name}.base_packages"
    base_package_config_data = "${target_name}.base_packages.config_data"
    base_driver_package_set = "${target_name}.base_driver_packages"
    cache_package_set = "${target_name}.cache_packages"
    cache_package_config_data = "${target_name}.cache_packages.config_data"
    board_driver_package_set = "${target_name}.board_driver_packages"

    # Base packages specified by the invoker, used to create the list of
    # manifests and as the deps for the package set targets.
    base_package_labels = []
    base_package_config_data_deps = []
    if (defined(invoker.base_packages)) {
      foreach(package, invoker.base_packages) {
        assert(defined(package.package_target),
               "package_target must be supplied")
        base_package_labels += [ package.package_target ]

        if (defined(package.config_data)) {
          foreach(_config_data, package.config_data) {
            if (defined(_config_data.label)) {
              base_package_config_data_deps += [ _config_data.label ]
            }
          }
        }
      }
    }

    # Font packages to be included in base_packages.  These contain no
    # config data.
    if (defined(invoker.font_asset_provider_packages)) {
      foreach(font_package, invoker.font_asset_provider_packages) {
        base_package_labels += [ font_package ]
      }
    }

    # Cache packages specified by the invoker, used to create the list of
    # manifests and as the deps for the package set targets.
    cache_package_labels = []
    cache_package_config_data_deps = []
    if (defined(invoker.cache_packages)) {
      foreach(package, invoker.cache_packages) {
        assert(defined(package.package_target),
               "package_target must be supplied")
        cache_package_labels += [ package.package_target ]

        if (defined(package.config_data)) {
          foreach(_config_data, package.config_data) {
            if (defined(_config_data.label)) {
              cache_package_config_data_deps += [ _config_data.label ]
            }
          }
        }
      }
    }

    # Driver packages specified by the invoker, used to create the list of
    # manifests and as the deps for the package set targets.
    base_driver_package_labels = []
    if (defined(invoker.base_driver_packages)) {
      foreach(package, invoker.base_driver_packages) {
        base_driver_package_labels += [ package.package_target ]
      }
    }
  }

  files = {
    outdir = "$target_out_dir/$target_name"
    assembly_config_file = "$outdir/product_assembly_config.json"

    # Compute the paths for the package manifests (as files).  This is
    # closely coupled with how fuchsia_package() and prebuilt_package() both
    # create a package manifest from their label.

    base_packages = []
    base_package_manifests = []
    base_package_config_data_sources = []
    if (defined(invoker.base_packages)) {
      foreach(package, invoker.base_packages) {
        assert(defined(package.package_target),
               "package_target must be supplied")
        _package_out_dir =
            get_label_info(package.package_target, "target_out_dir")
        _package_name = get_label_info(package.package_target, "name")
        _manifest_path =
            "${_package_out_dir}/${_package_name}/package_manifest.json"
        _manifest_path_rebased = rebase_path(_manifest_path, root_build_dir)

        _config_data = []
        if (defined(package.config_data)) {
          foreach(c, package.config_data) {
            base_package_config_data_sources += [ c.source ]
            _config_data += [
              {
                source = rebase_path(c.source, root_build_dir)
                destination = c.destination
              },
            ]
          }
        }

        base_package_manifests += [ _manifest_path ]
        base_packages += [
          {
            manifest = _manifest_path_rebased
            if (defined(package.config_data)) {
              config_data = _config_data
            }
          },
        ]
      }
    }

    # Similar to above, except for font packages, and a bit simpler since
    # invoker.font_asset_provider_packages is a list of labels, not a list
    # of scopes.
    if (defined(invoker.font_asset_provider_packages)) {
      foreach(package, invoker.font_asset_provider_packages) {
        _package_out_dir = get_label_info(package, "target_out_dir")
        _package_name = get_label_info(package, "name")
        _manifest_path =
            "${_package_out_dir}/${_package_name}/package_manifest.json"
        _manifest_path_rebased = rebase_path(_manifest_path, root_build_dir)

        base_package_manifests += [ _manifest_path ]
        base_packages += [
          {
            manifest = _manifest_path_rebased
          },
        ]
      }
    }

    cache_packages = []
    cache_package_manifests = []
    cache_package_config_data_sources = []
    if (defined(invoker.cache_packages)) {
      foreach(package, invoker.cache_packages) {
        assert(defined(package.package_target),
               "package_target must be supplied")
        _package_out_dir =
            get_label_info(package.package_target, "target_out_dir")
        _package_name = get_label_info(package.package_target, "name")
        _manifest_path =
            "${_package_out_dir}/${_package_name}/package_manifest.json"
        _manifest_path_rebased = rebase_path(_manifest_path, root_build_dir)

        _config_data = []
        if (defined(package.config_data)) {
          foreach(c, package.config_data) {
            cache_package_config_data_sources += [ c.source ]
            _config_data += [
              {
                source = rebase_path(c.source, root_build_dir)
                destination = c.destination
              },
            ]
          }
        }

        cache_package_manifests += [ _manifest_path ]
        cache_packages += [
          {
            manifest = _manifest_path_rebased
            if (defined(package.config_data)) {
              config_data = _config_data
            }
          },
        ]
      }
    }

    base_driver_packages = []
    driver_package_manifests = []
    if (defined(invoker.base_driver_packages)) {
      foreach(driver_package, invoker.base_driver_packages) {
        assert(defined(driver_package.package_target),
               "package target must be supplied")
        _package_out_dir =
            get_label_info(driver_package.package_target, "target_out_dir")
        _package_name = get_label_info(driver_package.package_target, "name")
        _manifest_path =
            "${_package_out_dir}/${_package_name}/package_manifest.json"
        _manifest_path_rebased = rebase_path(_manifest_path, root_build_dir)

        driver_package_manifests += [ _manifest_path ]
        base_driver_packages += [
          # This scope needs to serialize to json and deserialize
          # to a DriverDetails Assembly config struct
          {
            package = _manifest_path_rebased
            components = driver_package.driver_components
          },
        ]
      }
    }
  }

  # Platform configuration schema fields that are paths to files.  These need to
  # be tracked as GN action `inputs`.
  #
  # Each is a path to a 'node' in the schema, and then a list of field names on
  # that node:
  #
  #  platform: {
  #    foo: {
  #      bar: {
  #        field: "../../path/to/source/filename.json"
  #      }
  #    }
  #  }
  #
  # is the following:
  #
  #  {
  #    node_path = "foo.bar"
  #    items = [ "field" ]
  #  }
  #
  # These paths need to be present in the generated assembly configuration json
  # file as _rebased_ paths.  In the example above, the GN label in GN for that
  # file is: `//path/to/source/filename.json`
  #
  # Assembly runs in a root_build_dir such as `//out/default`, and so the
  # rebased path from the root_build_dir to the file is
  # `../../path/to/source/filename.json`
  #
  # The GN label for the file needs to be passed to GN in the `inputs` list for
  # the `target_name` action defined by this template (below).
  #
  # However, because GN doesn't allow us to set the value of a variable in a
  # scope using the `scope_name[var_name]` syntax, only read it, we cannot do
  # any sort of programmatic field replacement, at least not without hard-coded
  # logic that's repeated for each field (which prior versions of this file did
  # when there was only field to deal with), e.g.:
  #
  #  _p = invoker.platform
  #
  #  # platform configuration with rebased contents:
  #  _new_platform_config = {
  #    forward_variables_from(_p, "*", [ "foo" ])
  #    if (defined(_p.foo)) {
  #      _foo = _p.foo
  #
  #      # 'foo' with rebased contents:
  #      foo = {
  #        forward_variables_from(_p.foo, "*", ["bar"])
  #
  #        if (defined(_foo.bar)) {
  #          _bar = _foo.bar
  #
  #          # 'bar' with rebased contents:
  #          bar = {
  #            forward_variables_from(_bar, "*", ["field"])
  #            if (defined(_bar.field)) {
  #              field = rebase_path(_bar.field, root_build_dir)
  #            }
  #          }
  #        }
  #      }
  #    }
  #  }
  #
  # The original invoker.platform scope would need to be carefully reconstructed
  # at every level using this pattern of forwarding variables that weren't part
  # of the newly-constructed ones, and then assigning the newly-constructed ones
  # to the appropriate variables in each of the nested scopes.

  config_file_potential_inputs = [
    {
      node_path = "platform.ui"
      fields = [ "sensor_config" ]
    },
    {
      node_path = "platform.development_support"
      fields = [
        "authorized_ssh_keys_path",
        "authorized_ssh_ca_certs_path",
      ]
    },
    {
      node_path = "platform.forensics.cobalt"
      fields = [ "registry" ]
    },
    {
      node_path = "platform.storage.component_id_index"
      fields = [ "product_index" ]
    },
    {
      node_path = "product.build_info"
      fields = [
        "version",
        "jiri_snapshot",
        "latest_commit_date",
        "minimum_utc_stamp",
      ]
    },
  ]

  # The assembly configuration
  config_inputs = []

  _config = {
    if (defined(invoker.platform)) {
      platform = invoker.platform
    }
    if (defined(invoker.product)) {
      product = invoker.product
    }
  }

  # Iterate over each item in the list above.
  foreach(potential_input, config_file_potential_inputs) {
    _node = {
    }
    _node = _config

    # Since we can't use recursion, iteratively change `_node` to the next
    # child in the path, e.g. 'foo', then 'bar'.  The `continue` var is used
    # to signal that some node along the path has been omitted, and this will
    # be a no-op for the rest of the iteration (since it can't exit early)
    _continue = true
    foreach(_node_name, string_split(potential_input.node_path, ".")) {
      if (_continue && defined(_node[_node_name])) {
        # because GN will not let you replace a non-empty scope, this does a
        # little workaround to what would be the following, if it was allowed:
        #
        #  _node = _node[_node_name]
        #
        # Instead, we need to create a _next_node temporary to hold the next
        # node, but even that temporary lives across iterations of the loop,
        # and must be reset to an empty scope before re-assigning to it.
        #

        # Clear the previous _next_node, and then cache the next node to look
        # at in _next_node.
        _next_node = {
        }
        _next_node = _node[_node_name]

        # Clear the _node var, so that we can assign _next_node to it.
        _node = {
        }
        _node = _next_node
      } else {
        # The node wasn't found, so do nothing for the rest of the iteration.
        _continue = false
      }
    }

    # 'continue' will still be true if the all the nodes in the path were
    # found.
    if (_continue) {
      foreach(_field_name, potential_input.fields) {
        if (defined(_node[_field_name])) {
          _file_path = _node[_field_name]

          # Here the rebased path is converted back in to an absolute GN
          # file label, from the GN root dir `//`:
          #
          # ../../path/to/filename.json
          #
          # becomes:
          #
          # //path/to/filename.json
          #
          # and if a file in root_build_dir:
          #
          # path/to/filename.json
          #
          # it becomes (for `root_build_dir` == "//out/default"):
          #
          # //out/default/path/to/filename.json
          #
          # And the resultant (non-rebased) path can be used in the GN
          # action's `inputs` list
          _gn_path = "//" + rebase_path(_file_path, "//", root_build_dir)
          config_inputs += [ _gn_path ]
        }
      }
    }
  }

  _assembly_config = {
    # Create the platform configuration section from the caller's argument
    platform = invoker.platform
    assert(defined(platform.build_type),
           "The platform build-type must be specified.")

    # Create the product configuration section from the caller's arguments.
    product = {
      if (defined(invoker.product)) {
        forward_variables_from(invoker.product, "*")
      }
      assert(!defined(packages),
             "Packages cannot be directly supplied under product")

      packages = {
        base = files.base_packages
        cache = files.cache_packages
      }

      base_drivers = files.base_driver_packages
    }
  }

  # Generate the Product Assembly configuration file itself.
  #
  # This does _not_ have deps on any of the passed in targets, which is why it
  # restricts it's visibility to the target that does dep on them.
  #
  generated_file(labels.assembly_config) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [
      ":${labels.assembly_config_for_validation}",
      ":${labels.target_name}",
    ]
    outputs = [ files.assembly_config_file ]
    output_conversion = "json"
    contents = _assembly_config
  }

  # These are used to detect if the deps don't correspond to a set of input
  # files (the deps can be larger than the set of files, but not the other way
  # around).  Since we're computing the manifest paths from the labels, if the
  # label to something other than a package is added, we'll compute a manifest
  # path that doesn't exist.  This catches it here, instead of inside a build
  # action which can't explain why it can't find a file.

  # Create a target for the base packages, so they appear in the dep graph
  # as distinct from the cache packages, and validate that they produce all of
  # the manifests whose paths were computed from the labels.
  group_with_inputs(labels.base_package_set) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":${labels.target_name}" ]
    inputs = files.base_package_manifests
    deps = labels.base_package_labels
  }

  group_with_inputs(labels.base_package_config_data) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":${labels.target_name}" ]
    inputs = files.base_package_config_data_sources
    deps = labels.base_package_config_data_deps
  }

  # Create a target for the base driver packages, so they appear in the dep
  # graph as distinct from the cache packages, and validate that they produce
  # all of the manifests whose paths were computed from the labels.
  group_with_inputs(labels.base_driver_package_set) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":${labels.target_name}" ]
    inputs = files.driver_package_manifests
    deps = labels.base_driver_package_labels
  }

  # Create a target for the cache packages, so they appear in the dep graph
  # as distinct from the base packages, and validate that they produce all of
  # the manifests whose paths were computed from the labels.
  group_with_inputs(labels.cache_package_set) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":${labels.target_name}" ]
    inputs = files.cache_package_manifests
    deps = labels.cache_package_labels
  }

  group_with_inputs(labels.cache_package_config_data) {
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":${labels.target_name}" ]
    inputs = files.cache_package_config_data_sources
    deps = labels.cache_package_config_data_deps
  }

  group_with_inputs(labels.target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                             "inputs",
                             "testonly",
                             "visibility",
                           ])
    if (!defined(public_deps)) {
      public_deps = []
    }
    public_deps += [ ":${labels.assembly_config}" ]

    if (!defined(inputs)) {
      inputs = []
    }

    # Add any inputs found by looking at the known config schema items
    # that contain paths to files, so that they are guaranteed to be added to
    # the ninja deps for the product assembly configuration.
    inputs += config_inputs

    if (!defined(deps)) {
      deps = []
    }
    deps += [
      ":${labels.base_driver_package_set}",
      ":${labels.base_package_config_data}",
      ":${labels.base_package_set}",
      ":${labels.cache_package_config_data}",
      ":${labels.cache_package_set}",
    ]

    # Block all metadata walks for packages, distribution entries, etc.  These
    # inputs should not exist in metadata walks, as they are added via the paths
    # in the assembly config itself.
    metadata = {
      package_barrier = []
      assembly_package_barrier = []
      config_package_barrier = []
      driver_package_barrier = []
      system_image_package_barrier = []
      distribution_entries_barrier = []
    }
  }

  # A testonly group with no visibilty restrictions, that allows the use of the
  # generated product assembly config file in validation actions that don't
  # require the existence of the packages and binaries that it points to.
  group(labels.assembly_config_for_validation) {
    testonly = true
    public_deps = [ ":${labels.assembly_config}" ]
  }
}
