# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/assembly/assembly_input_bundle.gni")
import("//build/assembly/bootfs_files_for_assembly.gni")
import("//build/assembly/generated_image_assembly_config.gni")
import("//build/assembly/package_manifests_list.gni")
import("//build/dist/distribution_manifest.gni")
import("//build/python/python_action.gni")
import("//src/storage/fshost/fshost.gni")
import("//src/storage/fshost/generated_fshost_config.gni")

# Create a "legacy" assembly input bundle from an image assembly configuration,
# so that product assembly can use it to produce a matching image assembly
# configuration (so that the contents of the two can be validated against).
#
# These will be used to validate that product assembly is operating correctly
# within the build, before we cut over to it.
#
# Parameters:
#
#   bundle_name [optional; default: legacy]
#     [string] A different name for the bundle, if not the name of the target.
#
#   kernel_zbi (optional; default: "//zircon/kernel")
#     [label] Label of the zircon kernel to use.  This needs to use the `images`
#     metadata key to provide the `path` and `name` fields (see the
#     build_api_module("images")` in `//BUILD.gn`).  The default value is most likely
#     the correct one.  This should only be overridden in special circumstances.
#
#   kernel_image_name (optional; default: "kernel")
#     [string] The image name of the 'kernel_zbi' as seen in images.json. This is used
#     as an override, that in conjunction with 'kernel_zbi' allows selecting a custom zbi
#     image as the kernel zbi.
#
#   bundles_dir [optional; default: target_out_dir]
#     [GN file path] path to a dir to use instead of $target_out_dir as the
#     parent of the legacy input bundle.
#
#   create_package [optional; default: false]
#     [bool] optionally create a package that contains the legacy assembly input
#      bundle
#
#   create_package_archive [optional; default: false]
#     [bool] optionally create an archive of the legacy assembly input bundle.
#     Implies that `create_package` is also true.
#
#   include_config_data [optional; default: true]
#     [bool] optionally omit the handling of config_data entries (for those
#     configurations that do not have a config_data package.
#
#   base_driver_packages [optional]
#     [list of labels] The driver packages to include in the base package set.
#
#   boot_driver_packages [optional]
#     [list of labels] The driver packages to include in the bootfs package set.
#
#   core_realm_definition [optional]
#     [label] The GN label of a `core_realm_definition()` template
#
#   use_assembly_fshost [optional; default: false]
#     [boolean] Whether to build the fshost component
#
#   fshost_config [optional; default: {}]
#     [scope] Arguments to add to fshost's configuration. These arguments come
#     before other arguments set by build args.
#
#   ramdisk_in_zbi [optional; default: false]
#     [boolean] Whether the FVM or Fxfs image should be embedded into the ZBI as
#     a ramdisk.
#
#   system_image_deps (optional)
#     [list of labels] The objects installed in the system image.
#
#   supports_blobs [required]
#     [bool] Whether blobs are supported on this product.
#
#   base_packages [required]
#     [list of labels] The set of base packages.
#
#   meta_packages [required]
#     [list of labels] The set of meta packages.
#
#   cache_packages [required]
#     [list of labels] The set of cache packages.
#
#   universe_packages [required]
#     [list of labels] The set of universe packages.
#
#   additional_boot_args [required]
#     [list of strings] Boot args to pass to the kernel.
#
#   bootfs_labels [required]
#     [list of labels] The set of labels to walk to find bootfs files.
#
template("legacy_assembly_input_bundle") {
  assert(
      current_toolchain == default_toolchain,
      "The legacy assembly input bundle can only be created in the default toolchain")

  assert(defined(invoker.supports_blobs), "Need to define supports_blobs")
  assert(defined(invoker.base_packages), "Need to define base_packages")
  assert(defined(invoker.meta_packages), "Need to define meta_packages")
  assert(defined(invoker.cache_packages), "Need to define cache_packages")
  assert(defined(invoker.universe_packages), "Need to define universe_packages")
  assert(defined(invoker.additional_boot_args),
         "Need to define additional_boot_args")
  assert(defined(invoker.bootfs_labels), "Need to define bootfs_labels")

  forward_variables_from(invoker,
                         [
                           "bundles_dir",
                           "bundle_name",
                           "create_package",
                           "create_package_archive",
                         ])

  kernel_zbi = "//zircon/kernel"
  if (defined(invoker.kernel_zbi)) {
    kernel_zbi = invoker.kernel_zbi
  }

  kernel_name = "kernel"
  if (defined(invoker.kernel_image_name)) {
    kernel_name = invoker.kernel_image_name
  }

  system_image_deps = []
  if (defined(invoker.system_image_deps) && invoker.supports_blobs) {
    system_image_deps += invoker.system_image_deps
  } else {
    not_needed(invoker, [ "system_image_deps" ])
  }

  if (!defined(bundles_dir)) {
    bundles_dir = target_out_dir
  }

  if (!defined(invoker.bundle_name)) {
    bundle_name = "legacy"
  }

  _include_config_data = true
  if (defined(invoker.include_config_data)) {
    _include_config_data = invoker.include_config_data
  }

  _base_driver_packages = []
  if (defined(invoker.base_driver_packages)) {
    _base_driver_packages = invoker.base_driver_packages
  }

  _boot_driver_packages = []
  if (defined(invoker.boot_driver_packages)) {
    _boot_driver_packages = invoker.boot_driver_packages
  }

  _shell_command_packages = []
  if (defined(invoker.shell_command_packages)) {
    _shell_command_packages = invoker.shell_command_packages
  }

  _core_realm_definition = false
  if (defined(invoker.core_realm_definition)) {
    _core_realm_definition = invoker.core_realm_definition
  }

  use_assembly_fshost =
      defined(invoker.use_assembly_fshost) && invoker.use_assembly_fshost

  labels = {
    image_assembly_config = "${target_name}.generated_image_assembly_config"
    bootfs_files = "${target_name}.bootfs_files"
    bootfs_files_package = "${target_name}.bootfs_files_package"

    # Compute the assembly config and config_data labels that are generated within
    # generated_image_assembly_config()
    assemble_system_config_data =
        "${image_assembly_config}.config-data_config_package_entries"

    # The AIB itself
    assembly_input_bundle = "$target_name.bundle"

    # The assembly bundle package and archive labels
    assembly_input_bundle_package = "${target_name}.pkg"
    assembly_input_bundle_archive = "${target_name}.tgz"
    base_driver_package_list =
        "${target_name}.package_manifest_list.base_drivers"
    driver_package_component_files =
        "${target_name}_driver_package_component_files"
    boot_driver_package_list =
        "${target_name}.package_manifest_list.boot_drivers"
    boot_driver_package_component_files =
        "${target_name}_boot_driver_package_component_files"
    shell_commands_manifest_list = "${target_name}.shell_commands_manifest_list"
    core_realm_shards_list = "${target_name}.core_realm_shards_list"
    core_realm_includes = "${target_name}.core_realm_includes"
    core_realm_default_includes = "${target_name}.core_realm_default_includes"
    core_realm_main_cml = "${target_name}.core_realm_main_cml"
    fshost = "${target_name}.fshost"
  }

  files = {
    image_assembly_config =
        "$target_out_dir/${labels.image_assembly_config}.json"
    bootfs_files_package =
        "$target_out_dir/${labels.bootfs_files_package}/package_manifest.json"
    assemble_system_config_data_entries = "$target_out_dir/${labels.image_assembly_config}.config-data_config_package_entries"

    # Outputs

    # The directory where all the bundle contents are written to
    assembly_input_bundle_dir = "${bundles_dir}/${bundle_name}"

    # The "official" outputs file that we create in that directory
    assembly_input_bundle_config =
        "${assembly_input_bundle_dir}/assembly_config.json"

    # The files that we create as book-keeping between our tasks.
    assembly_input_bundle_depfile = "${assembly_input_bundle_dir}.d"

    # The manifest of all files in the AIB, used to create pkgs and archives.
    assembly_input_bundle_manifest =
        "${assembly_input_bundle_dir}.fini_manifest"

    # The AIB package's meta.far (optionally used)
    assembly_input_bundle_package_metafar =
        "${assembly_input_bundle_dir}.pkg/meta.far"

    # The AIB archive and the manifest used to create it (optionally used)
    assembly_input_bundle_archive = "${assembly_input_bundle_dir}.tgz"
    assembly_input_bundle_archive_manifest =
        "${assembly_input_bundle_dir}.tgz.fini_manifest"
    base_driver_package_list =
        "${assembly_input_bundle_dir}.package_manifest_list.drivers"
    driver_package_component_files =
        "${target_gen_dir}/${target_name}.driver_package_component_files"
    boot_driver_package_list =
        "${assembly_input_bundle_dir}.package_manifest_list.boot_drivers"
    boot_driver_package_component_files =
        "${target_gen_dir}/${target_name}.boot_driver_package_component_files"
    shell_command_manifests_list =
        "${assembly_input_bundle_dir}.package_manifest_list.shell_commands"
    core_realm_shards_list =
        "${assembly_input_bundle_dir}.core_realm_shards_list"
    core_realm_includes = "${assembly_input_bundle_dir}.core_realm_includes"

    # The cmc_merge() template this is used with prepends $target_out_dir.
    fshost_merged_cml = "${target_name}/fshost.merged.cml"
  }

  package_manifests_list(labels.base_driver_package_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    filename = files.base_driver_package_list
    deps = _base_driver_packages
  }

  generated_file(labels.driver_package_component_files) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                           ])
    deps = _base_driver_packages
    outputs = [ "${files.driver_package_component_files}" ]
    data_keys = [ "driver_package_component_files" ]
    walk_keys = [ "driver_package_component_files_barrier" ]
    output_conversion = "json"
  }

  package_manifests_list(labels.boot_driver_package_list) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    filename = files.boot_driver_package_list
    deps = _boot_driver_packages
  }

  generated_file(labels.boot_driver_package_component_files) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                           ])
    deps = _boot_driver_packages
    outputs = [ "${files.boot_driver_package_component_files}" ]
    data_keys = [ "boot_driver_package_component_files" ]
    walk_keys = [ "boot_driver_package_component_files_barrier" ]
    output_conversion = "json"
  }

  if (_shell_command_packages != []) {
    generated_file(labels.shell_commands_manifest_list) {
      forward_variables_from(invoker,
                             [
                               "deps",
                               "testonly",
                             ])
      deps = _shell_command_packages
      outputs = [ "${files.shell_command_manifests_list}" ]
      data_keys = [ "shell_commands_distribution_manifests" ]
      walk_keys = [ "shell_commands_barrier" ]
      output_conversion = "json"
    }
  }

  if (_core_realm_definition != false) {
    # Legacy list of includes used by core realm shards.
    core_shard_includes = [
      "//src/intl/intl_services/meta/intl.core_shard.base.cml",
      "//src/media/audio/audio_core/meta/audio_core.core_shard.base.cml",
      "//src/settings/service/meta/setui_service_base.core_shard.cml",
      "//src/testing/sl4f/meta/sl4f.core_shard.cml",
      "//src/testing/sl4f/meta/sl4f_base.core_shard.cml",
      "//src/recovery/system/meta/core_shards/base.shard.cml",
      "//src/recovery/system/meta/core_shards/ui.shard.cml",

      # Required for workstation
      "//src/connectivity/bluetooth/profiles/bt-a2dp/meta/bt-a2dp-common.core_shard.cml",
      "//src/session/bin/session_manager/meta/all_products_capabilities.core_shard.cml",
      "//src/session/bin/session_manager/meta/some_products_capabilities.core_shard.cml",
      "//src/session/bin/session_manager/meta/terminal_capabilities.core_shard.cml",
      "//src/ui/meta/ui_routes_base.shard.cml",
      "//src/session/bin/session_manager/meta/session.smart.from_platform.core_shard.cml",
      "//src/security/bin/tee_manager/meta/tee_manager.core_shard.base.cml",
    ]

    # Include the default core cml in the legacy AIB
    group(labels.core_realm_main_cml) {
      forward_variables_from(invoker, [ "testonly" ])
      deps = []
      metadata = {
        shard_files =
            [ rebase_path("//src/sys/core/meta/core.cml", root_build_dir) ]
      }
    }

    generated_file(labels.core_realm_shards_list) {
      forward_variables_from(invoker, [ "testonly" ])
      deps = [
        ":${labels.core_realm_main_cml}",
        "${_core_realm_definition}",
      ]
      data_keys = [ "shard_files" ]
      outputs = [ "${files.core_realm_shards_list}" ]
      output_conversion = "json"
    }

    # Include files needed by the default core cml in the legacy AIB
    # The source of a core realm include file is its location
    # relative to the root_build_dir, while the destination
    # is its location relative to the fuchsia root.
    # Assembly doesn't know about the fuchsia root but components reference
    # absolute includes relative to the fuchsia root dir, so we lay them
    # out in the AIB in the same way they are laid out in fuchsia.git.
    group(labels.core_realm_default_includes) {
      forward_variables_from(invoker, [ "testonly" ])
      metadata = {
        shard_includes = [
          {
            #TODO(115630): Add the sdk directory to the include paths
            source = rebase_path("//sdk/lib/syslog/offer.shard.cml")
            destination = "syslog/offer.shard.cml"
          },
          {
            #TODO(115630): Add the sdk directory to the include paths
            source = rebase_path("//sdk/lib/inspect/offer.shard.cml")
            destination = "inspect/offer.shard.cml"
          },
        ]

        foreach(core_shard_include, core_shard_includes) {
          shard_includes += [
            {
              source = rebase_path(core_shard_include, root_build_dir)
              destination = rebase_path(core_shard_include, "//")
            },
          ]
        }
      }
    }

    generated_file(labels.core_realm_includes) {
      forward_variables_from(invoker, [ "testonly" ])
      deps = [
        ":${labels.core_realm_default_includes}",
        "${_core_realm_definition}",
      ]
      data_keys = [ "shard_includes" ]
      outputs = [ "${files.core_realm_includes}" ]
      output_conversion = "json"
    }
  }

  component_id_index_dep = []
  component_id_index_config_data_dep = []
  include_component_index = defined(invoker.include_component_id_index) &&
                            invoker.include_component_id_index
  if (include_component_index) {
    # For details, see //docs/development/components/component_id_index.md#system-assembly
    component_id_index_config("${target_name}.component_id_index_config") {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])

      # collect and merge component ID indices from the base set.
      deps = invoker.base_packages

      metadata = {
        package_barrier = []
      }
    }

    component_id_index_dep = [ ":${target_name}.component_id_index_config" ]
    component_id_index_config_data_dep =
        [ ":${target_name}.component_id_index_config-config-data" ]
  } else {
    not_needed([ "component_id_index_config_data_dep" ])
  }

  create_package_archive =
      defined(invoker.create_package_archive) && invoker.create_package_archive
  create_package = create_package_archive ||
                   (defined(invoker.create_package) && invoker.create_package)

  generated_image_assembly_config(labels.image_assembly_config) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    kernel_image = kernel_zbi
    kernel_image_name = kernel_name

    base_packages = []
    if (invoker.supports_blobs) {
      base_packages = invoker.base_packages
      base_packages += invoker.meta_packages
      cache_packages = invoker.cache_packages
    } else {
      not_needed(invoker, [ "meta_packages" ])
    }

    include_config_data = _include_config_data
    config_data_packages =
        invoker.base_packages + invoker.universe_packages +
        invoker.cache_packages + component_id_index_config_data_dep

    boot_args = invoker.additional_boot_args

    # Search for BootFS packages in these targets.
    bootfs_package_labels = []
    if (defined(invoker.bootfs_package_labels)) {
      bootfs_package_labels += invoker.bootfs_package_labels
    }

    extra_base_deps = system_image_deps

    # Search for the Kernel cmdline in the BootFS dependencies.
    cmdline_deps = invoker.bootfs_labels
    if (defined(invoker.cmdline_deps)) {
      cmdline_deps += invoker.cmdline_deps
    }
    if (defined(invoker.cmdline)) {
      cmdline = invoker.cmdline
    }
  }

  # Compile the fshost component and configuration needed for this assembly
  fshost_component_and_config(labels.fshost) {
    # THIS CANNOT BE MARKED TESTONLY, EVEN IF THE ASSEMBLY IS.  This template
    # changes behavior to create a non-bootable fshost if testonly is set to
    # true.
    testonly = false

    # Correct the component name since the target_name is per-image.
    component_name = "fshost"

    # This is picked up by the `cmc_merge()` within `fshost_cml()`, through its
    # use of foward_variables_from(invoker, ["output_name" ...]).
    output_name = files.fshost_merged_cml

    options = {
      # Use the defaults from the build args set in generated_fshost_config.gni
      data_filesystem_format = data_filesystem_format
      use_disk_migration = use_disk_migration

      if (defined(invoker.fshost_config)) {
        # Override with anything passed from `fshost_config`
        forward_variables_from(invoker.fshost_config, "*")
      }

      # Always set ramdisk_image if the assmebled ZBI contains a ramdisk.
      if (defined(invoker.ramdisk_in_zbi) && invoker.ramdisk_in_zbi) {
        ramdisk_image = true
      }

      fxfs_blob = fxfs_blob
      fxfs_vmex = fxfs_blob
    }
  }

  # Search for BootFS files in these targets.
  bootfs_files_for_assembly(labels.bootfs_files) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    deps = invoker.bootfs_labels + component_id_index_dep + [ kernel_zbi ]
    if (!use_assembly_fshost) {
      deps += [ ":${labels.fshost}" ]
    }
  }

  fuchsia_package(labels.bootfs_files_package) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    deps = [ ":${labels.bootfs_files}" ]
  }

  # Run the script that creates the out-of-tree-usable Assembly Input Bundle from
  # an Image Assembly product configuration and the config_data package entries
  # that go with it.
  python_action(labels.assembly_input_bundle) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])

    binary_label = "//build/assembly/scripts:make_legacy_config"

    # The contents of these folders is dynamic, and managed entirely by this
    # action.  Further, this action will need to delete items from these
    # directories that are not added back (on an incremental build, if an item
    # is removed from one of these sets)
    #
    # These folders would grow in size forever, if it was not cleaned out on
    # each incremental build.
    hermetic_action_ignored_prefixes = [
      "${files.assembly_input_bundle_dir}/packages",
      "${files.assembly_input_bundle_dir}/subpackages",
      "${files.assembly_input_bundle_dir}/blobs",
      "${files.assembly_input_bundle_dir}/config_data",
      "${files.assembly_input_bundle_dir}/bootfs",
      "${files.assembly_input_bundle_dir}/kernel",
      "${files.assembly_input_bundle_dir}/compiled_packages",
    ]

    outputs = [ files.assembly_input_bundle_config ]
    depfile = files.assembly_input_bundle_depfile
    args = [
      "--image-assembly-config",
      rebase_path(files.image_assembly_config, root_build_dir),
      "--outdir",
      rebase_path(files.assembly_input_bundle_dir, root_build_dir),
      "--depfile",
      rebase_path(files.assembly_input_bundle_depfile, root_build_dir),
      "--base-driver-packages-list",
      rebase_path(files.base_driver_package_list, root_build_dir),
      "--base-driver-components-files-list",
      rebase_path(files.driver_package_component_files, root_build_dir),
      "--bootfs-files-package",
      rebase_path(files.bootfs_files_package, root_build_dir),
      "--boot-driver-packages-list",
      rebase_path(files.boot_driver_package_list, root_build_dir),
      "--boot-driver-components-files-list",
      rebase_path(files.boot_driver_package_component_files, root_build_dir),
    ]

    # If packaging or archiving the AIB, write out the fini manifest needed to
    # do so.
    if (create_package || create_package_archive) {
      args += [
        "--export-manifest",
        rebase_path(files.assembly_input_bundle_manifest, root_build_dir),
      ]
      outputs += [ files.assembly_input_bundle_manifest ]
    }

    inputs = [
      files.base_driver_package_list,
      files.driver_package_component_files,
      files.image_assembly_config,
      files.bootfs_files_package,
      files.boot_driver_package_list,
      files.boot_driver_package_component_files,
    ]

    deps = [
      ":${labels.base_driver_package_list}",
      ":${labels.boot_driver_package_component_files}",
      ":${labels.boot_driver_package_list}",
      ":${labels.bootfs_files_package}",
      ":${labels.driver_package_component_files}",
      ":${labels.image_assembly_config}",
    ]

    if (_shell_command_packages != []) {
      args += [
        "--shell-commands-packages-list",
        rebase_path(files.shell_command_manifests_list, root_build_dir),
      ]
      inputs += [ files.shell_command_manifests_list ]
      deps += [ ":${labels.shell_commands_manifest_list}" ]
    }

    if (_core_realm_definition != false) {
      args += [
        "--core-realm-shards-list",
        rebase_path(files.core_realm_shards_list, root_build_dir),
        "--core-realm-includes-list",
        rebase_path(files.core_realm_includes, root_build_dir),
      ]

      inputs += [
        files.core_realm_shards_list,
        files.core_realm_includes,
      ]
      deps += [
        ":${labels.core_realm_includes}",
        ":${labels.core_realm_shards_list}",
      ]
    }

    if (_include_config_data) {
      args += [
        "--config-data-entries",
        rebase_path(files.assemble_system_config_data_entries, root_build_dir),
      ]
      inputs += [ files.assemble_system_config_data_entries ]
      deps += [ ":${labels.assemble_system_config_data}" ]
    }

    metadata = {
      # We insert these barriers to prevent the dependencies of the input bundle
      # from leaking into images "higher up" in the dependency chain.
      package_barrier = []
      config_package_barrier = []
      distribution_entries_barrier = []
    }
  }

  if (create_package) {
    assembly_input_bundle_package(labels.assembly_input_bundle_package) {
      forward_variables_from(invoker, [ "testonly" ])
      package_name = bundle_name
      package_outdir = "${bundles_dir}/${bundle_name}.pkg"
      manifest = files.assembly_input_bundle_manifest
      deps = [ ":${labels.assembly_input_bundle}" ]
    }
  }

  if (create_package_archive) {
    assembly_input_bundle_archive(labels.assembly_input_bundle_archive) {
      forward_variables_from(invoker, [ "testonly" ])
      archive_name = bundle_name
      archive_outdir = bundles_dir
      manifest = files.assembly_input_bundle_manifest
      deps = [ ":${labels.assembly_input_bundle}" ]

      # If the package was created, include it in the archive.
      if (create_package) {
        meta_far = files.assembly_input_bundle_package_metafar
        deps += [ ":${labels.assembly_input_bundle_package}" ]
      }
    }
  }

  group(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    public_deps = [ ":${labels.assembly_input_bundle}" ]
    if (create_package) {
      public_deps += [ ":${labels.assembly_input_bundle_package}" ]
    }
    if (create_package_archive) {
      public_deps += [ ":${labels.assembly_input_bundle_archive}" ]
    }
  }
}
