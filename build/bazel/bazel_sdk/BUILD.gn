# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/bazel/bazel_fuchsia_sdk.gni")
import("//build/sdk/config.gni")
import("//build/sdk/generate_final_idk.gni")
import("//build/sdk/sdk_collection.gni")

# The list of target cpu architectures supported by @fuchsia_sdk.
if (bazel_fuchsia_sdk_all_cpus) {
  _fuchsia_sdk_target_cpus = idk_target_cpus
} else {
  _fuchsia_sdk_target_cpus = [ target_cpu ]
}

# Ensure that the //build/bazel/bazel_sdk:idk.exported target
# populates `$OUTPUT_DIR/sdk/exported/bazel_fuchsia_sdk_idk`.
#
generate_final_idk("idk") {
  output_name = "bazel_fuchsia_sdk_idk"
  sdk_target_labels = bazel_fuchsia_sdk_deps
  target_cpus = _fuchsia_sdk_target_cpus

  if (bazel_fuchsia_sdk_content != "core") {
    # Never include binaries from previous API levels when not using the
    # "core" set of SDK atom collections to generate this IDK. This is
    # necessary because many atoms in the "driver" set cannot compile
    # on older API levels.
    extra_api_levels = []
  }
}

# Run the //build/bazel_sdk/tests/scripts/bazel_test.sh
# script, which runs the test suite for the Fuchsia Bazel
# SDK rules, using the IDK built from the platform build
# as well as the prebuilt Clang in the Fuchsia source
# checkout.
#
# Note that this does not use bazel_action() because:
#
#  1) The test suite is run in its own Bazel workspace,
#     completely separate from the one used by the platform
#     build.
#
#  2) bazel_action() may change the target build configuration
#     in ways that are not supported by the test suite, for
#     example, changing `is_debug` or `optimize` in args.gn may
#     change Bazel output paths, which will fail tests that rely
#     on golden file that embeds hard-coded versions of them.
#
#  3) There is no way to list all inputs / outputs properly.
#
# Arguments:
#    target_cpu: (optional)
#       Target cpu name. Default to current_cpu otherwise.
#
#    idk_exported_dir: (optional)
#       GN path to an IDK `exported` directory to use to run the
#       test suite. Requires `idk_exported_target` to be set as well.
#
#    idk_exported_target: (optional)
#       GN label of target used to generate the directory pointed to by
#       `idk_exported_dir`, if provided.
#
template("bazel_sdk_tests_for") {
  _use_idk_exported = defined(invoker.idk_exported_path)
  if (_use_idk_exported) {
    _idk_exported_path = invoker.idk_exported_path
    _idk_exported_target = invoker.idk_exported_target
  }

  _target_cpu = target_cpu
  if (defined(invoker.target_cpu)) {
    _target_cpu = invoker.target_cpu
  }

  action(target_name) {
    testonly = true
    script = "//build/bazel_sdk/tests/scripts/bazel_test.py"
    inputs = [ "//prebuilt/third_party/bazel/${host_os}-${host_cpu}/bazel" ]
    outputs = [ "$target_gen_dir/$target_name.stamp" ]
    depfile = "$target_gen_dir/$target_name.d"

    # Provide a distinct output_base for each test. This is because the
    # fuchsia_sdk_repository() rule call does not use a version file in
    # //build/bazel_sdk/tests/WORKSPACE.bazel, and the content of @fuchsia_sdk
    # will not be regenerated when we change the target cpu architecture.
    #
    # For example (assuming a shared output_base directory):
    #
    #   fx clean
    #
    #   # This populates @fuchsia_sdk//:generated_constants.bzl with
    #   # constants = struct(host_cpus = ["x64"], target_cpus = ["x64"])
    #   # the test suite passes though.
    #   #
    #   fx build bazel_sdk_tests
    #
    #   # This does not regenerate @fuchsia_sdk//:generated_constants.bzl
    #   # but the test suite passes because it has the right target_cpus list.
    #   #
    #   fx build bazel_sdk_tests_idk_x64
    #
    #   # This does not regenerate @fuchsia_sdk//:generated_constants.bzl
    #   # And Bazel complains there is not C++ toolchain for arm64 because
    #   # register_clang_toolchains() uses the content of constants.target_cpus
    #   # to declare C++ toolchains, and that one does not include an "arm64"
    #   # item, even though the IDK provides all the necessary prebuilt
    #   # binaries for it.
    #   #
    #   fx build bazel_sdk_tests_idk_arm64
    #
    #
    _output_base = "${target_gen_dir}/${target_name}/output_base"
    _output_user_root = "${target_gen_dir}/${target_name}/output_user_root"

    args = [
      "--verbose",
      "--fuchsia_source_dir=" + rebase_path("//", root_build_dir),
      "--output_base=" + rebase_path(_output_base, root_build_dir),
      "--output_user_root=" + rebase_path(_output_user_root, root_build_dir),
      "--target_cpu=${_target_cpu}",
      "--bazel=" + rebase_path(inputs[0], root_build_dir),
      "--stamp-file=" + rebase_path(outputs[0], root_build_dir),
      "--depfile=" + rebase_path(depfile, root_build_dir),
      "--quiet",
    ]
    if (_use_idk_exported) {
      args += [
        "--fuchsia_idk_directory",
        rebase_path(_idk_exported_path, root_build_dir),
      ]
      deps = [ _idk_exported_target ]
    } else {
      args += [
        "--fuchsia_build_dir",
        rebase_path(root_build_dir, root_build_dir),
      ]
      deps = [ "//build/bazel:generate_fuchsia_sdk_repository" ]
    }
    pool = "//:console"
    hermetic_deps = false
    no_output_dir_leaks = true
  }
}

# Do not define the following targets in final_fuchsia_idk sub-builds to
# avoid dependency recursion issues!
if (!sdk_inside_idk_sub_build) {
  foreach(cpu, _fuchsia_sdk_target_cpus) {
    # Run the test suite against the internal IDK used to populate
    # @fuchsia_sdk, for the current target cpu only.
    bazel_sdk_tests_for("bazel_sdk_tests_${cpu}") {
      target_cpu = cpu
    }
  }

  # Run the test suite against hte internal IDK used to populate
  # @fuchsia_sdk, once per supported target CPU architecture, if
  # bazel_fuchsia_sdk_all_cpus is set, otherwise only against
  # the current target_cpu value.
  group("bazel_sdk_tests") {
    testonly = true
    deps = []
    foreach(cpu, _fuchsia_sdk_target_cpus) {
      deps += [ ":bazel_sdk_tests_${cpu}" ]
    }
  }

  foreach(cpu, idk_target_cpus) {
    # This target runs the test suite against a locally-generated IDK
    # (which includes support for all target architectures), but only
    # for target_cpu. E.g. `bazel_sdk_tests_arm64` will run the
    # test suite with a build configuration that generates Fuchsia/arm64
    # binaries.
    #
    # Note that the IDK does _not_ contain //sdk:driver atoms.
    # (see //sdk:final_fuchsia_idk definition for details).
    bazel_sdk_tests_for("bazel_sdk_tests_idk_${cpu}") {
      target_cpu = cpu
      idk_exported_path = "$root_build_dir/sdk/exported/fuchsia_idk"
      idk_exported_target = "//sdk:final_fuchsia_idk.exported"
    }
  }

  # This target runs the test suite against each target architecture
  # supported by the IDK. Currently, this runs multiple instances of
  # the test suite, one per target cpu.
  group("bazel_sdk_tests_idk") {
    testonly = true
    deps = []
    foreach(cpu, idk_target_cpus) {
      deps += [ ":bazel_sdk_tests_idk_${cpu}" ]
    }
  }
}

group("tests") {
  testonly = true
  if (!sdk_inside_idk_sub_build) {
    deps = [
      ":bazel_sdk_tests",
      # DO NOT INCLUDE bazel_sdk_tests_idk here to avoid making all core builds
      # longer than necessary (https://fxbug.dev/132279). It is still possible
      # to invoke the target manually during local development though.
      # ":bazel_sdk_tests_idk",
    ]
  }
}
