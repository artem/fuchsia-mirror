# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Implement fuchsia_prebuilt_package() rule."""

load("@bazel_skylib//rules:select_file.bzl", "select_file")
load("//fuchsia/private/workflows:fuchsia_task_publish.bzl", "fuchsia_task_publish")
load(":providers.bzl", "FuchsiaComponentInfo", "FuchsiaPackageInfo", "FuchsiaPackagedComponentInfo")

def _relative_file_name(ctx, filename):
    return ctx.label.name + "_expanded/" + filename

def _unpack_prebuilt_package_impl(ctx):
    sdk = ctx.toolchains["@fuchsia_sdk//fuchsia:toolchain"]
    far_archive = ctx.files.archive[0]
    output_files = [far_archive]

    # where we will collect all of the temporary files
    pkg_dir = ctx.label.name + "_pkg/"

    # An environment variable that creates an isolated FFX instance.
    ffx_isolate_dir = ctx.actions.declare_directory(pkg_dir + "_package.ffx")

    # Technical note: `ffx package archive extract` below will populate its
    # output directory with multiple files whose name are content hashes and
    # cannot be known in advance, so use ctx.actions.declare_directory() to
    # declare an output directory for the expansion. This tells Bazel that all
    # files present in the directory after the command execution are outputs,
    # and should be copied from the sandbox to the corresponding final output
    # location in the output_base directory (otherwise, they would disappear
    # once the sandbox is destroyed).
    #
    # The top-level directory for this target will be computed from
    # `${label}_expanded/`, which, for a label like `//package/foo:bar`
    # will expand to something like this (relative to the sandbox execroot):
    #
    # `bazel-out/aarch64-opt/bin/package/foo/bar/bar_expanded`
    #
    # Inside this TARGET_OUT_DIR, the following is generated:
    #
    #   $TARGET_OUT_DIR/
    #       content/
    #          A directory that contains the expanded content from the
    #          prebuilt package, as well as a `package_manifest.json` file
    #          that lists all entries, where source paths appear relative
    #          to the execroot too, e.g.:
    #
    #           "blobs": [
    #             {
    #               "source_path": "bazel-out/aarch64-opt/bin/package/foo/bar/bar_expanded/_content/meta.far",
    #               "path": "meta/",
    #               "merkle": "d0d73e04d89e393b71f2280831421ebe279e247265e25714c71fdc8961928822",
    #               "size": 94288,
    #             },
    #             ...
    #
    #       rebased_package_manifest.json
    #          A version of _content/package_manifest.json that contains
    #          source paths that are relative to an alternative `artifacts_base_path`
    #          value. However, since the default value for this argument is just '.',
    #          it will have the same content as `_content/package_manifest.json` in
    #          most cases.
    #
    #          Note that this file _cannot_ be inside `_content`, as Bazel
    #          would complain otherwise, as it is generated by a different action
    #          than the one that generated `_content/`.
    #
    #       <component>_stamp
    #          For each component listed in ctx.attr.components or
    #          ctx.attr.drivers, a stamp file generated by the action that
    #          verifies it belongs to the package.
    #
    output_dir = ctx.actions.declare_directory(_relative_file_name(ctx, "content"))
    output_files.append(output_dir)

    # extract the package
    ctx.actions.run(
        executable = sdk.ffx_package,
        arguments = [
            "--isolate-dir",
            ffx_isolate_dir.path,
            "package",
            "archive",
            "extract",
            far_archive.path,
            "-o",
            output_dir.path,
            "--repository",
            "fuchsia.com",
        ],
        inputs = [far_archive],
        outputs = [
            output_dir,
            ffx_isolate_dir,
        ],
        mnemonic = "FuchsiaFfxPackageArchiveExtract",
        progress_message = "extracting the package for %{label}",
    )

    # rebase paths in package manifest
    rebased_package_manifest_json = ctx.actions.declare_file(_relative_file_name(ctx, "rebased_package_manifest.json"))
    ctx.actions.run(
        outputs = [rebased_package_manifest_json],
        inputs = [output_dir],
        executable = ctx.executable._rebase_package_manifest,
        arguments = [
            "--package-manifest",
            output_dir.path + "/package_manifest.json",
            "--updated-package-manifest",
            rebased_package_manifest_json.path,
        ],
    )
    output_files.append(rebased_package_manifest_json)

    return [
        DefaultInfo(files = depset(output_files)),
        FuchsiaPackageInfo(
            package_manifest = rebased_package_manifest_json,
            far_file = ctx.files.archive,
            packaged_components = [
                                      FuchsiaPackagedComponentInfo(
                                          dest = d,
                                          component_info = FuchsiaComponentInfo(
                                              is_driver = True,
                                              is_test = False,
                                          ),
                                      )
                                      for d in ctx.attr.drivers
                                  ] +
                                  [
                                      FuchsiaPackagedComponentInfo(
                                          dest = c,
                                          component_info = FuchsiaComponentInfo(
                                              is_driver = False,
                                              is_test = False,
                                          ),
                                      )
                                      for c in ctx.attr.components
                                  ],
            files = output_files,
        ),
    ]

_unpack_prebuilt_package = rule(
    doc = """Provides access to a fuchsia package from a prebuilt package archive (.far).
""",
    implementation = _unpack_prebuilt_package_impl,
    toolchains = ["@fuchsia_sdk//fuchsia:toolchain"],
    attrs = {
        "archive": attr.label(
            doc = "The fuchsia archive",
            allow_single_file = True,
            mandatory = True,
        ),
        "components": attr.string_list(
            doc = "components of this driver",
            default = [],
        ),
        "drivers": attr.string_list(
            doc = "drivers of this driver",
            default = [],
        ),
        "_rebase_package_manifest": attr.label(
            default = "//fuchsia/tools:rebase_package_manifest",
            executable = True,
            cfg = "exec",
        ),
    },
)

def _pack_prebuilt_package_impl(ctx):
    sdk = ctx.toolchains["@fuchsia_sdk//fuchsia:toolchain"]

    # Inputs
    manifest = ctx.files.manifest[0]
    input_files = ctx.files.files

    # Outputs
    far_file = ctx.actions.declare_file("%s.far" % ctx.attr.name)
    output_files = [far_file, manifest]

    # An environment variable that creates an isolated FFX instance.
    ffx_isolate_dir = ctx.actions.declare_directory(ctx.label.name + "_pkg/_package.ffx")

    # Create the far file.
    ctx.actions.run(
        executable = sdk.ffx_package,
        arguments = [
            "--isolate-dir",
            ffx_isolate_dir.path,
            "package",
            "archive",
            "create",
            manifest.path,
            "-o",
            far_file.path,
        ],
        inputs = input_files,
        outputs = [far_file, ffx_isolate_dir],
        mnemonic = "FuchsiaFfxPackageArchiveCreate",
        progress_message = "Archiving package for %{label}",
    )

    return [
        DefaultInfo(files = depset(output_files)),
        FuchsiaPackageInfo(
            package_manifest = manifest,
            far_file = far_file,
            packaged_components = [FuchsiaPackagedComponentInfo(dest = d, component_info = FuchsiaComponentInfo(is_driver = True, is_test = False)) for d in ctx.attr.drivers] +
                                  [FuchsiaPackagedComponentInfo(dest = c, component_info = FuchsiaComponentInfo(is_driver = False, is_test = False)) for c in ctx.attr.components],
            files = output_files + input_files,
        ),
    ]

_pack_prebuilt_package = rule(
    doc = """Provides access to a fuchsia package from a package manifest.
""",
    implementation = _pack_prebuilt_package_impl,
    toolchains = ["@fuchsia_sdk//fuchsia:toolchain"],
    attrs = {
        "manifest": attr.label(
            doc = "The package's manifest file",
            allow_single_file = True,
            mandatory = True,
        ),
        "files": attr.label_list(
            doc = "Files that are part of the package.",
            allow_files = True,
            mandatory = True,
        ),
        "components": attr.string_list(
            doc = "components of this driver",
            default = [],
        ),
        "drivers": attr.string_list(
            doc = "drivers of this driver",
            default = [],
        ),
    },
)

# buildifier: disable=function-docstring
def fuchsia_prebuilt_package(*, name, archive = None, manifest = None, files = [], components = [], drivers = [], **kwargs):
    if (archive and files) or bool(archive) == bool(manifest):
        fail("Must specify exactly either `archive` or `manifest + files`.")
    if archive:
        _unpack_prebuilt_package(
            name = name,
            archive = archive,
            components = components,
            drivers = drivers,
            **kwargs
        )
    else:
        _pack_prebuilt_package(
            name = name,
            manifest = manifest,
            files = files,
            components = components,
            drivers = drivers,
            **kwargs
        )

        select_file(
            name = name + ".far",
            srcs = ":" + name,
            subpath = name + ".far",
        )

    fuchsia_task_publish(
        name = "%s.publish" % name,
        packages = [name],
        **kwargs
    )
