# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Implement fuchsia_prebuilt_package() rule."""

load("//fuchsia/private/workflows:fuchsia_package_tasks.bzl", "fuchsia_package_tasks")
load(":providers.bzl", "FuchsiaComponentInfo", "FuchsiaDebugSymbolInfo", "FuchsiaPackageInfo", "FuchsiaPackagedComponentInfo")
load("@bazel_skylib//rules:select_file.bzl", "select_file")

def _relative_file_name(ctx, filename):
    return ctx.label.name + "_expanded/" + filename

def _component_basename(cm_str):
    return cm_str.rpartition("/")[-1].removesuffix(".cm")

def _make_component_info(ctx):
    return [
        FuchsiaPackagedComponentInfo(
            dest = c,
            component_info = FuchsiaComponentInfo(
                name = _component_basename(c),
                is_driver = False,
                is_test = False,
                run_tag = _component_basename(c),
            ),
        )
        for c in ctx.attr.components
    ] + [
        FuchsiaPackagedComponentInfo(
            dest = d,
            component_info = FuchsiaComponentInfo(
                name = _component_basename(d),
                is_driver = True,
                is_test = False,
                run_tag = _component_basename(d),
            ),
        )
        for d in ctx.attr.drivers
    ] + [
        FuchsiaPackagedComponentInfo(
            dest = t,
            component_info = FuchsiaComponentInfo(
                name = _component_basename(t),
                is_driver = False,
                is_test = True,
                run_tag = _component_basename(t),
            ),
        )
        for t in ctx.attr.test_components
    ]

def _unpack_prebuilt_package_impl(ctx):
    sdk = ctx.toolchains["@fuchsia_sdk//fuchsia:toolchain"]
    far_archive = ctx.files.archive[0]
    output_files = [far_archive]

    # where we will collect all of the temporary files
    pkg_dir = ctx.label.name + "_pkg/"

    # An environment variable that creates an isolated FFX instance.
    ffx_isolate_dir = ctx.actions.declare_directory(pkg_dir + "_package.ffx")

    # Technical note: `ffx package archive extract` below will populate its
    # output directory with multiple files whose name are content hashes and
    # cannot be known in advance, so use ctx.actions.declare_directory() to
    # declare an output directory for the expansion. This tells Bazel that all
    # files present in the directory after the command execution are outputs,
    # and should be copied from the sandbox to the corresponding final output
    # location in the output_base directory (otherwise, they would disappear
    # once the sandbox is destroyed).
    #
    # The top-level directory for this target will be computed from
    # `${label}_expanded/`, which, for a label like `//package/foo:bar`
    # will expand to something like this (relative to the sandbox execroot):
    #
    # `bazel-out/aarch64-opt/bin/package/foo/bar/bar_expanded`
    #
    # Inside this TARGET_OUT_DIR, the following is generated:
    #
    #   $TARGET_OUT_DIR/
    #       content/
    #          A directory that contains the expanded content from the
    #          prebuilt package, as well as a `package_manifest.json` file
    #          that lists all entries, where source paths appear relative
    #          to the execroot too, e.g.:
    #
    #           "blobs": [
    #             {
    #               "source_path": "bazel-out/aarch64-opt/bin/package/foo/bar/bar_expanded/_content/meta.far",
    #               "path": "meta/",
    #               "merkle": "d0d73e04d89e393b71f2280831421ebe279e247265e25714c71fdc8961928822",
    #               "size": 94288,
    #             },
    #             ...
    #
    #       rebased_package_manifest.json
    #          A version of _content/package_manifest.json that contains
    #          source paths that are relative to an alternative `artifacts_base_path`
    #          value. However, since the default value for this argument is just '.',
    #          it will have the same content as `_content/package_manifest.json` in
    #          most cases.
    #
    #          Note that this file _cannot_ be inside `_content`, as Bazel
    #          would complain otherwise, as it is generated by a different action
    #          than the one that generated `_content/`.
    #
    #       <component>_stamp
    #          For each component listed in ctx.attr.components or
    #          ctx.attr.drivers, a stamp file generated by the action that
    #          verifies it belongs to the package.
    #
    output_dir = ctx.actions.declare_directory(_relative_file_name(ctx, "content"))
    output_files.append(output_dir)

    # extract the package
    ctx.actions.run(
        executable = sdk.ffx_package,
        arguments = [
            "--isolate-dir",
            ffx_isolate_dir.path,
            "package",
            "archive",
            "extract",
            far_archive.path,
            "-o",
            output_dir.path,
            "--repository",
            "fuchsia.com",
        ],
        inputs = [far_archive],
        outputs = [
            output_dir,
            ffx_isolate_dir,
        ],
        mnemonic = "FuchsiaFfxPackageArchiveExtract",
        progress_message = "extracting the package for %{label}",
    )

    # rebase paths in package manifest
    rebased_package_manifest_json = ctx.actions.declare_file(_relative_file_name(ctx, "rebased_package_manifest.json"))
    ctx.actions.run(
        outputs = [rebased_package_manifest_json],
        inputs = [output_dir],
        executable = ctx.executable._rebase_package_manifest,
        arguments = [
            "--package-manifest",
            output_dir.path + "/package_manifest.json",
            "--updated-package-manifest",
            rebased_package_manifest_json.path,
        ],
    )
    output_files.append(rebased_package_manifest_json)

    return [
        DefaultInfo(files = depset(output_files)),
        FuchsiaPackageInfo(
            package_manifest = rebased_package_manifest_json,
            far_file = far_archive,
            packaged_components = _make_component_info(ctx),
            files = output_files,
        ),
        # TODO(https://fxbug.dev/338180287): Add debug symbols support.
        FuchsiaDebugSymbolInfo(build_id_dirs = {}),
    ]

_unpack_prebuilt_package = rule(
    doc = """Provides access to a fuchsia package from a prebuilt package archive (.far).""",
    implementation = _unpack_prebuilt_package_impl,
    toolchains = ["@fuchsia_sdk//fuchsia:toolchain"],
    attrs = {
        "archive": attr.label(
            doc = "The fuchsia archive (typically a .far file).",
            allow_single_file = True,
            mandatory = True,
        ),
        "components": attr.string_list(
            doc = "ordinary components in this package",
            default = [],
        ),
        "drivers": attr.string_list(
            doc = "driver components in this package",
            default = [],
        ),
        "test_components": attr.string_list(
            doc = "test components in this package",
            default = [],
        ),
        "_rebase_package_manifest": attr.label(
            default = "//fuchsia/tools:rebase_package_manifest",
            executable = True,
            cfg = "exec",
        ),
    },
)

def _pack_prebuilt_package_impl(ctx):
    sdk = ctx.toolchains["@fuchsia_sdk//fuchsia:toolchain"]

    # Inputs
    manifest = ctx.files.manifest[0]
    input_files = ctx.files.files

    # Outputs
    far_file = ctx.actions.declare_file("%s.far" % ctx.attr.name)
    output_files = [far_file, manifest]

    # An environment variable that creates an isolated FFX instance.
    ffx_isolate_dir = ctx.actions.declare_directory(ctx.label.name + "_pkg/_package.ffx")

    # Create the far file.
    ctx.actions.run(
        executable = sdk.ffx_package,
        arguments = [
            "--isolate-dir",
            ffx_isolate_dir.path,
            "package",
            "archive",
            "create",
            manifest.path,
            "-o",
            far_file.path,
        ],
        inputs = input_files,
        outputs = [far_file, ffx_isolate_dir],
        mnemonic = "FuchsiaFfxPackageArchiveCreate",
        progress_message = "Archiving package for %{label}",
    )

    return [
        DefaultInfo(files = depset(output_files)),
        FuchsiaPackageInfo(
            package_manifest = manifest,
            far_file = far_file,
            packaged_components = _make_component_info(ctx),
            files = output_files + input_files,
        ),
        # TODO(https://fxbug.dev/338180287): Add debug symbols support.
        FuchsiaDebugSymbolInfo(build_id_dirs = {}),
    ]

_pack_prebuilt_package = rule(
    doc = """Provides access to a fuchsia package from a package manifest.""",
    implementation = _pack_prebuilt_package_impl,
    toolchains = ["@fuchsia_sdk//fuchsia:toolchain"],
    attrs = {
        "manifest": attr.label(
            doc = "The package's manifest file",
            allow_single_file = True,
            mandatory = True,
        ),
        "files": attr.label_list(
            doc = "Files that are part of the package.",
            allow_files = True,
            mandatory = True,
        ),
        "components": attr.string_list(
            doc = "ordinary components in this package",
            default = [],
        ),
        "drivers": attr.string_list(
            doc = "driver components in this package",
            default = [],
        ),
        "test_components": attr.string_list(
            doc = "test components in this package",
            default = [],
        ),
    },
)

def _make_prebuilt_package(
        *,
        name,
        archive,
        manifest,
        files,
        components = [],
        drivers = [],
        test_components = [],
        **kwargs):
    if (archive and files) or bool(archive) == bool(manifest):
        fail("Must specify exactly either `archive` or `manifest + files`.")
    if archive:
        _unpack_prebuilt_package(
            name = "%s_fuchsia_package" % name,
            archive = archive,
            drivers = drivers,
            components = components,
            test_components = test_components,
            **kwargs
        )
    else:
        _pack_prebuilt_package(
            name = "%s_fuchsia_package" % name,
            manifest = manifest,
            files = files,
            drivers = drivers,
            components = components,
            test_components = test_components,
            **kwargs
        )

        select_file(
            name = name + ".far",
            srcs = ":%s_fuchsia_package" % name,
            subpath = "%s_fuchsia_package.far" % name,
            **kwargs
        )

# buildifier: disable=function-docstring
def fuchsia_prebuilt_package(
        *,
        name,
        archive = None,
        manifest = None,
        files = [],
        components = [],
        drivers = [],
        **kwargs):
    _make_prebuilt_package(
        name = name,
        archive = archive,
        manifest = manifest,
        files = files,
        components = components,
        drivers = drivers,
        **kwargs
    )

    fuchsia_package_tasks(
        name = name,
        package = "%s_fuchsia_package" % name,
        component_run_tags = [_component_basename(c) for c in components + drivers],
        **kwargs
    )

# buildifier: disable=function-docstring
def fuchsia_prebuilt_test_package(
        *,
        name,
        archive = None,
        manifest = None,
        files = [],
        test_components = [],
        test_realm = None,
        **kwargs):
    _make_prebuilt_package(
        name = name,
        archive = archive,
        manifest = manifest,
        files = files,
        test_components = test_components,
        testonly = True,
        **kwargs
    )

    fuchsia_package_tasks(
        name = name,
        package = "%s_fuchsia_package" % name,
        component_run_tags = [_component_basename(c) for c in test_components],
        is_test = True,
        enumerate_test_components = True,
        test_realm = test_realm,
        testonly = True,
        **kwargs
    )
