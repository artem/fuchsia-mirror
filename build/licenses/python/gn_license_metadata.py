#!/usr/bin/env fuchsia-vendored-python
# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Holders for license-related GN metadata dictionaries."""

import json
import dataclasses
import logging
from pathlib import Path
from typing import Dict, Tuple
from gn_label import GnLabel


@dataclasses.dataclass(frozen=True)
class GnLicenseMetadata:
    """Metadata produced by //build/licenses/license.gni template"""

    target_label: GnLabel
    public_package_name: str
    license_files: Tuple[GnLabel]

    def is_license_metadata_dict(dict) -> bool:
        return "license_files" in dict

    def from_json_dict(dict) -> "GnLicenseMetadata":
        target_label = GnLabel.from_str(dict["target_label"])
        assert (
            target_label.toolchain
        ), f"Label must have a toolchain part: {target_label}"

        public_package_name = dict["public_package_name"]
        license_files = [
            target_label.create_child_from_str(s) for s in dict["license_files"]
        ]

        return GnLicenseMetadata(
            target_label=target_label,
            public_package_name=public_package_name,
            license_files=tuple(license_files),
        )


@dataclasses.dataclass
class GnApplicableLicensesMetadata:
    """Metadata produced by the GN `applicable_licenses` template parameter"""

    target_label: GnLabel
    target_type: str
    license_labels: Tuple[GnLabel]

    def is_applicable_licenses_metadata_dict(dict) -> bool:
        return "license_labels" in dict

    def from_json_dict(data) -> "GnApplicableLicensesMetadata":
        assert isinstance(data, dict)
        target_label = GnLabel.from_str(data["target_label"])
        target_type = data["target_type"] if "target_type" in data else None
        assert (
            target_label.toolchain
        ), f"Label must have a toolchain part: {target_label}"

        license_labels = [GnLabel.from_str(s) for s in data["license_labels"]]

        return GnApplicableLicensesMetadata(
            target_label=target_label,
            target_type=target_type,
            license_labels=tuple(license_labels),
        )


@dataclasses.dataclass
class GnLicenseMetadataDB:
    """An in-memory DB of licensing GN metadata"""

    """GnLicenseMetadata by the license's GN label"""
    licenses_by_label: Dict[GnLabel, GnLicenseMetadata] = dataclasses.field(
        default_factory=dict
    )
    """GnApplicableLicensesMetadata by the target label they apply to"""
    applicable_licenses_by_target: Dict[
        GnLabel, GnApplicableLicensesMetadata
    ] = dataclasses.field(default_factory=dict)

    def from_file(path: Path) -> "GnLicenseMetadataDB":
        """Loads from a json file generated by the build/licenses/license_collection.gni template"""

        with open(path, "r") as f:
            output = GnLicenseMetadataDB.from_json_list(json.load(f))
            logging.debug(
                f"Loaded {len(output.licenses_by_label)} licenses and {len(output.applicable_licenses_by_target)} from {path}"
            )
            return output

    def from_json_list(json_list) -> "GnLicenseMetadataDB":
        """Loads from a json list generated by the build/licenses/license_collection.gni template"""

        db = GnLicenseMetadataDB()

        assert type(json_list) is list
        for d in json_list:
            if GnLicenseMetadata.is_license_metadata_dict(d):
                db.add_license_metadata(GnLicenseMetadata.from_json_dict(d))
            elif GnApplicableLicensesMetadata.is_applicable_licenses_metadata_dict(
                d
            ):
                db.add_applicable_licenses_metadata(
                    GnApplicableLicensesMetadata.from_json_dict(d)
                )
            else:
                raise RuntimeError(f"Unexpected json element: {d}")

        # Remove applicable_licenses for targets that are license targets.
        # Those are meaningless.
        for label in db.licenses_by_label.keys():
            if label in db.applicable_licenses_by_target:
                db.applicable_licenses_by_target.pop(label)

        return db

    def add_license_metadata(self, license_metadata: GnLicenseMetadata):
        assert license_metadata.target_label not in self.licenses_by_label
        self.licenses_by_label[license_metadata.target_label] = license_metadata

    def add_applicable_licenses_metadata(
        self, application: GnApplicableLicensesMetadata
    ):
        if application.target_label in self.applicable_licenses_by_target:
            # TODO(133723): Change to error once there are no more targets suffering from fxb/133723.
            logging.warn(
                f"Multiple applicable_licences metadata entries for {application.target_label}, probably due to fxb/133723."
            )
            return
        self.applicable_licenses_by_target[
            application.target_label
        ] = application
