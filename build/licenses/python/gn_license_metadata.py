#!/usr/bin/env fuchsia-vendored-python
# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""Holders for license-related GN metadata dictionaries."""

import json
import dataclasses
import logging
from pathlib import Path
from typing import Dict, Tuple
from gn_label import GnLabel


@dataclasses.dataclass(frozen=True)
class GnLicenseMetadata:
    """Metadata produced by //build/licenses/license.gni template"""

    target_label: GnLabel
    public_package_name: str
    license_files: Tuple[GnLabel]

    def is_license_metadata_dict(dict) -> bool:
        return "license_files" in dict

    def from_json_dict(dict) -> "GnLicenseMetadata":
        target_label = GnLabel.from_str(dict["target_label"])
        assert (
            target_label.toolchain
        ), f"Label must have a toolchain part: {target_label}"

        public_package_name = dict["public_package_name"]
        license_files = [
            target_label.create_child_from_str(s) for s in dict["license_files"]
        ]

        return GnLicenseMetadata(
            target_label=target_label,
            public_package_name=public_package_name,
            license_files=tuple(license_files),
        )


@dataclasses.dataclass
class GnApplicableLicensesMetadata:
    """Metadata produced by the GN `applicable_licenses` template parameter"""

    target_label: GnLabel
    target_type: str
    license_labels: Tuple[GnLabel]

    def is_applicable_licenses_metadata_dict(dict) -> bool:
        return "license_labels" in dict

    def from_json_dict(data) -> "GnApplicableLicensesMetadata":
        assert isinstance(data, dict)
        target_label = GnLabel.from_str(data["target_label"])
        target_type = data["target_type"] if "target_type" in data else None
        assert (
            target_label.toolchain
        ), f"Label must have a toolchain part: {target_label}"

        license_labels = [GnLabel.from_str(s) for s in data["license_labels"]]

        return GnApplicableLicensesMetadata(
            target_label=target_label,
            target_type=target_type,
            license_labels=tuple(license_labels),
        )


@dataclasses.dataclass
class GnLicenseMetadataDB:
    """An in-memory DB of licensing GN metadata"""

    """GnLicenseMetadata by the license's GN label"""
    licenses_by_label: Dict[GnLabel, GnLicenseMetadata]
    """GnApplicableLicensesMetadata by the target label they apply to"""
    applicable_licenses_by_target: Dict[GnLabel, GnApplicableLicensesMetadata]

    def from_file(path: Path) -> "GnLicenseMetadataDB":
        """Loads from a json file generated by the build/licenses/license_collection.gni template"""

        with open(path, "r") as f:
            output = GnLicenseMetadataDB.from_json_list(json.load(f))
            logging.debug(
                f"Loaded {len(output.licenses_by_label)} licenses and {len(output.applicable_licenses_by_target)} from {path}"
            )
            return output

    def from_json_list(json_list) -> "GnLicenseMetadataDB":
        """Loads from a json list generated by the build/licenses/license_collection.gni template"""

        licenses_by_label = {}
        applicable_licenses_by_target = {}

        assert type(json_list) is list
        for d in json_list:
            if GnLicenseMetadata.is_license_metadata_dict(d):
                license_metadata = GnLicenseMetadata.from_json_dict(d)
                assert license_metadata.target_label not in licenses_by_label
                licenses_by_label[
                    license_metadata.target_label
                ] = license_metadata
            elif GnApplicableLicensesMetadata.is_applicable_licenses_metadata_dict(
                d
            ):
                application = GnApplicableLicensesMetadata.from_json_dict(d)
                if application.target_label in applicable_licenses_by_target:
                    # TODO(133723): Remove once there are no more targets suffering from fxb/133723.
                    logging.warn(
                        f"Multiple applicable_licences metadata entries for {application.target_label}, probably due to fxb/133723."
                    )
                    continue
                applicable_licenses_by_target[
                    application.target_label
                ] = application
            else:
                raise RuntimeError(f"Unexpected json element: {d}")

        # Remove applicable_licenses for targets that are license targets.
        # Those are meaningless.
        for label in licenses_by_label.keys():
            if label in applicable_licenses_by_target:
                applicable_licenses_by_target.pop(label)

        return GnLicenseMetadataDB(
            licenses_by_label=licenses_by_label,
            applicable_licenses_by_target=applicable_licenses_by_target,
        )
