# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/compiler.gni")
import("//build/config/fuchsia/platform_version.gni")
import("//build/sdk/config.gni")
import("//build/toolchain/goma.gni")
import("//build/toolchain/rbe.gni")
import("//sdk/config.gni")

# Generate a final Fuchsia IDK archive, which merges outputs from different
# arch-specific sub-builds into a single one. The generated archive will
# include prebuilts for x64 and arm64 libraries. On a host Linux machine, the
# generated archive will have host tools for both Linux/x64 and Linux/arm64.
#
# The generated archive will go into
# $root_build_dir/sdk/archive/{output_name}.tar.gz
#
# This template also creates two implicit targets which can be used
# internally, or during local development:
#
# - ${target_name}.exported target that will only create the final export
#   directory, under $root_build_dir/sdk/exported/{output_name}, without
#   validating its content or creating a compressed archive.
#
# - ${target_name}.validation that will validate the exported directory
#   content, without creating the compressed archive.
#
# Arguments:
#    target_cpus: (optional)
#      List of target cpu names. This must include the default target_cpu
#      value for the current build configuration. Defaults to `idk_target_cpus`.
#
#    sdk_target_labels: (required)
#      List of labels to sdk_collection() GN targets that will be merged into
#      the final archive. Each one will be built for several CPU architecture.
#
#    validation_target_labels: (optional)
#      List of labels to non-sdk_collection() GN targets that will be built
#      as well, but whose output will not go into the final archive. These
#      targets can depend on any sdk_target_labels dependency, and will be
#      built by the top-level build as well as each sub-build launched by
#      the action that creates the final export directory.
#
#    final_validation_target_labels: (optional)
#      List of labels to a targets used to validate the content of
#      the final exported directory before the archive is created. Unlike
#      targets listed in validation_target_labels, these are only built
#      in the top-level build. These targets should only depend on
#      the ${target_name}.exported target, not the main one which builds
#      the compressed archive.
#
#    extra_api_levels: (optional)
#      List of extra API levels, as integers, to build prebuilts for, in
#      addition to the current (HEAD) one. The default value depends on the
#      global sdk_with_all_supported_api_levels variable. If true, then
#      the default will be platform_version.supported_fuchsia_api_levels,
#      otherwise it will be empty.
#
#    output_name: (optional)
#      Name of the archive, without a .tar.gz suffix. Default is target_name
#
#    testonly, visibility
#      Usual GN meaning.
#
template("generate_final_idk") {
  _exported_dir_target = "${target_name}.exported"
  _validation_target = "${target_name}.validation"

  if (sdk_inside_idk_sub_build) {
    # sdk_no_host_tools should only be defined in the sub-builds generated
    # by build_final_idk.py, If this happens, do not define anything here.
    group(target_name) {
    }

    group(_exported_dir_target) {
    }

    group(_validation_target) {
    }

    not_needed(invoker, "*")
  } else {
    # Compute the list of target_cpu values that will require a sub-build
    # directory.
    if (defined(invoker.target_cpus)) {
      _target_cpus = invoker.target_cpus
    } else {
      _target_cpus = idk_target_cpus
    }
    _extra_target_cpus = _target_cpus + [ current_cpu ] - [ current_cpu ]
    assert(
        _extra_target_cpus != _target_cpus,
        "The target_cpus argument must include the current target_cpu ($target_cpu): $_target_cpus")

    # Determine output archive location
    _output_name = target_name
    if (defined(invoker.output_name)) {
      _output_name = invoker.output_name
    }
    _output_archive = root_build_dir + "/sdk/archive/${_output_name}.tar.gz"
    _exported_dir = root_build_dir + "/sdk/exported/${_output_name}"
    _exported_dir_manifest = "${_exported_dir}/meta/manifest.json"
    _exported_dir_stamp = _exported_dir + ".stamp"

    # Compute sdk target labels to pass to the script
    _sdk_targets = []
    foreach(label, invoker.sdk_target_labels) {
      _dir = get_label_info(label, "dir")
      _name = get_label_info(label, "name")
      _sdk_targets += [ "${_dir}:${_name}" ]
    }

    _validation_targets = []
    if (defined(invoker.validation_target_labels)) {
      foreach(label, invoker.validation_target_labels) {
        _dir = get_label_info(label, "dir")
        _name = get_label_info(label, "name")
        _validation_targets += [ "${_dir}:${_name}" ]
      }
    }

    if (defined(invoker.extra_api_levels)) {
      _extra_api_levels = invoker.extra_api_levels
    } else if (sdk_with_all_supported_api_levels) {
      _extra_api_levels = platform_version.supported_fuchsia_api_levels
    } else {
      _extra_api_levels = []
    }

    # Run the script to generate the exported directory.
    # This only contains symlinks to the real files, but can
    # be used by other targets that need to use it without
    # a full archive.
    action(_exported_dir_target) {
      script = "//build/sdk/build_final_idk.py"
      outputs = [
        _exported_dir_stamp,
        _exported_dir_manifest,
      ]

      inputs = [
        # Invoked at runtime by this action's script.
        "//prebuilt/third_party/pigz/pigz",
        "//scripts/sdk/merger/merge.py",
      ]

      args = [
               "--output-directory",
               rebase_path(_exported_dir, root_build_dir),
               "--stamp-file",
               rebase_path(_exported_dir_stamp, root_build_dir),
               "--sdk-id",
               sdk_id,
               "--sdk-targets",
             ] + _sdk_targets

      if (_validation_targets != []) {
        # NOTE: The target labels passed to the script are only used
        # when invoking the sub-builds.
        args += [ "--validation-targets" ] + _validation_targets
      }

      args += [
        "--base-build-dir",
        rebase_path(root_build_dir, root_build_dir),
      ]
      if (_extra_target_cpus != []) {
        args += [ "--extra-target-cpus" ] + _extra_target_cpus
      }

      if (cxx_rbe_enable) {
        args += [ "--cxx-rbe-enable" ]
      }
      if (rust_rbe_enable) {
        args += [ "--rust-rbe-enable" ]
      }
      if (use_goma) {
        args += [ "--use-goma" ]
        if (goma_dir != prebuilt_goma_dir) {
          args += [ "--goma-dir=${goma_dir}" ]
        }
      }
      args += [
        "--compress-debuginfo",
        compress_debuginfo,
      ]

      if (_extra_api_levels != []) {
        args += [ "--extra-api-levels" ]
        foreach(api_level, _extra_api_levels) {
          args += [ "${api_level}" ]
        }
      }

      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])

      # Depending on sdk_target_labels ensures that these are built in
      # the top-level Ninja build directory.
      deps = invoker.sdk_target_labels

      # This script cannot be hermetic.
      hermetic_deps = false

      metadata = {
        sdk_archives = [
          {
            name = target_name

            # TODO(https://fxbug.dev/126262): Determine which values are
            # appropriate, since the archive contains binaries for all
            # Fuchsia CPU architectures (but only one, or even two in
            # the case of Linux) host CPU architectures!
            os = current_os
            cpu = current_cpu
            label = get_label_info(":$target_name", "label_with_toolchain")
            path = rebase_path(_output_archive, root_build_dir)
          },
        ]
      }

      pool = "//:console"
    }

    group(_validation_target) {
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
      deps = [ ":" + _exported_dir_target ]
      if (defined(invoker.validation_target_labels)) {
        deps += invoker.validation_target_labels
      }
      if (defined(invoker.final_validation_target_labels)) {
        deps += invoker.final_validation_target_labels
      }
    }

    action(target_name) {
      script = "//scripts/sdk/merger/merge.py"
      outputs = [ _output_archive ]
      inputs = [
        # Invoked at runtime by this action's script.
        "//prebuilt/third_party/pigz/pigz",
      ]
      mnemonic = "IDK_ARCHIVE"
      args = [
        "--input-directory",
        rebase_path(_exported_dir, root_build_dir),
        "--output-archive",
        rebase_path(outputs[0], root_build_dir),
      ]
      deps = [
        ":${_exported_dir_target}",
        ":${_validation_target}",
      ]

      hermetic_inputs_file = "$target_gen_dir/$target_name.hermetic_inputs"

      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
    }
  }
}
