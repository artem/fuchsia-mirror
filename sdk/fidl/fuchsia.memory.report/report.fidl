// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@available(added=HEAD)
library fuchsia.memory.report;

using zx;
using fuchsia.mem;

/// Provides memory attribution information under this principal.
///
/// TODO(fxbug.dev/307580082): This protocol is under construction.
@discoverable
open protocol SnapshotProvider {
    /// Obtains a breakdown of which resources are owned by which principals.
    ///
    /// Resources that are not attributed to a child principal are owned by this
    /// principal.
    GetAttribution() -> (resource struct {
        /// A FIDL persistence encoded object of type [`Attribution`].
        data fuchsia.mem.Buffer;
    }) error Error;
};

type Error = flexible enum : uint32 {
    /// Internal error within the principal.
    INTERNAL = 1;
};

/// Data returned by [`SnapshotProvider.GetResources`].
type Attribution = table {
    /// A mapping from principals to resources owned by each principal.
    1: children vector<Principal>:MAX;
};

/// An entity that uses resources.
type Principal = table {
    /// The name of this principal.
    1: identifier Identifier;

    /// The resources owned by this principal.
    2: resources vector<flexible union {
        /// The set of VMOs pointed to by the job with the specified KOID.
        1: job zx.Koid;
    }>:MAX;
};

/// [`Identifier`] identifies a principal.
type Identifier = flexible union {
    /// A name identifying a component run by this principal.
    ///
    /// TODO(fxbug.dev/316036032): Once we have token representing the moniker,
    /// use that here instead of a generic string.
    1: component string:MAX;
};
