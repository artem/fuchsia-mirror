// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.driver.development;

using fuchsia.component.decl;
using fuchsia.driver.framework;
using fuchsia.driver.legacy;
using fuchsia.url;
using zx;

const NODE_MONIKER_MAX uint32 = 1024;

type V1DeviceInfo = table {
    /// The topological path of the driver.
    1: topological_path string:fuchsia.driver.legacy.DEVICE_PATH_MAX;

    /// Path to the driver shared library.
    2: bound_driver_libname string:fuchsia.driver.legacy.DEVICE_PATH_MAX;

    /// Properties of the device.
    3: property_list fuchsia.driver.legacy.DevicePropertyList;

    /// Tracks the state of the device.
    4: flags fuchsia.driver.legacy.DeviceFlags;

    /// Banjo protocol ID
    5: protocol_id uint32;

    /// Banjo protocol name
    6: protocol_name string:MAX;
};

type V2NodeInfo = table {
    /// The collection-relative moniker of the node.
    1: moniker string:NODE_MONIKER_MAX;

    /// Properties of the node.
    2: node_property_list
            vector<fuchsia.driver.framework.NodeProperty>:fuchsia.driver.framework.MAX_PROPERTY_COUNT;

    /// Component offers to the node.
    3: offer_list vector<fuchsia.component.decl.Offer>:MAX;
};

type VersionedNodeInfo = flexible union {
    1: v1 V1DeviceInfo;
    2: v2 V2NodeInfo;
};

type NodeInfo = table {
    /// Unique ID identifying the node.
    1: id uint64;

    /// List of ids representing parents. If more than one, this is a composite node.
    2: parent_ids vector<uint64>:MAX;

    /// List of ids representing children.
    3: child_ids vector<uint64>:MAX;

    /// The process KOID of the driver host the driver resides within.
    4: driver_host_koid zx.Koid;

    /// URL to the driver component manifest
    5: bound_driver_url fuchsia.url.Url;

    /// Information specific to the driver framework version in use.
    6: versioned_info VersionedNodeInfo;
};

/// Information about a node binding to either a driver or a composite.
type NodeBindingInfo = table {
    /// Full topological name of the node.
    1: node_name string:NODE_MONIKER_MAX;
    /// This is the component url for the driver that bound to the node.
    /// If this is present, then |composite_parents| and |legacy_composite_parents| must not be.
    2: driver_url fuchsia.url.Url;
    /// The composite parents that this node binded to.
    /// Can be present alongside |legacy_composite_parents|, but not |driver_url|.
    3: composite_parents vector<fuchsia.driver.framework.CompositeParent>:MAX;
    /// The legacy composite parents that this node binded to.
    /// Can be present alongside |composite_parents|, but not |driver_url|.
    4: legacy_composite_parents vector<fuchsia.driver.legacy.CompositeParent>:MAX;
};

/// Contains information for either a composite or legacy composite.
type CompositeInfo = strict union {
    1: legacy_composite fuchsia.driver.legacy.CompositeInfo;
    2: composite fuchsia.driver.framework.CompositeInfo;
};

/// Contains information for a composite node.
type CompositeNodeInfo = table {
    /// The topological paths of the parent nodes of this composite, ordered by index.
    1: parent_topological_paths vector<string:<MAX, optional>>:MAX;

    /// The topological path of the created composite node. Empty if not created.
    2: topological_path string:MAX;

    // Information about the composite.
    3: composite CompositeInfo;
};

type TestNodeAddArgs = table {
    /// Name of the node.
    1: name string:NODE_MONIKER_MAX;

    /// Properties of the node.
    2: properties
            vector<fuchsia.driver.framework.NodeProperty>:fuchsia.driver.framework.MAX_PROPERTY_COUNT;
};

/// These flags indicate when a |fuchsia.driver.index.DriverIndex::MatchDriver| call should be
/// made for a node that is restarting in order to find a new driver, instead of reusing the driver
/// that was previously bound to the node.
type RestartRematchFlags = flexible bits : uint32 {
    /// Rematch nodes that are currently bound to the requested driver. The requested driver is
    /// the driver url that the restart operation was initiated for.
    REQUESTED = 0x0001;
    /// Rematch nodes that are currently bound to a driver other than the requested driver. These
    /// are nodes that are affected by the restart of the requested driver, for example when
    /// it is a colocated parent.
    NON_REQUESTED = 0x0002;
    /// Rematch nodes that are legacy composite nodes.
    LEGACY_COMPOSITE = 0x0004;
    /// Rematch nodes that are created as part of a completed composite spec.
    COMPOSITE_SPEC = 0x0008;
};
