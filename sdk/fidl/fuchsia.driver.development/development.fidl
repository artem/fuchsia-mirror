// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.driver.development;

using fuchsia.component.decl;
using fuchsia.driver.framework;
using fuchsia.driver.legacy;
using fuchsia.url;
using zx;

const BINDING_RESULT_MAX uint8 = 10;

const NODE_MONIKER_MAX uint32 = 1024;

type V1DeviceInfo = table {
    /// The topological path of the driver.
    1: topological_path string:fuchsia.driver.legacy.DEVICE_PATH_MAX;

    /// Path to the driver shared library.
    2: bound_driver_libname string:fuchsia.driver.legacy.DEVICE_PATH_MAX;

    /// Properties of the device.
    3: property_list fuchsia.driver.legacy.DevicePropertyList;

    /// Tracks the state of the device.
    4: flags fuchsia.driver.legacy.DeviceFlags;

    /// Banjo protocol ID
    5: protocol_id uint32;

    /// Banjo protocol name
    6: protocol_name string:MAX;
};

type V2NodeInfo = table {
    /// The collection-relative moniker of the node.
    1: moniker string:NODE_MONIKER_MAX;

    /// Properties of the node.
    2: node_property_list
            vector<fuchsia.driver.framework.NodeProperty>:fuchsia.driver.framework.MAX_PROPERTY_COUNT;

    /// Component offers to the node.
    3: offer_list vector<fuchsia.component.decl.Offer>:MAX;
};

type VersionedNodeInfo = flexible union {
    1: v1 V1DeviceInfo;
    2: v2 V2NodeInfo;
};

type NodeInfo = table {
    /// Unique ID identifying the node.
    1: id uint64;

    /// List of ids representing parents. If more than one, this is a composite node.
    2: parent_ids vector<uint64>:MAX;

    /// List of ids representing children.
    3: child_ids vector<uint64>:MAX;

    /// The process KOID of the driver host the driver resides within.
    4: driver_host_koid zx.Koid;

    /// URL to the driver component manifest
    5: bound_driver_url fuchsia.url.Url;

    /// Information specific to the driver framework version in use.
    6: versioned_info VersionedNodeInfo;
};

/// Information about a node binding to either a driver or a composite.
type NodeBindingInfo = table {
    /// Full topological name of the node.
    1: node_name string:NODE_MONIKER_MAX;
    /// This is the component url for the driver that bound to the node.
    /// If this is present, then |composite_parents| and |legacy_composite_parents| must not be.
    2: driver_url fuchsia.url.Url;
    /// The composite parents that this node binded to.
    /// Can be present alongside |legacy_composite_parents|, but not |driver_url|.
    3: composite_parents vector<fuchsia.driver.framework.CompositeParent>:MAX;
    /// The legacy composite parents that this node binded to.
    /// Can be present alongside |composite_parents|, but not |driver_url|.
    4: legacy_composite_parents vector<fuchsia.driver.legacy.CompositeParent>:MAX;
};

/// Contains information for either a composite or legacy composite.
type CompositeInfo = strict union {
    1: legacy_composite fuchsia.driver.legacy.CompositeInfo;
    2: composite fuchsia.driver.framework.CompositeInfo;
};

/// Contains information for a composite node.
type CompositeNodeInfo = table {
    /// The topological paths of the parent nodes of this composite, ordered by index.
    1: parent_topological_paths vector<string:<MAX, optional>>:MAX;

    /// The topological path of the created composite node. Empty if not created.
    2: topological_path string:MAX;

    // Information about the composite.
    3: composite CompositeInfo;
};

type TestNodeAddArgs = table {
    /// Name of the node.
    1: name string:NODE_MONIKER_MAX;

    /// Properties of the node.
    2: properties
            vector<fuchsia.driver.framework.NodeProperty>:fuchsia.driver.framework.MAX_PROPERTY_COUNT;
};

/// These flags indicate when a |fuchsia.driver.index.DriverIndex::MatchDriver| call should be
/// made for a node that is restarting in order to find a new driver, instead of reusing the driver
/// that was previously bound to the node.
type RematchFlags = flexible bits : uint32 {
    /// Rematch nodes that are currently bound to the requested driver. The requested driver is
    /// the driver url that the restart operation was initiated for.
    REQUESTED = 0x0001;
    /// Rematch nodes that are currently bound to a driver other than the requested driver. These
    /// are nodes that are affected by the restart of the requested driver, for example when
    /// it is a colocated parent.
    NON_REQUESTED = 0x0002;
    /// Rematch nodes that are legacy composite nodes.
    LEGACY_COMPOSITE = 0x0004;
    /// Rematch nodes that are created as part of a completed composite spec.
    COMPOSITE_SPEC = 0x0008;
};

closed protocol DriverInfoIterator {
    /// Return empty when no more entries left.
    strict GetNext() -> (struct {
        drivers vector<fuchsia.driver.framework.DriverInfo>:MAX;
    });
};

/// Used to page through a CompositeList.
closed protocol CompositeInfoIterator {
    /// Returns up to 100 entries at a time. Return empty when no more
    /// composites are left.
    strict GetNext() -> (struct {
        composites vector<CompositeNodeInfo>:MAX;
    });
};

closed protocol CompositeNodeSpecIterator {
    /// Return empty when no more node groups are left.
    strict GetNext() -> (struct {
        specs vector<fuchsia.driver.framework.CompositeInfo>:MAX;
    });
};

closed protocol NodeInfoIterator {
    /// Return empty when no more entries left.
    strict GetNext() -> (struct {
        drivers vector<NodeInfo>:MAX;
    });
};

/// Interface for developing and debugging drivers.
/// This interface should only be used for development and disabled in release builds.
@discoverable
open protocol DriverIndex {
    /// Returns a list of all drivers that are known to the system.
    /// If a |driver_filter| is provided, the returned list will be filtered to
    /// only include drivers specified in the filter.
    ///
    /// |iterator| is closed with following epitaphs on error:
    /// ZX_ERR_NOT_FOUND indicates that there is no driver matching the given path for at least
    /// one driver in |driver_filter|.
    /// ZX_ERR_BUFFER_TOO_SMALL indicates that the driver's bind program is longer than the
    /// maximum number of instructions (BIND_PROGRAM_INSTRUCTIONS_MAX).
    flexible GetDriverInfo(resource struct {
        driver_filter vector<string:MAX>:MAX;
        iterator server_end:DriverInfoIterator;
    });

    /// Returns a list of all composite node specs that are known to the system.
    /// If a |name_filter| is provided, the returned list will only include 1 spec,
    /// the one with that exact name.
    ///
    /// |iterator| is closed with following epitaphs on error:
    /// ZX_ERR_NOT_FOUND indicates that there are no specs or if a |name_filter| is provided,
    /// that there are no specs with that name.
    flexible GetCompositeNodeSpecs(resource struct {
        name_filter string:<MAX, optional>;
        iterator server_end:CompositeNodeSpecIterator;
    });

    /// Disable the given driver url from being returned as a match. When this is called,
    /// subsequent |fuchsia.driver.index.DriverIndex::MatchDriver| requests will not consider
    /// the driver with the given url.
    /// This can be used for all driver package types. The given driver url does not
    /// have to match existing drivers, it will apply even if the driver appears afterwards,
    /// for example through a |fuchsia.driver.registrar.Register| operation.
    flexible DisableMatchWithDriverUrl(struct {
        driver_url fuchsia.url.Url;
    }) -> ();

    /// Re-enables a given driver url, that was previously disabled with
    /// |DisableMatchWithDriverUrl|, for matching again. This must be called for driver urls that
    /// were previously disabled.
    /// Will return ZX_ERR_NOT_FOUND if the `driver_url` was not previously disabled.
    flexible ReEnableMatchWithDriverUrl(struct {
        driver_url fuchsia.url.Url;
    }) -> () error zx.Status;
};

/// Interface for developing and debugging drivers.
/// This interface should only be used for development and disabled in release builds.
@discoverable
open protocol DriverDevelopment {
    compose DriverIndex;

    /// Restarts all driver hosts containing the driver specified by the `driver_url` component url,
    /// and returns the number of driver hosts that were restarted.
    flexible RestartDriverHosts(struct {
        driver_url fuchsia.url.Url;
        rematch_flags RematchFlags;
    }) -> (struct {
        count uint32;
    }) error zx.Status;

    /// Returns the list of nodes that are running on the system.
    ///
    /// If a |node_filter| is provided, the returned list will be filtered to
    /// only include nodes specified in the filter. If |exact_match| is true,
    /// then the filter must exactly match a node's topological path;
    /// otherwise, it performs a substring match. The list will be empty if no
    /// nodes match the filter.
    ///
    /// |iterator| is closed with following epitaphs on error:
    /// ZX_ERR_BAD_PATH indicates that the given path is not valid.
    /// ZX_ERR_BUFFER_TOO_SMALL indicates either that the given path is too long,
    /// or that the node has more than the maximum number of properties (PROPERTIES_MAX).
    flexible GetNodeInfo(resource struct {
        node_filter vector<string:MAX>:MAX;
        iterator server_end:NodeInfoIterator;
        exact_match bool;
    });

    /// Returns the list of composites in the system. This includes composites 
    /// that are not yet assembled and added into the node topology.
    flexible GetCompositeInfo(resource struct {
        iterator server_end:CompositeInfoIterator;
    });


    /// (DFv2) Attempts to bind all unbound nodes in the topology.
    /// Returns new successful binds.
    flexible BindAllUnboundNodes() -> (struct {
        /// List of new bindings that happened as a result of this.
        binding_result vector<NodeBindingInfo>:BINDING_RESULT_MAX;
    }) error zx.Status;

    // TODO(https://fxbug.dev/107895): Remove this method once it is no longer being
    // used.
    // Returns a boolean value of whether or not driver framework version 2 is
    // enabled.
    flexible IsDfv2() -> (struct {
        response bool;
    });

    /// (DFv2) Adds test node under the root node.
    flexible AddTestNode(struct {
        args TestNodeAddArgs;
    }) -> () error fuchsia.driver.framework.NodeError;

    /// (DFv2) Removes the test node. The node is removed asynchronously and is
    /// not guaranteed to be removed by the time this returns.
    flexible RemoveTestNode(struct {
        name string:NODE_MONIKER_MAX;
    }) -> () error zx.Status;
};
