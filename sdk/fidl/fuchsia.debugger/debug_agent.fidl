// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
@available(added=16)
library fuchsia.debugger;

using fuchsia.component;
using zx;

@available(added=HEAD)
closed protocol AttachedProcessIterator {
    strict GetNext() -> (struct {
        process_names vector<string:zx.MAX_NAME_LEN>:MAX;
    });
};

@available(added=HEAD)
type FilterError = flexible enum {
    /// Indicates that there was no pattern given in the filter.
    NO_PATTERN = 1;
    /// FilterType was either unspecified or an otherwise unknown type to this agent.
    UNKNOWN_TYPE = 2;
};

@available(added=HEAD)
type FilterType = flexible enum : uint8 {
    /// Performs an exact match against a component's URL, sans hash values.
    /// e.g. pattern fuchsia-pkg://fuchsia.com/package#meta/component.cm will
    /// match fuchsia-pkg://fuchsia.com/package?hash=1234abcd#meta/component.cm.
    URL = 0;
    /// Performs an exact match against a component's full moniker.
    MONIKER = 1;
    /// Matches any component moniker that includes the pattern as a prefix.
    MONIKER_PREFIX = 2;
    /// Matches any component moniker that includes the pattern as a suffix.
    MONIKER_SUFFIX = 3;
};

@available(added=HEAD)
type FilterOptions = table {
    /// Whether or not to also match all child components in the matching
    /// component's realm. When true, the matching component's full moniker will
    /// be assumed to be the root of the realm, and all children components will
    /// be launched within this realm.
    1: recursive bool;
};

/// A filter that will apply to processes and components running now and in the
/// future. Any component or process that matches the given pattern and type
/// will be attached, thereafter allowing clients to query information about the
/// program(s). A valid filter will always contain a non-empty pattern string,
/// and a FilterType to discern what to compare the pattern against. Additional
/// options may be specified via FilterOptions.
@available(added=HEAD)
type Filter = struct {
    /// A string pattern to be matched against the given |type|. An empty
    /// pattern will result in a NO_PATTERN error.
    pattern string:MAX;

    /// How to interpret |pattern|. See FilterType.
    type FilterType;

    /// Additional options for this filter. See FilterOptions.
    options FilterOptions;
};

@discoverable
open protocol DebugAgent {
    /// Hand the DebugAgent a socket that connects it to the debugger. This
    /// will return ZX_ERR_ALREADY_BOUND if a connection already exists. When
    /// the socket is closed, the DebugAgent will exit.
    flexible Connect(resource struct {
        socket zx.Handle:SOCKET;
    }) -> () error zx.Status;

    /// Iterator over all processes that this agent is attached to. Note this is
    /// not the same as the set of installed filters, but rather the set of
    /// filters that matched and were later successfully attached.
    @available(added=HEAD)
    flexible GetAttachedProcesses(resource struct {
        iterator server_end:AttachedProcessIterator;
    });

    /// Use the given filter to attach to any existing or subsequently created
    /// components. This method will return the number of matches that were
    /// present at the time of calling this method. All attached processes will
    /// be detached when this agent is destroyed.
    ///
    /// |filter| will be inspected for validity, with corresponding errors
    /// returned. If the filter is invalid, no attaches will occur.
    ///
    /// |num_matches| will contain the number of matches that were found
    /// immediately upon filter installation if there was no error, that is, the
    /// number of processes immediately within (or recursively in this realm, if
    /// the option is specified) this component's corresponding job. Note that
    /// filters may be installed _before_ any components are actually resolved
    /// and matched, so this number may be 0. This return value may be safely
    /// ignored.
    ///
    /// Invalid filters will return an error, see Filter above for details on
    /// how to construct a filter.
    @available(added=HEAD)
    flexible AttachTo(Filter) -> (struct {
        num_matches uint32;
    }) error FilterError;
};

@available(added=HEAD)
type Agent = resource struct {
    name fuchsia.component.child_name;
    client_end client_end:DebugAgent;
};

@available(added=HEAD)
closed protocol AgentIterator {
    strict GetNext() -> (resource struct {
        agents vector<Agent>:MAX;
    });
};

@discoverable
@available(added=HEAD)
open protocol Launcher {
    /// Launch a new instance of DebugAgent listening on |agent|. The DebugAgent
    /// will exit upon closing the corresponding client_end of this channel.
    /// Clients must not close the channel until the debugging session is
    /// completed.
    flexible Launch(resource struct {
        agent server_end:DebugAgent;
    }) -> () error zx.Status;

    /// Iterator over all DebugAgent instances.
    flexible GetAgents(resource struct {
        iterator server_end:AgentIterator;
    });
};
