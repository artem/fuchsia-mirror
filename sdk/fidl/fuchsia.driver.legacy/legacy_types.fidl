// Copyright 2023 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library fuchsia.driver.legacy;

using fuchsia.driver.framework;

/// Maximum number of bytes in a path
// The simple name PATH_MAX collides with a musl #define on c++ bindings.
const DEVICE_PATH_MAX uint32 = 1024;

// Maximum number of instructions in a driver bind program
const BIND_RULES_INSTRUCTIONS_MAX uint32 = 256;

/// Maximum number of properties that can be attached to a device
const PROPERTIES_MAX uint32 = 256;

/// Maximum number of string properties that can be attached to a device
const STR_PROPERTIES_MAX uint32 = 256;

/// Maximum length of a string property key and value.
const STR_LENGTH_MAX uint32 = 255;

type BindInstruction = struct {
    /// bitfield that encodes the operation and execution conditions
    op uint32;
    /// bitfield that encodes the arguments
    arg uint32;
    /// bitfield that encodes debugging information
    debug uint32;
};

/// This has the same structure as zx_device_prop_t.
type DeviceProperty = struct {
    id uint16;
    reserved uint16;
    value uint32;
};

type PropertyValue = strict union {
    1: int_value uint32;
    2: str_value string:STR_LENGTH_MAX;
    3: bool_value bool;
    4: enum_value string:STR_LENGTH_MAX;
};

type DeviceStrProperty = struct {
    key string:STR_LENGTH_MAX;
    value PropertyValue;
};

type DevicePropertyList = struct {
    props vector<DeviceProperty>:PROPERTIES_MAX;
    str_props vector<DeviceStrProperty>:STR_PROPERTIES_MAX;
};

type DeviceFlags = strict bits : uint32 {
    //// This device is never destroyed
    IMMORTAL = 0x0001;
    /// This device requires that children are created in a
    /// new driver_host attached to a proxy device
    MUST_ISOLATE = 0x0002;

    /// This device is bound and not eligible for binding
    /// again until unbound.  Not allowed on ALLOW_MULTI_COMPOSITE ctx.
    BOUND = 0x0008;

    /// Device has been remove()'d
    DEAD = 0x0010;

    /// This device is a fragment of a composite device and
    /// can be part of multiple composite devices.
    ALLOW_MULTI_COMPOSITE = 0x0020;

    /// Device is a proxy -- its "parent" is the device it's
    /// a proxy to.
    PROXY = 0x0040;

    /// Device is not visible in devfs or bindable.
    /// Devices may be created in this state, but may not
    /// return to this state once made visible.
    INVISIBLE = 0x0080;

    /// Device should not go through auto-bind process.
    SKIP_AUTOBIND = 0x0100;
};

/// Information for a composite node's fragment in DFv1.
type CompositeFragmentInfo = table {
    1: name string:MAX;
    2: bind_rules vector<BindInstruction>:BIND_RULES_INSTRUCTIONS_MAX;
};

/// Information for a legacy composite in DFv1.
type CompositeInfo = table {
    /// The name of the composite node.
    1: name string:MAX;

    /// A list of composite fragment information.
    2: fragments vector<CompositeFragmentInfo>:MAX;

    /// The node properties in the composite node.
    3: properties
            vector<fuchsia.driver.framework.NodeProperty>:fuchsia.driver.framework.MAX_PROPERTY_COUNT;

    /// Information about the driver matched to the legacy composite node.
    4: matched_driver fuchsia.driver.framework.DriverInfo;

    /// This is the primary fragment. If it is unavailable the first fragment at index 0
    /// is the primary fragment.
    5: primary_fragment_index uint32;
};

/// A parent to a composite that is defined by a legacy composite.
type CompositeParent = table {
    /// Information about the legacy composite node that this is a parent of.
    1: composite CompositeInfo;

    /// The index of this parent in the fragments.
    2: index uint32;
};
