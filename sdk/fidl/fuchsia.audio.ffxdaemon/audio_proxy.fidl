// Copyright 2022 The Fuchsia Authors.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// This library contains protocols used by the `ffx audio` tool only.
@available(added=HEAD)
library fuchsia.audio.ffxdaemon;

using fuchsia.media;
using fuchsia.hardware.audio;
using fuchsia.io;
using fuchsia.audio.device;
using fuchsia.virtualaudio;
using zx;

/// Where to output audio data supplied by an ffx client.
type PlayLocation = flexible union {
    /// Create an `AudioRenderer` using the audio_core API and play audio through it.
    1: renderer RendererConfig;

    /// Write audio data directly to a device ring buffer.
    2: device_ring_buffer DeviceSelector;
};

/// Selection of the frequency range than an `AudioRenderer` can write.
type RendererConfig = flexible union {
    /// Renderer for standard frequencies.
    1: standard_renderer StandardRendererConfig;

    /// Renderer for ultrasonic frequencies.
    2: ultrasound_renderer UltrasoundRendererConfig;
};

/// Configuration parameters for creating an `AudioRenderer` for the standard frequency range.
type StandardRendererConfig = table {
    /// The usage of the audio stream.
    ///
    /// Required.
    1: usage fuchsia.media.AudioRenderUsage;

    /// The reference clock type used by the stream. If unspecified, use the default
    /// reference clock provided by the renderer.
    ///
    /// Optional.
    2: clock ClockType;

    /// How many packets to use when sending data to an `AudioRenderer`.
    /// Optional. If not specified, AudioDaemon will use four packets.
    3: packet_count uint32;
};

/// Configuration parameters for creating an `AudioRenderer` for the standard frequency range.
type UltrasoundRendererConfig = table {
    /// How many packets to use when sending data to an `AudioRenderer`.
    /// Optional. If not specified, AudioDaemon will use four packets.
    1: packet_count uint32;
};

/// Reference clock options for an `AudioRenderer` or `AudioCapturer`.
type ClockType = flexible union {
    /// Use a flexible clock.
    1: flexible struct {};

    /// Use the system monotonic clock.
    2: monotonic struct {};

    /// Use a monotonic clock with possible rate adjustment and offset relative to the system
    /// monotonic clock.
    3: custom CustomClockConfig;
};

/// Configuration for the custom reference clock passed to an `AudioRenderer` or `AudioCapturer`.
type CustomClockConfig = table {
    /// Frequency rate adjustment to a clone of the system monotonic clock.
    /// Given in parts per million relative to the system monotonic rate.
    /// Must fall within [ZX_CLOCK_UPDATE_MIN_RATE_ADJUST, ZX_CLOCK_UPDATE_MAX_RATE_ADJUST].
    /// For more info, see `zx_clock_update`. If not specified, use the reference clock's
    /// default rate.
    ///
    /// Optional.
    1: rate_adjust int32;

    /// Starting delta between the reference clock passed to AudioRenderer or Capturer
    /// and the system monotonic clock. If not specified, do not adjust reference clock offset.
    ///
    /// Optional.
    2: offset int32;
};

/// Where to read audio data from to send back to an ffx client.
type RecordLocation = flexible union {
    /// Create an audio_core `AudioCapturer` and record audio data from it.
    1: capturer CapturerConfig;

    /// Create an audio_core `AudioCapturer` with loopback and record audio data from it.
    2: loopback struct {};

    /// Raad audio data directly from a device ring buffer.
    3: device_ring_buffer DeviceSelector;
};

/// Selection of the frequency range than an `AudioCapturer` can read.
type CapturerConfig = flexible union {
    /// AudioCapturer for standard frequencies.
    1: standard_capturer StandardCapturerConfig;

    /// AudioCapturer for ultrasonic frequencies.
    2: ultrasound_capturer struct {};
};

/// Configuration parameters for creating an `AudioCapturer` for the standard frequency range.
type StandardCapturerConfig = table {
    /// The usage of the audio stream.
    ///
    /// Required.
    1: usage fuchsia.media.AudioCaptureUsage;

    /// The reference clock type used by the stream. If unspecified, use the default
    /// reference clock provided by the capturer.
    ///
    /// Optional.
    2: clock ClockType;
};

/// Gain settings.
type GainSettings = table {
    /// Whether to mute the audio stream. If unspecified, do not adjust the existing mute value.
    ///
    /// Optional.
    1: mute bool;

    /// Gain level in dB. If unspecified, do not adjust stream or device gain.
    ///
    /// Optional.
    2: gain float32;
};

/// Information about a device.
type DeviceInfo = flexible union {
    /// Device supports the fuchsia.hardware.audio/StreamConfig protocol.
    1: stream_config StreamConfigDeviceInfo;
};

/// Information about a device that supports the fuchsia.hardware.audio/StreamConfig protocol.
type StreamConfigDeviceInfo = table {
    /// Top level static properties of the stream.
    ///
    /// Required.
    1: stream_properties fuchsia.hardware.audio.StreamProperties;

    /// Supported formats.
    ///
    /// Required.
    2: supported_formats
            vector<fuchsia.hardware.audio.SupportedFormats>:fuchsia.hardware.audio.MAX_COUNT_FORMATS;

    /// Gain state.
    ///
    /// Required.
    3: gain_state fuchsia.hardware.audio.GainState;

    /// Plug state.
    ///
    /// Required.
    4: plug_state fuchsia.hardware.audio.PlugState;
};

/// Identifies which device to retrieve information about.
type DeviceSelector = table {
    /// Whether device is input or output.
    ///
    /// Required. Future device types may not require this field.
    1: is_input bool;

    /// ID of device.
    ///
    /// Required.
    2: id fuchsia.io.Path;

    /// Device type. If not specified, defaults to StreamConfig.
    3: device_type fuchsia.virtualaudio.DeviceType;
};

/// Cancels an AudioDaemonRecordRequest if no duration was specified.
closed protocol AudioDaemonCanceler {
    /// Finish sending audio data back to the client.
    strict Cancel() -> () error zx.Status;
};

/// The main entry point for ffx audio.
@discoverable
closed protocol AudioDaemon {
    /// Plays audio data from socket on either an `AudioRenderer` or on device ring buffer.
    /// Returns sockets for transmitting info back to stdout and stderr on host.
    strict Play(resource table {
        /// Socket for audio data. Should transmit entire file in WAV format.
        ///
        /// Required.
        1: socket zx.Handle:SOCKET;

        /// Play on device ring buffer or AudioRenderer.
        ///
        /// Required.
        2: location PlayLocation;

        /// Play settings.
        ///
        /// Required.
        3: gain_settings GainSettings;
    }) -> (resource table {
        /// Information from daemon component for ffx plugin to display.
        ///
        /// Required.
        1: stdout zx.Handle:SOCKET;

        /// Errors from daemon component for ffx plugin to display.
        ///
        /// Required.
        2: stderr zx.Handle:SOCKET;
    }) error zx.Status;

    /// Records audio data from either an `AudioCapturer` or device ring buffer.
    /// Returns sockets containing audio data and errors back to host.
    strict Record(resource table {
        /// Record from `AudioCapturer` or ring buffer.
        ///
        /// Required.
        1: location RecordLocation;

        /// Streamtype.
        ///
        /// Required.
        2: stream_type fuchsia.media.AudioStreamType;

        /// Duration in nanoseconds to record audio data. If not specified, daemon will send
        /// data back to ffx client until it receives a stop signal following a keypress.
        /// If present, the record request is still cancelable via handle below.
        ///
        /// Optional.
        3: duration zx.Duration;

        /// Handle to signal when to stop sending data back to ffx client.
        ///
        /// Required.
        4: canceler server_end:AudioDaemonCanceler;

        /// Record gain settings. If not specified, AudioCapturer's defaults will apply.
        ///
        /// Optional.
        5: gain_settings GainSettings;

        /// Buffer size. If not specified, allocate enough to hold one second of audio data.
        ///
        /// Optional.
        6: buffer_size uint64;
    }) -> (resource table {
        /// Contains audio data in the form of a complete WAV file.
        ///
        /// Required.
        1: stdout zx.Handle:SOCKET;

        /// Errors from daemon component for ffx plugin to display.
        ///
        /// Required.
        2: stderr zx.Handle:SOCKET;
    }) error zx.Status;

    /// Lists all available audio devices on target.
    strict ListDevices() -> (resource table {
        /// List of available devices, sorted by name.
        ///
        /// Required.
        1: devices vector<DeviceSelector>:fuchsia.audio.device.MAX_COUNT_DEVICES;
    }) error zx.Status;

    /// Returns details about a specific audio device.
    strict DeviceInfo(resource table {
        /// Id of device to retrieve information about, and
        /// whether it is an input or output device.
        ///
        /// Required.
        1: device DeviceSelector;
    }) -> (resource table {
        /// Information about the device.
        ///
        /// Required.
        1: device_info DeviceInfo;
    }) error zx.Status;

    /// Sets the gain of the stream in decibels.
    strict DeviceSetGainState(resource table {
        /// Id of the device to set the gain state.
        ///
        /// Required.
        1: device DeviceSelector;

        /// Desired gain state.
        ///
        /// Required.
        2: gain_state fuchsia.hardware.audio.GainState;
    }) -> () error zx.Status;
};
