# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/testing/host_test_data.gni")
import("//build/toolchain/toolchain_environment.gni")
import("//build/toolchain/zircon/user_basic_redirect.gni")

# This only gets instantiated in the environment where the test modules are
# meant to be built.

# Everything in this list has can_be_in_process = true.
in_process_executables = [
  ":ret17",
  ":relative-reloc",
  ":symbolic-reloc",
  ":ld-dep",
  ":basic-dep",
  ":indirect-deps",
  ":passive-abi-basic",
  ":symbolic-namespace",
  ":many-deps",
  ":init-fini",
  ":tls-exec-only",
  ":tls-shlib-only",
  ":tls-exec-shlib",
]

# Everything in this list does not have can_be_in_process = true.
executables = []

shlibs = [
  ":ld-dep-a",
  ":ld-dep-b",
  ":ld-dep-c",
  ":ld-dep-d",
  ":ld-dep-e",
  ":ld-dep-f",
  ":indirect-deps-a",
  ":indirect-deps-b",
  ":indirect-deps-c",
  ":tls-dep",
]

modules = []

foreach(label, in_process_executables) {
  executables += [
    label,
    "$label.in-process",
  ]
}

if (is_fuchsia) {
  assert(toolchain_environment == "user.basic",
         "$current_toolchain is $toolchain_environment")

  group("modules") {
    testonly = true

    deps = executables + modules
  }
} else if (current_toolchain != shlib_toolchain) {
  if (is_linux) {
    assert(toolchain_environment == "linux",
           "$current_toolchain is $toolchain_environment")
  }

  host_test_data("modules") {
    deps = []
    sources = []
    outputs = [ "$host_out_dir/test_data/elfldltl/{{source_file_part}}" ]

    foreach(label, executables) {
      name = get_label_info(label, "name")

      deps += [ label ]
      sources += [ "$root_out_dir/$name" ]
    }

    shlib_out_dir = get_label_info(".($shlib_toolchain)", "root_out_dir")

    foreach(label, shlibs) {
      name = get_label_info(label, "name")

      deps += [ "$label($shlib_toolchain)" ]
      sources += [ "$shlib_out_dir/lib$name.so" ]
    }

    foreach(label, modules) {
      name = get_label_info(label, "name")

      deps += [ "$label($shlib_toolchain)" ]
      sources += [ "$shlib_out_dir/$name.so" ]
    }
  }
}

config("semantic-interposition") {
  visibility = [ ":*" ]

  # TODO(fxbug.dev/117866): clang will still perform interprocedural
  # optimization in a PIC, this flag disallows that and requires the PLT call
  # always be made so we can properly test applying plt relocations.
  if (!is_gcc) {
    cflags = [ "-fsemantic-interposition" ]
  }
}

template("test_executable") {
  suffices = [ "" ]
  if (defined(invoker.can_be_in_process) && invoker.can_be_in_process) {
    suffices += [ ".in-process" ]
  }
  foreach(suffix, suffices) {
    executable(target_name + suffix) {
      testonly = true

      deps = []
      forward_variables_from(invoker,
                             "*",
                             [
                               "configs",
                               "testonly",
                             ])
      deps += [ ":test-executable$suffix" ]
      if (defined(invoker.configs)) {
        configs += invoker.configs
      }

      # This is needed in the non-Zircon (host/Linux) toolchains to avoid
      # having any implicit deps injected.
      disable_syslog_backend = true

      exclude_toolchain_tags = [ "instrumentation-runtime" ]
    }
  }
}

# The test executables declare an `extern "C" ... TestStart(...)` entry point.
#
# When built for in-process tests, the ELF entry point will be called directly
# by the test code.  For Fuchsia, link the test executables with -e TestStart.
# For POSIX, link with an assembly implementation of _start that tail-calls
# TestStart.
#
# When built for separate-process tests, the ELF entry point cannot return.
# Instead, it's defined to call TestStart and exit with its value.
foreach(in_process,
        [
          "",
          ".in-process",
        ]) {
  static_library("test-executable$in_process") {
    visibility = [ ":*" ]
    testonly = true

    if (in_process != "") {
      defines = [ "IN_PROCESS_TEST" ]
    }

    public = [ "ensure-test-thread-pointer.h" ]
    public_deps = [ "//sdk/lib/ld:standalone" ]
    public_configs = [
      "//sdk/lib/ld:abi-interp",
      ":semantic-interposition",
    ]
    sources = [ "ensure-test-thread-pointer.cc" ]
    deps = [ "//zircon/system/public" ]
    if (is_fuchsia) {
      if (in_process == "") {
        sources += [ "zircon-test-start.cc" ]
        deps += [ "//src/zircon/lib/zircon" ]
      } else {
        public_configs += [ ":test-executable.in-process.config" ]
      }
    } else {
      sources += [ "posix-test-start.S" ]
      deps += [ "//zircon/kernel/lib/arch" ]
    }

    # This dependency is evaluated in the toolchain where the test_executable()
    # is built, after variant selection.  So it gets the right version of
    # ld-startup installed where the test needs to find it.
    data_deps = [ "..:ld-startup.test-data($shlib_toolchain)" ]
  }
}

# clang++ will add -lc++ and -lm, which we don't want for these tests. Note
# there are differences between the Fuchsia and GNU toolchains in clang. The
# GNU toolchain will unconditionally add -lm regardless of -nostdlib++ though
# the Fuchsia driver doesn't. -nodefaultlibs will stop the driver from adding
# -lm, but we get unused -nolibc warning because the arg is never read when
# -nodefaultlibs is specified, so just ignore the warning.
config("nostdlibs") {
  if (is_fuchsia) {
    ldflags = [ "-nostdlib++" ]
  } else {
    ldflags = [
      "-nodefaultlibs",
      "-Wno-unused-command-line-argument",
    ]
  }
}

template("test_shared_library") {
  shared_library(target_name) {
    ldflags = []
    public_deps = [ "//sdk/lib/ld:standalone" ]
    forward_variables_from(invoker, "*")

    if (is_linux) {
      configs -= [ "//build/config/linux:implicit-host-libs" ]
    }
    configs += [ ":nostdlibs" ]

    exclude_toolchain_tags = [ "instrumentation-runtime" ]
  }
}

template("test_dep") {
  test_shared_library("ld-dep-$target_name") {
    deps = []
    test_deps = []
    forward_variables_from(invoker, "*")

    decls = ""
    syms = ""
    foreach(dep, test_deps) {
      deps += [ ":ld-dep-$dep" ]
      decls += "extern \"C\" int64_t $dep();"
      syms += "$dep, "
    }

    defines = [
      "VALUE=$value",
      "SYM=$target_name",
      "DECLS=$decls",
      "DEP_SYMS=$syms",
    ]

    sources = [ "dep-template.cc" ]
    deps += [ "//zircon/system/public" ]
  }
}

config("test-executable.in-process.config") {
  visibility = [ ":*" ]
  ldflags = [ "-Wl,-e,TestStart" ]
}

test_executable("ret17") {
  can_be_in_process = true
  sources = [ "ret17.cc" ]
}

test_executable("relative-reloc") {
  can_be_in_process = true
  sources = [ "relative-reloc.cc" ]
}

config("temporarily-build-as-shared") {
  visibility = [ ":*" ]

  cflags = [
    "-fPIC",
    "-Wno-unused-command-line-argument",
    "-Wno-option-ignored",
  ]
  ldflags = cflags
  ldflags += [ "-shared" ]
}

test_executable("symbolic-reloc") {
  can_be_in_process = true
  sources = [
    "interp.S",
    "symbolic-reloc.cc",
  ]
  defines = [ "DYNAMIC_LINKER_PATH=\"${toolchain_variant.libprefix}ld.so.1\"" ]
  deps = [ "//zircon/system/public" ]
  configs = [ ":temporarily-build-as-shared" ]
}

test_executable("ld-dep") {
  can_be_in_process = true
  sources = [ "ld-dep.cc" ]
  deps = [ "../.." ]
}

test_dep("a") {
  value = 13
}

test_executable("basic-dep") {
  can_be_in_process = true
  sources = [ "basic-dep.cc" ]
  deps = [ ":ld-dep-a" ]
}

test_executable("indirect-deps") {
  can_be_in_process = true
  sources = [ "basic-dep.cc" ]
  deps = [ ":indirect-deps-a" ]
}

test_shared_library("indirect-deps-a") {
  sources = [ "indirect-deps-a.cc" ]
  deps = [
    ":indirect-deps-b",
    ":indirect-deps-c",
    "//zircon/system/public",
  ]
}

test_shared_library("indirect-deps-b") {
  sources = [ "indirect-deps-b.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_shared_library("indirect-deps-c") {
  sources = [ "indirect-deps-c.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_executable("passive-abi-basic") {
  can_be_in_process = true
  sources = [ "passive-abi-basic.cc" ]
  deps = [ "../.." ]
}

test_executable("symbolic-namespace") {
  can_be_in_process = true
  sources = [ "symbolic-namespace.cc" ]
  deps = [
    ":ld-dep-a",
    "../..",
  ]
}

# These show the dependency graph of the test and the expected return value of each dependency's
# only symbol.
#
# many_deps -> (13 + -8 + 3 + 9 = 17)
#   a -> 13
#   b -> -2 (-2 + 2 + 13 + -21 = -8)
#     c -> 2
#     a -> 13
#     d -> -5 (-5 + -16 = -21)
#       c -> 2
#       e -> -18
#   f -> 3
#   _ld_abi -> 9 (number of total modules including vdso which may not be depended on)

test_dep("b") {
  value = -2
  test_deps = [
    "a",
    "c",
    "d",
  ]
}

test_dep("c") {
  value = 2
}

test_dep("d") {
  value = -5
  test_deps = [
    "c",
    "e",
  ]
}

test_dep("e") {
  value = -18
}

test_dep("f") {
  value = 3
}

test_executable("many-deps") {
  can_be_in_process = true
  sources = [ "many-deps.cc" ]

  deps = [
    ":ld-dep-a",
    ":ld-dep-b",
    ":ld-dep-f",
    "../..",
  ]
}

test_executable("init-fini") {
  can_be_in_process = true
  sources = [ "init-fini.cc" ]
  deps = [ "../.." ]
}

test_executable("tls-exec-only") {
  can_be_in_process = true
  sources = [ "tls-exec-only.cc" ]
  deps = [
    "../..",
    "//src/lib/elfldltl",
  ]
}

test_executable("tls-shlib-only") {
  can_be_in_process = true
  sources = [ "tls-shlib-only.cc" ]
  deps = [
    ":tls-dep",
    "../..",
  ]
}

test_shared_library("tls-dep") {
  public = [ "tls-dep.h" ]
  sources = [ "tls-dep.cc" ]
  deps = [ "//zircon/system/public" ]
}

test_executable("tls-exec-shlib") {
  can_be_in_process = true
  sources = [ "tls-exec-shlib.cc" ]
  deps = [
    ":tls-dep",
    "../..",
  ]
}
