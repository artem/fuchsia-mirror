# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_unittest_package.gni")
import("//build/cpp/library_headers.gni")
import("//build/cpp/verify_public_symbols.gni")
import("//build/test.gni")
import("//build/toolchain/ifs_extract.gni")
import("//build/toolchain/ifs_shared_library.gni")
import("//build/toolchain/zircon/user_basic_redirect.gni")

ldso_name = "ld.so.1"

# TODO(fxbug.dev/121817): This will be used for the static library of support
# code.  It provides access to additional <lib/ld/...> headers for support code
# that isn't itself part of of the passive ABI.
library_headers("headers") {
  headers = []

  public_deps = [ ":abi-headers" ]
}

# This is the linkable target for using the passive ABI.
# It gives access to the passive ABI dynamic linkage symbols
# and to the header files declaring the `ld::abi` namespace.
ifs_shared_library("ld") {
  abi = "ld.ifs"
  public_deps = [ ":abi-headers" ]
}

library_headers("abi-headers") {
  headers = [
    "lib/ld/abi.h",
    "lib/ld/module.h",
  ]

  public_deps = [
    "//sdk/lib/stdcompat",
    "//src/lib/elfldltl:headers",
  ]
}

# This is the SONAME reflecting the passive ABI defined here.
# It has to match what's in ld.ifs and in ld::abi::kSoname (<lib/ld/abi.h>).
config("abi-soname") {
  ldflags = [ "-Wl,-soname=ld.so.1" ]
}

# `verify_ld_abi(ld) {}` defines "$ld.verify-abi" to check that the
# shared_library(ld) or loadable_module(ld) matches the passive ABI.
template("verify_ld_abi") {
  ld_target = target_name
  extract_target = "$ld_target.ifs"
  verify_target = "$ld_target.verify-abi"
  ifs_file = "$target_out_dir/$extract_target"

  ifs_extract(extract_target) {
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    outputs = [ ifs_file ]
    deps = [ ":$ld_target" ]
  }

  verify_public_symbols(verify_target) {
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    deps = [ ":$extract_target" ]
    current = ifs_file
    reference = "ld.ifs"
    library_name = get_label_info(":$ld_target", "label_with_toolchain")
  }
}

# There's no real difference between a shared library and a loadable module
# with a SONAME, but loadable_module() does its own variant selection.  Since
# the stub ld.so is really just a data ABI image, there's no meaningful sense
# in which it could be in the same variant as its users.
loadable_module("stub-ld") {
  configs += [
    "//build/config/fuchsia:no_cpp_standard_library",
    "//build/config/zircon:nolibc",
    ":abi-soname",
  ]
  deps = [ ":abi" ]

  # Since it has no C++ code (only a data definition), it doesn't really matter
  # for this to use the user.basic build environment as the startup dynamic
  # linker must.  But we don't want it to have any instrumentation hair that
  # might be generated even with no C++ functions.
  exclude_toolchain_tags = [ "instrumented" ]
}

verify_ld_abi("stub-ld") {
}

source_set("abi") {
  visibility = [ ":*" ]

  public = [ "mutable-abi.h" ]
  sources = [ "mutable-abi.cc" ]
  deps = [ ":headers" ]
}

ldso_test_loc = "test/${toolchain_variant.libprefix}$ldso_name"

loadable_module("startup-ld") {
  sources = [
    "bootstrap.cc",
    "standalone-assert.cc",
  ]

  ldflags = [ "-Wl,-soname,$ldso_name" ]

  deps = [
    "//src/lib/elfldltl",
    "//zircon/system/ulib/c/string:mem",
    "//zircon/third_party/ulib/musl/src/exit:abort",
  ]

  if (!is_gcc) {
    # The standard profiling runtime can't be used in the minimal standalone
    # context of ld.so.
    #
    # TODO(fxbug.dev/130542): The instrumentation works fine to collect data,
    # but the data needs to be plumbed out somewhere using a custom
    # runtime. For now, the data is just ignored.
    ldflags += [ "-noprofilelib" ]
  }

  test_libname = "test/${toolchain_variant.libprefix}$ldso_name"

  metadata = {
    distribution_entries = [
      {
        destination = "lib/$ldso_test_loc"
        source = rebase_path("$root_out_dir/startup-ld.so", root_build_dir)
        label = get_label_info(target_name, "label_with_toolchain")
      },
    ]

    # This is collected by ld-startup-test-switches.rsp, below.  The
    # user_basic_redirect may wind up in a different variant than the one
    # requested, if the test's variant isn't available in user.basic, so we
    # don't know statically which libprefix the test should load from.
    ld_startup_test_switches = [ "'-DLD_STARTUP_TEST_LIB=\"$test_libname\"'" ]
  }
}

user_basic_redirect("ld.basic") {
  public_deps = [ ":startup-ld" ]
}

# This collects the -DLD_STARTUP_TEST_LIB=... flag in the response file.
generated_file("ld-startup-test-switches.rsp") {
  visibility = [ ":*" ]
  testonly = true
  output_conversion = "list lines"
  data_keys = [ "ld_startup_test_switches" ]
  outputs = [ "$target_gen_dir/$target_name" ]
  data_deps = [ ":ld.basic" ]
}

source_set("target-unittests") {
  testonly = true
  sources = [ "ld-startup-tests.cc" ]
  deps = [
    "//src/lib/elfldltl",
    "//src/lib/elfldltl:elfldltl-testutils",
    "//src/lib/fxl/test:gtest_main",
    "//zircon/system/ulib/zx",
  ]

  # Bring the ld.so image into the package.
  data_deps = [ ":ld.basic" ]

  # Plumb in the switch via the response file to give the name under lib/ that
  # the test can pass to fuchsia.ldsvc.Loader/LoadObject.
  deps += [ ":ld-startup-test-switches.rsp" ]
  inputs = get_target_outputs(":ld-startup-test-switches.rsp")
  cflags = [ "@" + rebase_path(inputs[0], root_build_dir) ]
}

test("ld-unittests") {
  sources = [ "abi-tests.cc" ]
  deps = [
    ":headers",
    "//src/lib/fxl/test:gtest_main",
  ]

  if (!is_host) {
    deps += [ ":target-unittests" ]
  }
}

fuchsia_unittest_package("ld-tests") {
  deps = [ ":ld-unittests" ]
}

group("tests") {
  testonly = true

  deps = [
    ":ld-tests",
    ":ld-unittests($host_toolchain)",
    ":stub-ld.verify-abi",
  ]
}
