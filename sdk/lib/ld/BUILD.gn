# Copyright 2023 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_unittest_package.gni")
import("//build/cpp/library_headers.gni")
import("//build/cpp/verify_public_symbols.gni")
import("//build/test.gni")
import("//build/toolchain/ifs_extract.gni")
import("//build/toolchain/ifs_shared_library.gni")
import("//build/toolchain/toolchain_environment.gni")
import("//build/toolchain/zircon/user_basic_redirect.gni")

is_elf = current_os != "mac" && current_os != "win"

# TODO(fxbug.dev/121817): This will be used for the static library of support
# code.  It provides access to additional <lib/ld/...> headers for support code
# that isn't itself part of of the passive ABI.
library_headers("headers") {
  headers = []

  public_deps = [ ":abi-headers" ]
}

# This is the linkable target for using the passive ABI.
# It gives access to the passive ABI dynamic linkage symbols
# and to the header files declaring the `ld::abi` namespace.
ifs_shared_library("ld") {
  abi = "ld.ifs"
  public_deps = [ ":abi-headers" ]
}

library_headers("abi-headers") {
  headers = [
    "lib/ld/abi.h",
    "lib/ld/module.h",
  ]

  public_deps = [
    "//sdk/lib/stdcompat",
    "//src/lib/elfldltl:headers",
  ]
}

# This is the SONAME reflecting the passive ABI defined here.
# It has to match what's in ld.ifs and in ld::abi::kSoname (<lib/ld/abi.h>).
abi_soname = "ld.so.1"
config("abi-soname") {
  ldflags = [ "-Wl,-soname=$abi_soname" ]
}

# `verify_ld_abi(ld) {}` defines "$ld.verify-abi" to check that the
# shared_library(ld) or loadable_module(ld) matches the passive ABI.
template("verify_ld_abi") {
  ld_target = target_name
  extract_target = "$ld_target.ifs"
  verify_target = "$ld_target.verify-abi"
  ifs_file = "$target_out_dir/$extract_target"

  ifs_extract(extract_target) {
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    outputs = [ ifs_file ]
    deps = [ ":$ld_target" ]
  }

  verify_public_symbols(verify_target) {
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    deps = [ ":$extract_target" ]
    current = ifs_file
    reference = "ld.ifs"
    library_name = get_label_info(":$ld_target", "label_with_toolchain")
  }
}

# There's no real difference between a shared library and a loadable module
# with a SONAME, but loadable_module() does its own variant selection.  Since
# the stub ld.so is really just a data ABI image, there's no meaningful sense
# in which it could be in the same variant as its users.
loadable_module("ld-stub") {
  configs += [
    "//build/config/fuchsia:no_cpp_standard_library",
    "//build/config/zircon:nolibc",
    ":abi-soname",
  ]
  deps = [ ":abi" ]

  # Since it has no C++ code (only a data definition), it doesn't really matter
  # for this to use the user.basic build environment as the startup dynamic
  # linker must.  But we don't want it to have any instrumentation hair that
  # might be generated even with no C++ functions.
  exclude_toolchain_tags = [ "instrumented" ]
}

verify_ld_abi("ld-stub") {
}

source_set("abi") {
  visibility = [ ":*" ]

  public = [ "mutable-abi.h" ]
  sources = [ "mutable-abi.cc" ]
  deps = [ ":headers" ]
}

source_set("bootstrap") {
  visibility = [ ":*" ]

  public = [ "bootstrap.h" ]
  public_deps = [
    ":headers",
    "//src/lib/elfldltl",
  ]
}

# This is a proper archive library of the bits from libc and the stubs that can
# be used in the standalone implementation.  Having the source_set() targets as
# direct or transitive deps not via a `complete_static_lib=true` archive would
# eagerly link unused code into the standalone binary and rely on linker GC to
# remove it, which is suboptimal.
static_library("standalone") {
  visibility = [ ":*" ]

  complete_static_lib = true

  sources = [ "standalone-assert.cc" ]
  deps = [
    "//zircon/system/public",
    "//zircon/system/ulib/c/string:hermetic",
    "//zircon/third_party/ulib/musl/src/exit:abort",
  ]

  public_configs = [ ":standalone.config" ]
}

config("standalone.config") {
  visibility = [ ":*" ]
  if (toolchain_environment != "user.basic") {
    # The user.basic environment doesn't have implicit dependencies or libc.
    # Other environments like host need the compiler driver's defaults disabled
    # to build something that doesn't use the system libc.
    ldflags = [
      "-nostartfiles",
      "-nolibc",
    ]
  }
}

source_set("posix-header") {
  public = [ "posix.h" ]
}

shared_library("ld-startup") {
  configs += [ ":abi-soname" ]

  sources = []
  deps = [
    ":bootstrap",
    ":diagnostics",
    ":standalone",
    "//src/lib/elfldltl",
  ]

  if (is_fuchsia) {
    sources += [ "zircon-startup.cc" ]
    deps += [
      "//src/zircon/lib/zircon",
      "//zircon/system/ulib/zx",
    ]
  } else {
    sources += [
      "posix-startup.S",
      "posix-startup.cc",
    ]
    deps += [
      ":posix-header",
      "//zircon/kernel/lib/arch:headers",
    ]
    if (is_linux) {
      deps += [ ":linux-syscalls" ]
    }
  }

  if (!is_gcc) {
    # The standard profiling runtime can't be used in the minimal standalone
    # context of ld.so.
    #
    # TODO(fxbug.dev/130542): The instrumentation works fine to collect data,
    # but the data needs to be plumbed out somewhere using a custom
    # runtime. For now, the data is just ignored.
    ldflags = [ "-noprofilelib" ]
  }

  if (is_fuchsia) {
    output_path = "$root_out_dir/lib$target_name.so"
    test_libname = "test/${toolchain_variant.libprefix}$abi_soname"

    metadata = {
      distribution_entries = [
        {
          destination = "lib/$test_libname"
          source = rebase_path(output_path, root_build_dir)
          label = get_label_info(target_name, "label_with_toolchain")
        },
      ]

      # This is collected by ld-startup-test-switches.rsp, below.  The
      # user_basic_redirect may wind up in a different variant than the one
      # requested, if the test's variant isn't available in user.basic, so we
      # don't know statically which libprefix the test should load from.
      ld_startup_test_switches = [ "'-DLD_STARTUP_TEST_LIB=\"$test_libname\"'" ]
    }
  }
}

source_set("diagnostics") {
  visibility = [ ":*" ]
  public = [ "diagnostics.h" ]
  public_deps = [ "//src/lib/elfldltl" ]
  sources = [ "diagnostics.cc" ]
}

source_set("linux-syscalls") {
  visibility = [ ":*" ]
  sources = [ "linux-syscalls.cc" ]
  include_dirs = [ "//third_party/linux-syscall-support/src" ]
}

user_basic_redirect("ld-startup.basic") {
  public_deps = [ ":ld-startup" ]
}

# This collects the -DLD_STARTUP_TEST_LIB=... flag in the response file.
generated_file("ld-startup-test-switches.rsp") {
  visibility = [ ":*" ]
  testonly = true
  output_conversion = "list lines"
  data_keys = [ "ld_startup_test_switches" ]
  outputs = [ "$target_gen_dir/$target_name" ]
  data_deps = [ ":ld-startup.basic" ]
}

source_set("load-tests") {
  visibility = [ ":*" ]
  testonly = true

  sources = [ "ld-startup-tests.cc" ]
  deps = [
    ":posix-header",
    "//src/lib/elfldltl",
    "//src/lib/elfldltl:elfldltl-testutils",
    "//third_party/googletest:gtest",
  ]
  if (is_fuchsia) {
    deps += [ "//zircon/system/ulib/zx" ]
  }

  if (is_fuchsia) {
    # Plumb in the switch via the response file to give the name under lib/
    # that the test can pass to fuchsia.ldsvc.Loader/LoadObject.
    deps += [ ":ld-startup-test-switches.rsp" ]
    inputs = get_target_outputs(":ld-startup-test-switches.rsp")
    cflags = [ "@" + rebase_path(inputs[0], root_build_dir) ]
  } else {
    defines = [ "LD_STARTUP_TEST_LIB=\"libld-startup.so\"" ]
  }

  data_deps = [ ":load-test-data" ]
}

if (is_host) {
  test_shlib_tc = ""
  test_shlib_out_dir = root_out_dir
  if (is_linux) {
    # The linux_$cpu (vs host_$cpu) handles shared libraries.
    test_shlib_tc = "(//build/toolchain:linux_$current_cpu-shared)"
    test_shlib_out_dir = get_label_info(":here$test_shlib_tc", "root_out_dir")
  }

  # For host tests, the test binaries must be packaged in host_test_data() at
  # the expected path where elfldltl::testing::GetTestLib will find them.
  host_test_data("load-test-data") {
    visibility = [ ":*" ]

    deps = []
    sources = []
    outputs = [ "$root_out_dir/test_data/elfldltl/{{source_file_part}}" ]

    deps += [ ":ld-startup$test_shlib_tc" ]
    sources += [ "$test_shlib_out_dir/libld-startup.so" ]
  }
} else {
  # On Fuchsia these are just included in /pkg/lib implicitly by dint
  # of being in data_deps of the test code.
  group("load-test-data") {
    visibility = [ ":*" ]
    testonly = true
    deps = [ ":ld-startup.basic" ]
  }
}

test("ld-unittests") {
  sources = [ "abi-tests.cc" ]
  deps = [
    ":headers",
    "//src/lib/fxl/test:gtest_main",
  ]

  if (is_elf) {
    deps += [ ":load-tests" ]
  }
}

fuchsia_unittest_package("ld-tests") {
  deps = [ ":ld-unittests" ]
}

group("tests") {
  testonly = true

  deps = [
    ":ld-stub.verify-abi",
    ":ld-tests",
    ":ld-unittests($host_toolchain)",
  ]
}
