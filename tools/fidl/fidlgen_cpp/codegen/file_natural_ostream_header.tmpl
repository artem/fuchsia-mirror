{{/*
// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Filename:NaturalOStreamHeader" -}}
  fidl/{{ .LibraryDots }}/cpp/natural_ostream.h
{{- end }}

{{- define "File:NaturalOStreamHeader" -}}
  {{- UseUnified -}}
  // WARNING: This file is machine generated by fidlgen.
  {{ range $experiment := .Experiments }}
  // fidl_experiment = {{ $experiment }}
  {{- end }}

  #pragma once

  #include <iostream>
  #include <lib/fidl/cpp/natural_ostream.h>
  {{ if .ContainsDriverReferences -}}
    #include <lib/fidl_driver/cpp/natural_ostream.h>
  {{ end -}}

  #include <{{ .Library | Filename "NaturalTypesHeader" }}>

  {{ range .Dependencies -}}
    #include <{{ . | Filename "NaturalOStreamHeader" }}>
  {{ end }}

  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wshadow"

  {{ EnsureNamespace "" }}
  {{- range .Decls }}
    {{- if and (ne .Kind Kinds.Alias) (ne .Kind Kinds.Const) (ne .Kind Kinds.Protocol) (ne .Kind Kinds.Service) }}
      {{- if .IsResourceType }}
        {{- IfdefFuchsia }}
      {{- end }}
      template<>
      struct fidl::ostream::Formatter<{{ . }}> {
        static std::ostream& Format(std::ostream& os, const {{ . }}& value);
      };
      {{- if .IsResourceType }}
        {{- EndifFuchsia -}}
      {{- end }}
    {{- end }}
  {{- end }}

  {{ range .Decls }}
    {{ EnsureNamespace . }}
    {{- if and (ne .Kind Kinds.Alias) (ne .Kind Kinds.Const) (ne .Kind Kinds.Protocol) (ne .Kind Kinds.Service) }}
      {{- if .IsResourceType }}
        {{- IfdefFuchsia }}
      {{- end }}
      std::ostream& operator<<(std::ostream& os, const {{ . }}& value);
      {{- if .IsResourceType }}
        {{- EndifFuchsia -}}
      {{- end }}
    {{- end }}
  {{- end }}

  {{ EnsureNamespace "" }}
  {{- IfdefFuchsia }}
    {{- range .Protocols }}
      {{- if .Transport }}
        template<>
        struct fidl::ostream::Formatter<{{ .ClientEnd }}> {
          static std::ostream& Format(std::ostream& os, const {{ .ClientEnd }}& value) {
            return os << "ClientEnd<" << "{{ .NoLeading }}" << ">(" << value.channel().get() << ")";
          }
        };

        template<>
        struct fidl::ostream::Formatter<{{ .ServerEnd }}> {
          static std::ostream& Format(std::ostream& os, const {{ .ServerEnd }}& value) {
            return os << "ServerEnd<" << "{{ .NoLeading }}" << ">(" << value.channel().get() << ")";
          }
        };
      {{- end }}
    {{- end }}

    {{ range .Protocols }}
      {{- if .Transport }}
        {{ EnsureNamespace .Transport.Namespace }}

        inline std::ostream& operator<<(std::ostream& os, const {{ .ClientEnd }}& value) {
            return fidl::ostream::Formatter<{{ .ClientEnd }}>::Format(os, value);
        }

        inline std::ostream& operator<<(std::ostream& os, const {{ .ServerEnd }}& value) {
            return fidl::ostream::Formatter<{{ .ServerEnd }}>::Format(os, value);
        }
      {{- end }}
    {{- end }}
  {{- EndifFuchsia }}

  #pragma clang diagnostic pop

  {{ EndOfFile }}
{{- end }}
