// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = output_index_json

#pragma once

#include <lib/fidl/cpp/wire/array.h>
#include <lib/fidl/cpp/wire/envelope.h>
#include <lib/fidl/cpp/wire/internal/framework_err.h>
#include <lib/fidl/cpp/wire/message.h>
#include <lib/fidl/cpp/wire/message_storage.h>
#include <lib/fidl/cpp/wire/object_view.h>
#include <lib/fidl/cpp/wire/string_view.h>
#include <lib/fidl/cpp/wire/traits.h>
#include <lib/fidl/cpp/wire/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__

#endif  // __Fuchsia__

#include <fidl/test.padding/cpp/common_types.h>
#include <fidl/test.padding/cpp/markers.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshadow"

namespace test_padding {

namespace wire {

struct Padding1ByteEnd;

struct Padding2ByteEnd;

struct Padding3ByteEnd;

struct Padding4ByteEnd;

struct Padding5ByteEnd;

struct Padding6ByteEnd;

struct Padding7ByteEnd;

struct Padding1ByteMiddle;

struct Padding2ByteMiddle;

struct Padding3ByteMiddle;

struct Padding4ByteMiddle;

struct Padding5ByteMiddle;

struct Padding6ByteMiddle;

struct Padding7ByteMiddle;

struct Padding4ByteAlignmentLength12;

struct Padding2ByteAlignmentLength6;

struct Padding1ByteEnd {
  uint16_t a = {};

  uint8_t b = {};
};

struct Padding1ByteMiddle {
  uint8_t a = {};

  uint16_t b = {};
};

struct Padding2ByteEnd {
  uint32_t a = {};

  uint16_t b = {};
};

struct Padding3ByteEnd {
  uint32_t a = {};

  uint8_t b = {};
};

struct Padding4ByteEnd {
  uint64_t a = {};

  uint32_t b = {};
};

struct Padding5ByteEnd {
  uint64_t a = {};

  uint16_t b = {};

  uint8_t c = {};
};

struct Padding6ByteEnd {
  uint64_t a = {};

  uint16_t b = {};
};

struct Padding7ByteEnd {
  uint64_t a = {};

  uint8_t b = {};
};

struct Padding2ByteMiddle {
  uint16_t a = {};

  uint32_t b = {};
};

struct Padding3ByteMiddle {
  uint8_t a = {};

  uint32_t b = {};
};

struct Padding4ByteMiddle {
  uint32_t a = {};

  uint64_t b = {};
};

struct Padding5ByteMiddle {
  uint16_t a = {};

  uint8_t b = {};

  uint64_t c = {};
};

struct Padding6ByteMiddle {
  uint16_t a = {};

  uint64_t b = {};
};

struct Padding7ByteMiddle {
  uint8_t a = {};

  uint64_t b = {};
};

struct Padding4ByteAlignmentLength12 {
  uint32_t a = {};

  uint8_t b = {};

  uint16_t c = {};

  uint16_t d = {};
};

struct Padding2ByteAlignmentLength6 {
  uint8_t a = {};

  uint16_t b = {};

  uint8_t c = {};
};

}  // namespace wire
}  // namespace test_padding
namespace fidl {

template <>
struct TypeTraits<::test_padding::wire::Padding1ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding1ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding1ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding1ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding1ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding1ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding1ByteEnd, b) == 2);
static_assert(sizeof(::test_padding::wire::Padding1ByteEnd) == TypeTraits<::test_padding::wire::Padding1ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding1ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding1ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding1ByteEnd));
    } else {
      internal::WireZeroPadding<uint16_t>(encoder, position + 2);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 2, recursion_depth);
    }
    internal::WireCheckPadding<uint16_t>(decoder, position + 2, 0xff00);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding2ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding2ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding2ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding2ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding2ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding2ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding2ByteEnd, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding2ByteEnd) == TypeTraits<::test_padding::wire::Padding2ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding2ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding2ByteEnd));
    } else {
      internal::WireZeroPadding<uint32_t>(encoder, position + 4);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 4, recursion_depth);
    }
    internal::WireCheckPadding<uint32_t>(decoder, position + 4, 0xffff0000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding3ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding3ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding3ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding3ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding3ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding3ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding3ByteEnd, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding3ByteEnd) == TypeTraits<::test_padding::wire::Padding3ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding3ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding3ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding3ByteEnd));
    } else {
      internal::WireZeroPadding<uint32_t>(encoder, position + 4);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 4, recursion_depth);
    }
    internal::WireCheckPadding<uint32_t>(decoder, position + 4, 0xffffff00);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding4ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding4ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding4ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding4ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding4ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding4ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding4ByteEnd, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding4ByteEnd) == TypeTraits<::test_padding::wire::Padding4ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding4ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding4ByteEnd));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 8);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffff00000000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding5ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding5ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding5ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding5ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding5ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding5ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding5ByteEnd, b) == 8);
static_assert(offsetof(::test_padding::wire::Padding5ByteEnd, c) == 10);
static_assert(sizeof(::test_padding::wire::Padding5ByteEnd) == TypeTraits<::test_padding::wire::Padding5ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding5ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding5ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding5ByteEnd));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 8);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 10, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 10, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffff000000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding6ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding6ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding6ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding6ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding6ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding6ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding6ByteEnd, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding6ByteEnd) == TypeTraits<::test_padding::wire::Padding6ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding6ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding6ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding6ByteEnd));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 8);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffffff0000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding7ByteEnd> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding7ByteEnd> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding7ByteEnd> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding7ByteEnd> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding7ByteEnd>);
static_assert(offsetof(::test_padding::wire::Padding7ByteEnd, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding7ByteEnd, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding7ByteEnd) == TypeTraits<::test_padding::wire::Padding7ByteEnd>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding7ByteEnd, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding7ByteEnd* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding7ByteEnd));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 8);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 8, 0xffffffffffffff00);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding1ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding1ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding1ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding1ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding1ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding1ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding1ByteMiddle, b) == 2);
static_assert(sizeof(::test_padding::wire::Padding1ByteMiddle) == TypeTraits<::test_padding::wire::Padding1ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 4;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding1ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding1ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding1ByteMiddle));
    } else {
      internal::WireZeroPadding<uint16_t>(encoder, position + 0);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 2, recursion_depth);
    }
    internal::WireCheckPadding<uint16_t>(decoder, position + 0, 0xff00);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding2ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding2ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding2ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding2ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding2ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding2ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding2ByteMiddle, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding2ByteMiddle) == TypeTraits<::test_padding::wire::Padding2ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding2ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding2ByteMiddle));
    } else {
      internal::WireZeroPadding<uint32_t>(encoder, position + 0);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 4, recursion_depth);
    }
    internal::WireCheckPadding<uint32_t>(decoder, position + 0, 0xffff0000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding3ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding3ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding3ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding3ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding3ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding3ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding3ByteMiddle, b) == 4);
static_assert(sizeof(::test_padding::wire::Padding3ByteMiddle) == TypeTraits<::test_padding::wire::Padding3ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 8;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding3ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding3ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding3ByteMiddle));
    } else {
      internal::WireZeroPadding<uint32_t>(encoder, position + 0);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 4, recursion_depth);
    }
    internal::WireCheckPadding<uint32_t>(decoder, position + 0, 0xffffff00);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding4ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding4ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding4ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding4ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding4ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding4ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding4ByteMiddle, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding4ByteMiddle) == TypeTraits<::test_padding::wire::Padding4ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding4ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding4ByteMiddle));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffff00000000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding5ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding5ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding5ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding5ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding5ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding5ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding5ByteMiddle, b) == 2);
static_assert(offsetof(::test_padding::wire::Padding5ByteMiddle, c) == 8);
static_assert(sizeof(::test_padding::wire::Padding5ByteMiddle) == TypeTraits<::test_padding::wire::Padding5ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding5ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding5ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding5ByteMiddle));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 2, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffffff000000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding6ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding6ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding6ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding6ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding6ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding6ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding6ByteMiddle, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding6ByteMiddle) == TypeTraits<::test_padding::wire::Padding6ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding6ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding6ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding6ByteMiddle));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffffffff0000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding7ByteMiddle> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding7ByteMiddle> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding7ByteMiddle> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding7ByteMiddle> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding7ByteMiddle>);
static_assert(offsetof(::test_padding::wire::Padding7ByteMiddle, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding7ByteMiddle, b) == 8);
static_assert(sizeof(::test_padding::wire::Padding7ByteMiddle) == TypeTraits<::test_padding::wire::Padding7ByteMiddle>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding7ByteMiddle, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding7ByteMiddle* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding7ByteMiddle));
    } else {
      internal::WireZeroPadding<uint64_t>(encoder, position + 0);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint64_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint64_t>(decoder, position + 0, 0xffffffffffffff00);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding4ByteAlignmentLength12> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 12;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding4ByteAlignmentLength12> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding4ByteAlignmentLength12> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding4ByteAlignmentLength12> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding4ByteAlignmentLength12>);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, b) == 4);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, c) == 6);
static_assert(offsetof(::test_padding::wire::Padding4ByteAlignmentLength12, d) == 8);
static_assert(sizeof(::test_padding::wire::Padding4ByteAlignmentLength12) == TypeTraits<::test_padding::wire::Padding4ByteAlignmentLength12>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 12;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding4ByteAlignmentLength12, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding4ByteAlignmentLength12* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding4ByteAlignmentLength12));
    } else {
      internal::WireZeroPadding<uint32_t>(encoder, position + 4);
      internal::WireZeroPadding<uint32_t>(encoder, position + 8);
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 4, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 6, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->d, position + 8, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 4, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 6, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 8, recursion_depth);
    }
    internal::WireCheckPadding<uint32_t>(decoder, position + 4, 0xff00);
    internal::WireCheckPadding<uint32_t>(decoder, position + 8, 0xffff0000);
  }
};

template <>
struct TypeTraits<::test_padding::wire::Padding2ByteAlignmentLength6> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 6;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_padding::wire::Padding2ByteAlignmentLength6> : public std::true_type {};
template <>
struct IsWire<::test_padding::wire::Padding2ByteAlignmentLength6> : public std::true_type {};
template <>
struct IsStruct<::test_padding::wire::Padding2ByteAlignmentLength6> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_padding::wire::Padding2ByteAlignmentLength6>);
static_assert(offsetof(::test_padding::wire::Padding2ByteAlignmentLength6, a) == 0);
static_assert(offsetof(::test_padding::wire::Padding2ByteAlignmentLength6, b) == 2);
static_assert(offsetof(::test_padding::wire::Padding2ByteAlignmentLength6, c) == 4);
static_assert(sizeof(::test_padding::wire::Padding2ByteAlignmentLength6) == TypeTraits<::test_padding::wire::Padding2ByteAlignmentLength6>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t kInlineSize = 6;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>(), ::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = true;
  using Base = WireStructCodingTraitsBase<::test_padding::wire::Padding2ByteAlignmentLength6, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool kIsMemcpyCompatible = Base::kIsMemcpyCompatible;

  static void Encode(
      internal::WireEncoder* encoder, ::test_padding::wire::Padding2ByteAlignmentLength6* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (kIsMemcpyCompatible) {
      memcpy(position.As<void>(), value, sizeof(::test_padding::wire::Padding2ByteAlignmentLength6));
    } else {
      internal::WireZeroPadding<uint16_t>(encoder, position + 0);
      internal::WireZeroPadding<uint16_t>(encoder, position + 4);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->a, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->b, position + 2, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->c, position + 4, recursion_depth);
    }
  }
  static void Decode(
      internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 0, recursion_depth);
      internal::WireCodingTraits<uint16_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 2, recursion_depth);
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
          decoder, position + 4, recursion_depth);
    }
    internal::WireCheckPadding<uint16_t>(decoder, position + 0, 0xff00);
    internal::WireCheckPadding<uint16_t>(decoder, position + 4, 0xff00);
  }
};

#pragma clang diagnostic pop

}  // namespace fidl
