// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = unknown_interactions
// fidl_experiment = unknown_interactions_mandate

#![warn(clippy::all)]
#![allow(unused_parens, unused_mut, unused_imports, nonstandard_style)]

use {
    bitflags::bitflags,
    fidl::{
        client::QueryResponseFut,
        endpoints::{ControlHandle as _, Responder as _},
    },
    fuchsia_zircon_status as zx_status,
    futures::future::{self, MaybeDone, TryFutureExt},
};

#[cfg(target_os = "fuchsia")]
use fuchsia_zircon as zx;

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum MyEmptyFlexibleEnum {
    #[doc(hidden)]
    __SourceBreaking { unknown_ordinal: u32 },
}

/// Pattern that matches an unknown `MyEmptyFlexibleEnum` member.
#[macro_export]
macro_rules! MyEmptyFlexibleEnumUnknown {
    () => {
        _
    };
}

impl MyEmptyFlexibleEnum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            unknown_ordinal => Self::__SourceBreaking { unknown_ordinal },
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0xffffffff }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { unknown_ordinal: _ } => true,
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum MyFlexibleEnum {
    Foo,
    Bar,
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u32,
    },
}

/// Pattern that matches an unknown `MyFlexibleEnum` member.
#[macro_export]
macro_rules! MyFlexibleEnumUnknown {
    () => {
        _
    };
}

impl MyFlexibleEnum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Foo),
            2 => Some(Self::Bar),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Foo,
            2 => Self::Bar,
            unknown_ordinal => Self::__SourceBreaking { unknown_ordinal },
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0xffffffff }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Foo => 1,
            Self::Bar => 2,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { unknown_ordinal: _ } => true,
            _ => false,
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum MyFlexibleEnumWithCustomUnknown {
    Foo,
    Bar,
    CustomUnknown,
    #[doc(hidden)]
    __SourceBreaking {
        unknown_ordinal: u32,
    },
}

/// Pattern that matches an unknown `MyFlexibleEnumWithCustomUnknown` member.
#[macro_export]
macro_rules! MyFlexibleEnumWithCustomUnknownUnknown {
    () => {
        _
    };
}

impl MyFlexibleEnumWithCustomUnknown {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Foo),
            2 => Some(Self::Bar),
            3 => Some(Self::CustomUnknown),
            _ => None,
        }
    }

    #[inline]
    pub fn from_primitive_allow_unknown(prim: u32) -> Self {
        match prim {
            1 => Self::Foo,
            2 => Self::Bar,
            3 => Self::CustomUnknown,
            unknown_ordinal => Self::__SourceBreaking { unknown_ordinal },
        }
    }

    #[inline]
    pub fn unknown() -> Self {
        Self::__SourceBreaking { unknown_ordinal: 0x3 }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        match self {
            Self::Foo => 1,
            Self::Bar => 2,
            Self::CustomUnknown => 3,
            Self::__SourceBreaking { unknown_ordinal } => unknown_ordinal,
        }
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        match self {
            Self::__SourceBreaking { unknown_ordinal: _ } => true,
            _ => false,
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(u32)]
pub enum MyStrictEnum {
    Foo = 1,
    Bar = 2,
}

impl MyStrictEnum {
    #[inline]
    pub fn from_primitive(prim: u32) -> Option<Self> {
        match prim {
            1 => Some(Self::Foo),
            2 => Some(Self::Bar),
            _ => None,
        }
    }

    #[inline]
    pub const fn into_primitive(self) -> u32 {
        self as u32
    }

    #[deprecated = "Strict enums should not use `is_unknown`"]
    #[inline]
    pub fn is_unknown(&self) -> bool {
        false
    }
}

mod internal {
    use super::*;
    unsafe impl fidl::encoding::TypeMarker for MyEmptyFlexibleEnum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for MyEmptyFlexibleEnum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for MyEmptyFlexibleEnum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for MyEmptyFlexibleEnum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for MyFlexibleEnum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for MyFlexibleEnum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for MyFlexibleEnum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for MyFlexibleEnum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for MyFlexibleEnumWithCustomUnknown {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            false
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for MyFlexibleEnumWithCustomUnknown {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for MyFlexibleEnumWithCustomUnknown {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for MyFlexibleEnumWithCustomUnknown {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::unknown()
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive_allow_unknown(prim);
            Ok(())
        }
    }
    unsafe impl fidl::encoding::TypeMarker for MyStrictEnum {
        type Owned = Self;

        #[inline(always)]
        fn inline_align(_context: fidl::encoding::Context) -> usize {
            std::mem::align_of::<u32>()
        }

        #[inline(always)]
        fn inline_size(_context: fidl::encoding::Context) -> usize {
            std::mem::size_of::<u32>()
        }

        #[inline(always)]
        fn encode_is_copy() -> bool {
            true
        }

        #[inline(always)]
        fn decode_is_copy() -> bool {
            false
        }
    }

    impl fidl::encoding::ValueTypeMarker for MyStrictEnum {
        type Borrowed<'a> = Self;
        #[inline(always)]
        fn borrow<'a>(
            value: &'a <Self as fidl::encoding::TypeMarker>::Owned,
        ) -> Self::Borrowed<'a> {
            *value
        }
    }

    unsafe impl fidl::encoding::Encode<Self> for MyStrictEnum {
        #[inline]
        unsafe fn encode(
            self,
            encoder: &mut fidl::encoding::Encoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            encoder.debug_check_bounds::<Self>(offset);
            encoder.write_num(self.into_primitive(), offset);
            Ok(())
        }
    }

    impl fidl::encoding::Decode<Self> for MyStrictEnum {
        #[inline(always)]
        fn new_empty() -> Self {
            Self::Foo
        }

        #[inline]
        unsafe fn decode(
            &mut self,
            decoder: &mut fidl::encoding::Decoder<'_>,
            offset: usize,
            _depth: fidl::encoding::Depth,
        ) -> fidl::Result<()> {
            decoder.debug_check_bounds::<Self>(offset);
            let prim = decoder.read_num::<u32>(offset);

            *self = Self::from_primitive(prim).ok_or(fidl::Error::InvalidEnumValue)?;
            Ok(())
        }
    }
}
