// WARNING: This file is machine generated by fidlgen.

// fidl_experiment = no_optional_structs
// fidl_experiment = output_index_json
// fidl_experiment = transitional_allow_list

#pragma once

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
#include <test/unknowninteractions/cpp/fidl.h>
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {


using UnknownInteractionsProtocolStrictTwoWayFieldsResponse = ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayFieldsResponse;
using UnknownInteractionsProtocolStrictTwoWayUnionResponse = ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayUnionResponse;
using UnknownInteractionsProtocolStrictTwoWayTableResponse = ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayTableResponse;
using UnknownInteractionsProtocol_StrictTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response;
using UnknownInteractionsProtocol_StrictTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result;
using UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response;
using UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result;
using UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response;
using UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result;
using UnknownInteractionsProtocol_StrictTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response;
using UnknownInteractionsProtocol_StrictTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Result;
using UnknownInteractionsProtocol_FlexibleTwoWay_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response;
using UnknownInteractionsProtocol_FlexibleTwoWay_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayFields_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayFields_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayTable_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayTable_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result;
using UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response;
using UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result;
using UnknownInteractionsProtocolStrictEventFieldsRequest = ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventFieldsRequest;
using UnknownInteractionsProtocolStrictEventUnionRequest = ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventUnionRequest;
using UnknownInteractionsProtocolStrictEventTableRequest = ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventTableRequest;
using UnknownInteractionsProtocol_StrictEventErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response;
using UnknownInteractionsProtocol_StrictEventErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result;
using UnknownInteractionsProtocol_StrictEventFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response;
using UnknownInteractionsProtocol_StrictEventFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Result;
using UnknownInteractionsProtocol_StrictEventUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response;
using UnknownInteractionsProtocol_StrictEventUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Result;
using UnknownInteractionsProtocol_StrictEventTableErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response;
using UnknownInteractionsProtocol_StrictEventTableErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Result;
using UnknownInteractionsProtocolFlexibleEventFieldsRequest = ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventFieldsRequest;
using UnknownInteractionsProtocolFlexibleEventUnionRequest = ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventUnionRequest;
using UnknownInteractionsProtocolFlexibleEventTableRequest = ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventTableRequest;
using UnknownInteractionsProtocol_FlexibleEventErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response;
using UnknownInteractionsProtocol_FlexibleEventErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result;
using UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response;
using UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result;
using UnknownInteractionsProtocol_FlexibleEventUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response;
using UnknownInteractionsProtocol_FlexibleEventUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Result;
using UnknownInteractionsProtocol_FlexibleEventTableErr_Response = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response;
using UnknownInteractionsProtocol_FlexibleEventTableErr_Result = ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Result;
using UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse = ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse;
using UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse = ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse;
using UnknownInteractionsAjarProtocolStrictTwoWayTableResponse = ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayTableResponse;
using UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response;
using UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result;
using UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response;
using UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result;
using UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response;
using UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result;
using UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response;
using UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result;
using UnknownInteractionsAjarProtocolStrictEventFieldsRequest = ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventFieldsRequest;
using UnknownInteractionsAjarProtocolStrictEventUnionRequest = ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventUnionRequest;
using UnknownInteractionsAjarProtocolStrictEventTableRequest = ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventTableRequest;
using UnknownInteractionsAjarProtocol_StrictEventErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response;
using UnknownInteractionsAjarProtocol_StrictEventErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result;
using UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response;
using UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result;
using UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response;
using UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result;
using UnknownInteractionsAjarProtocol_StrictEventTableErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response;
using UnknownInteractionsAjarProtocol_StrictEventTableErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Result;
using UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest = ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest;
using UnknownInteractionsAjarProtocolFlexibleEventUnionRequest = ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventUnionRequest;
using UnknownInteractionsAjarProtocolFlexibleEventTableRequest = ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventTableRequest;
using UnknownInteractionsAjarProtocol_FlexibleEventErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response;
using UnknownInteractionsAjarProtocol_FlexibleEventErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result;
using UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response;
using UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result;
using UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response;
using UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result;
using UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response;
using UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result;
using UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse = ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse;
using UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse = ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse;
using UnknownInteractionsClosedProtocolStrictTwoWayTableResponse = ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayTableResponse;
using UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response;
using UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result;
using UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response;
using UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result;
using UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response;
using UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result;
using UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response;
using UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result;
using UnknownInteractionsClosedProtocolStrictEventFieldsRequest = ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventFieldsRequest;
using UnknownInteractionsClosedProtocolStrictEventUnionRequest = ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventUnionRequest;
using UnknownInteractionsClosedProtocolStrictEventTableRequest = ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventTableRequest;
using UnknownInteractionsClosedProtocol_StrictEventErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response;
using UnknownInteractionsClosedProtocol_StrictEventErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result;
using UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response;
using UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result;
using UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response;
using UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result;
using UnknownInteractionsClosedProtocol_StrictEventTableErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response;
using UnknownInteractionsClosedProtocol_StrictEventTableErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Result;
using UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse = ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse;
using UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse = ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse;
using UnknownInteractionsDriverProtocolStrictTwoWayTableResponse = ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayTableResponse;
using UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response;
using UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result;
using UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response;
using UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result;
using UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response;
using UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result;
using UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response;
using UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response;
using UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result;
using UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse;
using UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse;
using UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response;
using UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result;
using UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse;
using UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse;
using UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response;
using UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result = ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result;


template<>
struct MinSize<UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolStrictTwoWayFieldsResponse> {
  UnknownInteractionsProtocolStrictTwoWayFieldsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>());
    UnknownInteractionsProtocolStrictTwoWayFieldsResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocolStrictTwoWayFieldsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolStrictTwoWayUnionResponse> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocolStrictTwoWayUnionResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolStrictTwoWayUnionResponse>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocolStrictTwoWayUnionResponse out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolStrictTwoWayTableResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolStrictTwoWayTableResponse> {
  UnknownInteractionsProtocolStrictTwoWayTableResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolStrictTwoWayTableResponse>());
    UnknownInteractionsProtocolStrictTwoWayTableResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocolStrictTwoWayTableResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayErr_Response> {
  UnknownInteractionsProtocol_StrictTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayErr_Response>());
    UnknownInteractionsProtocol_StrictTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_StrictTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictTwoWayErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response> {
  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>());
    UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response> {
  UnknownInteractionsProtocol_StrictTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>());
    UnknownInteractionsProtocol_StrictTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictTwoWayTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictTwoWayTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWay_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWay_Response> {
  UnknownInteractionsProtocol_FlexibleTwoWay_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWay_Response>());
    UnknownInteractionsProtocol_FlexibleTwoWay_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleTwoWay_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWay_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWay_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWay_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWay_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWay_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response> {
  UnknownInteractionsProtocol_FlexibleTwoWayFields_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>());
    UnknownInteractionsProtocol_FlexibleTwoWayFields_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFields_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayFields_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayFields_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFields_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayFields_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFields_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response> {
  UnknownInteractionsProtocol_FlexibleTwoWayTable_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>());
    UnknownInteractionsProtocol_FlexibleTwoWayTable_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTable_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayTable_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayTable_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTable_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayTable_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTable_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> {
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>());
    UnknownInteractionsProtocol_FlexibleTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response> {
  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>());
    UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response> {
  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>());
    UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolStrictEventFieldsRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolStrictEventFieldsRequest> {
  UnknownInteractionsProtocolStrictEventFieldsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolStrictEventFieldsRequest>());
    UnknownInteractionsProtocolStrictEventFieldsRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocolStrictEventFieldsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolStrictEventUnionRequest> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolStrictEventUnionRequest> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocolStrictEventUnionRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolStrictEventUnionRequest>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocolStrictEventUnionRequest out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolStrictEventTableRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolStrictEventTableRequest> {
  UnknownInteractionsProtocolStrictEventTableRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolStrictEventTableRequest>());
    UnknownInteractionsProtocolStrictEventTableRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocolStrictEventTableRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventErr_Response> {
  UnknownInteractionsProtocol_StrictEventErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventErr_Response>());
    UnknownInteractionsProtocol_StrictEventErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_StrictEventErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictEventErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictEventErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventFieldsErr_Response> {
  UnknownInteractionsProtocol_StrictEventFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventFieldsErr_Response>());
    UnknownInteractionsProtocol_StrictEventFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_StrictEventFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictEventFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictEventFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictEventUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictEventUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictEventUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictEventUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventTableErr_Response> {
  UnknownInteractionsProtocol_StrictEventTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventTableErr_Response>());
    UnknownInteractionsProtocol_StrictEventTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_StrictEventTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_StrictEventTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_StrictEventTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_StrictEventTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_StrictEventTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_StrictEventTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolFlexibleEventFieldsRequest> {
  UnknownInteractionsProtocolFlexibleEventFieldsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolFlexibleEventFieldsRequest>());
    UnknownInteractionsProtocolFlexibleEventFieldsRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocolFlexibleEventFieldsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolFlexibleEventUnionRequest> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolFlexibleEventUnionRequest> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocolFlexibleEventUnionRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolFlexibleEventUnionRequest>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocolFlexibleEventUnionRequest out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocolFlexibleEventTableRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocolFlexibleEventTableRequest> {
  UnknownInteractionsProtocolFlexibleEventTableRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocolFlexibleEventTableRequest>());
    UnknownInteractionsProtocolFlexibleEventTableRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocolFlexibleEventTableRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventErr_Response> {
  UnknownInteractionsProtocol_FlexibleEventErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventErr_Response>());
    UnknownInteractionsProtocol_FlexibleEventErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleEventErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleEventErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleEventErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response> {
  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>());
    UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleEventFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleEventUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleEventUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleEventUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleEventUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventTableErr_Response> {
  UnknownInteractionsProtocol_FlexibleEventTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventTableErr_Response>());
    UnknownInteractionsProtocol_FlexibleEventTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsProtocol_FlexibleEventTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsProtocol_FlexibleEventTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsProtocol_FlexibleEventTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsProtocol_FlexibleEventTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsProtocol_FlexibleEventTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsProtocol_FlexibleEventTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse> {
  UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>());
    UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse> {
  UnknownInteractionsAjarProtocolStrictTwoWayTableResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>());
    UnknownInteractionsAjarProtocolStrictTwoWayTableResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocolStrictTwoWayTableResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> {
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>());
    UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response> {
  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>());
    UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response> {
  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>());
    UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolStrictEventFieldsRequest> {
  UnknownInteractionsAjarProtocolStrictEventFieldsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>());
    UnknownInteractionsAjarProtocolStrictEventFieldsRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocolStrictEventFieldsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolStrictEventUnionRequest> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocolStrictEventUnionRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolStrictEventUnionRequest>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocolStrictEventUnionRequest out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolStrictEventTableRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolStrictEventTableRequest> {
  UnknownInteractionsAjarProtocolStrictEventTableRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolStrictEventTableRequest>());
    UnknownInteractionsAjarProtocolStrictEventTableRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocolStrictEventTableRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventErr_Response> {
  UnknownInteractionsAjarProtocol_StrictEventErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventErr_Response>());
    UnknownInteractionsAjarProtocol_StrictEventErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_StrictEventErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictEventErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictEventErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response> {
  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>());
    UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictEventUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response> {
  UnknownInteractionsAjarProtocol_StrictEventTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>());
    UnknownInteractionsAjarProtocol_StrictEventTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_StrictEventTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_StrictEventTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_StrictEventTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_StrictEventTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_StrictEventTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest> {
  UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>());
    UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocolFlexibleEventUnionRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolFlexibleEventUnionRequest>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocolFlexibleEventUnionRequest out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocolFlexibleEventTableRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocolFlexibleEventTableRequest> {
  UnknownInteractionsAjarProtocolFlexibleEventTableRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocolFlexibleEventTableRequest>());
    UnknownInteractionsAjarProtocolFlexibleEventTableRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocolFlexibleEventTableRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> {
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>());
    UnknownInteractionsAjarProtocol_FlexibleEventErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_FlexibleEventErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response> {
  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>());
    UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response> {
  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>());
    UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse> {
  UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>());
    UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse> {
  UnknownInteractionsClosedProtocolStrictTwoWayTableResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>());
    UnknownInteractionsClosedProtocolStrictTwoWayTableResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocolStrictTwoWayTableResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> {
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>());
    UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response> {
  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>());
    UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response> {
  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>());
    UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocolStrictEventFieldsRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocolStrictEventFieldsRequest> {
  UnknownInteractionsClosedProtocolStrictEventFieldsRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>());
    UnknownInteractionsClosedProtocolStrictEventFieldsRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocolStrictEventFieldsRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocolStrictEventUnionRequest> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocolStrictEventUnionRequest> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocolStrictEventUnionRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocolStrictEventUnionRequest>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocolStrictEventUnionRequest out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocolStrictEventTableRequest> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocolStrictEventTableRequest> {
  UnknownInteractionsClosedProtocolStrictEventTableRequest operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocolStrictEventTableRequest>());
    UnknownInteractionsClosedProtocolStrictEventTableRequest out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocolStrictEventTableRequest>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventErr_Response> {
  UnknownInteractionsClosedProtocol_StrictEventErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventErr_Response>());
    UnknownInteractionsClosedProtocol_StrictEventErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocol_StrictEventErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictEventErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictEventErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response> {
  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>());
    UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictEventUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response> {
  UnknownInteractionsClosedProtocol_StrictEventTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>());
    UnknownInteractionsClosedProtocol_StrictEventTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedProtocol_StrictEventTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedProtocol_StrictEventTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedProtocol_StrictEventTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedProtocol_StrictEventTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedProtocol_StrictEventTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse> {
  UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>());
    UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocolStrictTwoWayFieldsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocolStrictTwoWayUnionResponse out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse> {
  UnknownInteractionsDriverProtocolStrictTwoWayTableResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>());
    UnknownInteractionsDriverProtocolStrictTwoWayTableResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocolStrictTwoWayTableResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> {
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>());
    UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response> {
  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>());
    UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response> {
  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>());
    UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> {
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>());
    UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response> {
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>());
    UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFields_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnion_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response> {
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>());
    UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTable_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> {
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>());
    UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response> {
  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>());
    UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response> {
  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>());
    UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>(), MinSize<int32_t>(), MinSize<::fidl::FrameworkErr>()};
    return 1 + *std::max_element(sizes, sizes + 3 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result> {
  static_assert(3 > 0, "xunion must have at least one member");

  UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Result out;
    switch (selector % 3) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
      case 2: {
        out.set_framework_err(Allocate<::fidl::FrameworkErr>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse> {
  UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>());
    UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayFieldsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarDriverProtocolStrictTwoWayUnionResponse out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse> {
  UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>());
    UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarDriverProtocolStrictTwoWayTableResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> {
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>());
    UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response> {
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>());
    UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response> {
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>());
    UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse> {
  UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>());
    UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayFieldsResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedDriverProtocolStrictTwoWayUnionResponse out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse> {
  UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>());
    UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedDriverProtocolStrictTwoWayTableResponse>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> {
  operator size_t() {
    return MinSize<uint8_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> {
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>());
    UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<uint8_t>() + slack_per_member;
    out.__reserved = Allocate<uint8_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response> {
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>());
    UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.some_field = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayFieldsErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response> {
  static_assert(1 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response out;
    switch (selector % 1) {
      case 0: {
        out.set_some_field(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayUnionErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response> {
  operator size_t() {
    return MinSize<int32_t>();
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response> {
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>());
    UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response out;
    const size_t slack_per_member = (*size - MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.set_some_field(Allocate<int32_t>{}(src, &out_size));
    return out;
  }
};
template<>
struct MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>(), MinSize<int32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template<>
struct Allocate<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(Allocate<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayTableErr_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<int32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};

}  // namespace fuzzing
