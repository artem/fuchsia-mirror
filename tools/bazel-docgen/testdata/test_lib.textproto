rule_info {
  rule_name: "empty"
  doc_string: "Just an empty rule"
  attribute {
    name: "name"
    doc_string: "A unique name for this target."
    type: NAME
    mandatory: true
  }
  origin_key {
    name: "empty"
    file: "//tools/bazel-docgen/testdata/foo:foo_internal.bzl"
  }
}
provider_info {
  provider_name: "FooInfo"
  doc_string: "Some provider"
  field_info {
    name: "contents"
    doc_string: "Some contents"
  }
  origin_key {
    name: "FooInfo"
    file: "//tools/bazel-docgen/testdata:foo.bzl"
  }
}
func_info {
  function_name: "some_function"
  parameter {
    name: "name"
    mandatory: true
  }
  doc_string: "a starlark function"
  origin_key {
    name: "some_function"
    file: "//tools/bazel-docgen/testdata:foo.bzl"
  }
}
module_docstring: "Public definitions for the foo library"
file: "//tools/bazel-docgen/testdata:foo.bzl"
repository_rule_info {
  rule_name: "empty_repo"
  doc_string: "Just an empty repository rule"
  attribute {
    name: "name"
    doc_string: "A unique name for this repository."
    type: NAME
    mandatory: true
  }
  attribute {
    name: "repo_mapping"
    doc_string: "In `WORKSPACE` context only: a dictionary from local repository name to global repository name. This allows controls over workspace dependency resolution for dependencies of this repository.\n\nFor example, an entry `\"@foo\": \"@bar\"` declares that, for any time this repository depends on `@foo` (such as a dependency on `@foo//some:target`, it should actually resolve that dependency within globally-declared `@bar` (`@bar//some:target`).\n\nThis attribute is _not_ supported in `MODULE.bazel` context (when invoking a repository rule inside a module extension\'s implementation function)."
    type: STRING_DICT
  }
  origin_key {
    name: "empty_repo"
    file: "//tools/bazel-docgen/testdata/foo:foo_internal.bzl"
  }
}
